@@  cgi_pars.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:51:02 PM BST  --
+---------------------------------------------------------------------
+--(class_description.ADS) Implementation Instantiation
+
+--
+-- Split the components of a CGI result string into
+--  individual sub strings
+--
+-- For example the string
+--   name=Your+name&action=%2B10%25&log=~mas/log
+--
+-- is composed of three named elements:
+--
+--     Element    String associated with element
+--     name       Your name
+--     action     +10%
+--     log        /usr/staff/mas/log
+--
+-- (C) M.A.Smith University of Brighton
+-- Permission is granted to use this code
+--   provided this declaration and copyright notice remains intact.
+-- 4 January 1996
+--
+--
+--
+-- S p e c i f i c a t i o n
+
+
+with Ada.Text_Io, Ada.Integer_Text_Io, Ada.Strings.Unbounded;
+use  Ada.Text_Io, Ada.Integer_Text_Io, Ada.Strings.Unbounded;
+package Class_Parse is
+  type Parse is private;
+  procedure Set( The:in out Parse; Mes:in String );
+  function  Get_Item( The:in Parse; Key: in String; Pos:in Integer:=1;
+    Map:in Boolean :=False ) return String;
+private
+  Sep : constant Character := '&';
+  type Parse is record
+    Str : Unbounded_String;            -- String to parse
+    Len : Integer;                     -- Length
+  end record;
+end Class_Parse;
+
+
+
+--
+-- Split the components of a CGI result string into
+--  individual sub strings
+--
+-- For example the string
+--   name=Your+name&action=%2B10%25&log=~mas/log
+--
+-- is composed of three named elements:
+--
+--     Element    String associated with element
+--     name       Your name
+--     action     +10%
+--     log        /usr/staff/mas/log
+--
+-- (C) M.A.Smith University of Brighton
+-- Permission is granted to use this code
+--   provided this declaration and copyright notice remains intact.
+-- 4 January 1996
+--
+--
+-- I m p l e m e n t a t i o n
+
+package body Class_Parse is
+
+  function Remove_Escape(From:in String) return String;
+  function Hex( First, Second :in Character ) return Character;
+
+  procedure Set( The:in out Parse; Mes:in String ) is
+  begin
+    The.Str := To_Unbounded_String(Mes);
+    The.Len := Mes'Length;
+  end Set;
+
+  function Get_Item( The:in Parse; Key: in String; Pos:in Integer:=1;
+      Map:in Boolean :=False ) return String is
+    Cur_Tag   : Integer := 1;
+    I,J       : Integer;
+    Start     : Integer;
+    Parse_Str : String (1 .. The.Len) := To_String( The.Str );
+  begin
+    I := 1;
+    while I < The.Len-Key'Length loop
+      if Parse_Str(I .. I+Key'Length-1) = Key then
+        if Parse_Str(I+Key'Length) = '=' then
+          if Cur_Tag = Pos then
+            Start := I+Key'Length+1; J := Start;
+            while J <= The.Len and then Parse_Str(J) /= Sep loop
+              if J <= The.Len then J := J + 1; end if;
+            end loop;
+            return Remove_Escape( Parse_Str( Start .. J-1 ) );
+          else
+            Cur_Tag := Cur_Tag + 1;
+          end if;
+        end if;
+      end if;
+      I := I + 1;
+    end loop;
+    return "";
+  end Get_Item;
+
+  function Remove_Escape(From:in String) return String is
+    Res : String( 1 .. From'Length );
+    Ch  : Character;
+    I,J : Integer;
+  begin
+    I := From'First; J := 0;
+    while I <= From'Last loop
+      Ch := From(I);
+      case Ch is
+        when '%' =>
+          Ch := Hex(From(I+1), From(I+2) );
+          I:= I+2;
+        when '+' =>
+          Ch := ' ';
+        when others =>
+          null;
+      end case;
+      I := I + 1;
+      J := J + 1; Res(J) := Ch;
+    end loop;
+    return Res(1..J);
+  end Remove_Escape;
+
+  function Hex( First, Second :in Character ) return Character is
+    type Mod256 is mod 256;
+    A_Ch : Mod256;
+    function Hex_Value( Ch:in Character ) return Mod256 is
+    begin
+      if Ch in '0' .. '9' then
+        return Character'Pos(Ch)-Character'Pos('0');
+      end if;
+      if Ch in 'A' .. 'F' then
+        return Character'Pos(Ch)-Character'Pos('A')+10;
+      end if;
+      return 0;
+    end Hex_Value;
+  begin
+    return Character'Val(
+      ( Hex_Value(First) and 16#FF#) * 16 +
+      ( Hex_Value(Second) and 16#FF#) );
+  end Hex;
+
+end Class_Parse;
+
+package Unix_If is
+  function Get_Env( Str:in String ) return String;
+end Unix_If;
+
+with Interfaces.C, Interfaces.C.Strings;
+use  Interfaces.C, Interfaces.C.Strings;
+package body Unix_If is
+
+  function Get_Env( Str:in String ) return String is
+    function Getenv( Str:in Char_Array ) return Chars_Ptr;
+    pragma Import (C, Getenv, "getenv");
+    Res : Chars_Ptr;
+  begin
+    Res := Getenv( To_C( Str, Append_Nul=>True ) );
+    if Res = Null_Ptr then
+      return "";
+    else
+      return Value(Res);
+    end if;
+  end Get_Env;
+
+end Unix_If;
+
+with Ada.Text_Io, Ada.Integer_Text_Io, Ada.Float_Text_Io, Class_Parse, Unix_If, Ada.Strings.Unbounded;
+use  Ada.Text_Io, Ada.Integer_Text_Io, Ada.Float_Text_Io, Class_Parse, Unix_If, Ada.Strings.Unbounded;
+procedure Main is
+  List         : Parse;
+  Query_String : Unbounded_String;      -- String to parse
+
+begin
+  Query_String := To_Unbounded_String( Get_Env( "QUERY_STRING" ) );
+  if ( To_String( Query_String ) = "" ) then
+    Query_String := To_Unbounded_String(
+      "tag=one&"             &
+      "name=mike&"           &
+      "action=%2B10%25&"     &
+      "tag=two&"             &
+      "log=~mas/log&"        &
+      "tag=three" );
+  end if;
+
+  Set( List, To_String(Query_String) ) ;
+
+  Put("name   = "); Put( Get_Item( List, "name" )) ; New_Line;
+  Put("action = "); Put( Get_Item( List, "action" )) ; New_Line;
+  Put("log    = "); Put( Get_Item( List, "log" )) ; New_Line;
+  for I in 1 .. 4 loop
+    Put("tag(" ); Put( I, Width=>1 ); Put( ")  ");
+    Put( Get_Item( List, "tag", I ) ); New_Line;
+  end loop;
+end Main;
@@  cgi_qs.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:51:03 PM BST  --
+---------------------------------------------------------------------
+package Unix_If is
+  function Get_Env( Str:in String ) return String;
+end Unix_If;
+
+with Interfaces.C, Interfaces.C.Strings;
+use  Interfaces.C, Interfaces.C.Strings;
+package body Unix_If is
+
+  function Get_Env( Str:in String ) return String is
+    function Getenv( Str:in Char_Array ) return Chars_Ptr;
+    pragma Import (C, Getenv, "getenv");
+    Res : Chars_Ptr;
+  begin
+    Res := Getenv( To_C( Str, Append_Nul=>True ) );
+    if Res = Null_Ptr then
+      return "";
+    else
+      return Value(Res);
+    end if;
+  end Get_Env;
+
+end Unix_If;
+
+with Ada.Text_Io, Ada.Integer_Text_Io, Ada.Float_Text_Io, Unix_If;
+use  Ada.Text_Io, Ada.Integer_Text_Io, Ada.Float_Text_Io, Unix_If;
+procedure Main is
+begin
+  New_Line;
+  Put( "Content-type: text/plain" ); New_Line(2);
+  Put( "<HTML>  " ); New_Line;
+  Put( "<HEAD>  " ); New_Line;
+  Put( "</HEAD> " ); New_Line;
+  Put( "<BODY>  " ); New_Line;
+  Put( "<P>" );      New_Line;
+  Put( "The data sent to the form processing program " ); New_Line;
+  Put( "in the environment variable QUERY_STRING is:" ); New_Line;
+  Put( "<P>" ); New_Line;
+  Put( Get_Env( "QUERY_STRING" ) ); New_Line;
+  Put( "<P>" ); New_Line;
+  Put( "</BODY>  " ); New_Line;
+  Put( "</HTML>  " ); New_Line;
+end Main;
+
@@  x00_cd.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:41 PM BST  --
+---------------------------------------------------------------------
+--[main.adb] Procedure
+with Ada.Text_Io;                  -- With package Text_Io
+use  Ada.Text_Io;                  -- Use  components
+
+procedure Main1 is
+  Count : Integer;                 -- Declaration of count
+begin
+  Count := 10;                     -- Set to 10
+  while Count > 0 loop             -- loop while greater than 0
+    if Count = 3 then              -- If 3 print Ignition
+      Put("Ignition"); New_Line;
+    end if;
+    Put( Integer'Image( Count ) ); -- Print current count
+    New_Line;
+    Count := Count - 1;            -- Decrement by 1 count
+    delay 1.0;                     -- Wait 1 second
+  end loop;
+  Put("Blast off"); New_Line;      -- Print Blast off
+
+end Main1;
+
+--[main.adb] Procedure
+with Ada.Text_Io;
+use  Ada.Text_Io;
+procedure Main2 is
+  type Count_Range is range 0 .. 10;
+  Count : Count_Range := 10;           -- Declaration of count
+begin
+  for Count in reverse Count_Range loop
+    if Count = 3 then                  -- If 3 print Ignition
+      Put("Ignition"); New_Line;
+    end if;
+    Put( Count_Range'Image( Count ) ); -- Print current count
+    New_Line;
+    --DELAY 1.0;                       -- Wait 1 second
+  end loop;
+  Put("Blast off"); New_Line;          -- Print Blast off
+
+end Main2;
+
+--[main.adb] Procedure
+with Ada.Text_Io, Main1, Main2;
+use  Ada.Text_Io;
+procedure Main is
+begin
+  Put("Example 1"); New_Line; Main1;
+  Put("Example 2"); New_Line; Main2;
+end Main;
@@  x09_acc2.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:41 PM BST  --
+---------------------------------------------------------------------
+--[class_account.ads] Specification
+package Class_Account is
+
+  type Account is private;
+  subtype Money  is Float;
+  subtype Pmoney is Float range 0.0 .. Float'Last;
+
+  procedure Deposit ( The:in out Account; Amount:in Pmoney );
+  procedure Withdraw( The:in out Account; Amount:in Pmoney;
+                      Get:out Pmoney );
+  function  Balance ( The:in Account ) return Money;
+
+private
+  type Account is record
+    Balance_Of : Money := 0.00;      -- Amount in account
+  end record;
+end Class_Account;
+
+
+--[class_account.adb] Implementation
+package body Class_Account is
+
+
+  procedure Deposit ( The:in out Account; Amount:in Pmoney ) is
+  begin
+    The.Balance_Of := The.Balance_Of + Amount;
+  end Deposit;
+
+  procedure Withdraw( The:in out Account; Amount:in Pmoney;
+                      Get:out Pmoney ) is
+  begin
+    if The.Balance_Of >= Amount then
+      The.Balance_Of := The.Balance_Of - Amount;
+      Get := Amount;
+    else
+      Get := 0.00;
+    end if;
+  end Withdraw;
+
+  function  Balance( The:in Account ) return Money is
+  begin
+    return The.Balance_Of;
+  end Balance;
+
+end Class_Account;
+
+--[class_account_other.ads] Specification
+package Class_Account_Other is
+  type Account is private;
+  subtype Money  is Float;
+  procedure Statement( The:in Account );
+
+private
+  type Account is record
+    Amount : Money := 0.00;      -- Amount in account
+  end record;
+end Class_Account_Other;
+
+
+--[class_account_other.adb] Implementation
+with Ada.Text_Io, Ada.Float_Text_Io;
+use  Ada.Text_Io, Ada.Float_Text_Io;
+package body Class_Account_Other is
+
+  procedure Statement( The:in Account ) is
+  begin
+    Put("Other account system "); New_Line(2);
+  end Statement;
+
+end Class_Account_Other;
+
+--[Statement.adb] Procedure
+with Ada.Text_Io, Ada.Float_Text_Io, Class_Account;
+use  Ada.Text_Io, Ada.Float_Text_Io, Class_Account;
+procedure Statement( An_Account:in Account ) is
+begin
+  Put("Mini statement: The amount on deposit is $" );
+  Put( Balance( An_Account), Aft=>2, Exp=>0 );
+  New_Line(2);
+end Statement;
+
+--[main1.adb] Procedure
+with Ada.Text_Io, Class_Account, Statement;
+use  Ada.Text_Io, Class_Account;
+procedure Main1 is
+  My_Account: Account;
+  Obtain    : Money;
+begin
+  Statement( My_Account );
+
+  Put("Deposit $100.00 into account"); New_Line;  -- Deposit
+  Deposit( My_Account, 100.00 );
+  Statement( My_Account );
+
+  Put("Withdraw $80.00 from account"); New_Line;  -- Withdraw
+  Withdraw( My_Account, 80.00, Obtain );
+  Statement( My_Account );
+
+  Put("Deposit $200.00 into account"); New_Line;  -- Deposit
+  Deposit( My_Account, 200.00 );
+  Statement( My_Account );
+
+end Main1;
+
+
+--[main2.adb] Procedure
+with Ada.Text_Io, Class_Account, Statement;
+procedure Main2 is
+  My_Account: Class_Account.Account;
+  Obtain    : Class_Account.Money;
+begin
+  Statement( My_Account );
+
+  Ada.Text_Io.Put("Deposit $100.00 into account");
+  Ada.Text_Io.New_Line;
+  Class_Account.Deposit( My_Account, 100.00 );
+  Statement( My_Account );
+
+  Ada.Text_Io.Put("Withdraw $80.00 from account");
+  Ada.Text_Io.New_Line;
+  Class_Account.Withdraw( My_Account, 80.00, Obtain );
+  Statement( My_Account );
+
+  Ada.Text_Io.Put("Deposit $200.00 into account");
+  Ada.Text_Io.New_Line;
+  Class_Account.Deposit( My_Account, 200.00 );
+  Statement( My_Account );
+
+end Main2;
+
+
+--[main3.adb] Procedure
+with Class_Account, Class_Account_Other, Statement;
+use  Class_Account, Class_Account_Other;
+procedure Main3 is
+  My_Account    :Class_Account.Account;
+  Other_Account :Class_Account_Other.Account;
+begin
+  Statement( My_Account );    -- statement in Class_account
+  Statement( Other_Account ); -- statement in Class_account_other
+end Main3;
+
+--[main4.adb] Procedure
+with Class_Account;
+use  Class_Account;
+procedure Main4 is
+  My_Account   : Account;
+  Other_Account: Account;
+  Obtain       : Pmoney;
+begin
+  Deposit( My_Account, 100.00 );
+  Other_Account := My_Account;            -- Copy and
+  Withdraw(Other_Account, 100.00, Obtain);-- Withdraw 100.00
+
+  Other_Account := My_Account;            -- Copy again and
+  Withdraw(Other_Account, 100.00, Obtain);-- Withdraw 100.00
+
+end Main4;
+
+--[main.adb] Procedure
+with Ada.Text_Io, Main1, Main2, Main3, Main4;
+use  Ada.Text_Io;
+procedure Main is
+begin
+  Put("Example Account 1 "); New_Line; Main1;
+  Put("Example Account 2 "); New_Line; Main2;
+  Put("Example Account 3 "); New_Line; Main3;
+  Put("Example Account 4 "); New_Line; Main4;
+end Main;
@@  x11_acc3.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:42 PM BST  --
+---------------------------------------------------------------------
+--[class_account.ads] Specification
+package Class_Account is
+  type Account is private;
+  subtype Money  is Float;
+  subtype Pmoney is Float range 0.0 .. Float'Last;
+
+  procedure Deposit( The:in out Account; Amount:in Pmoney );
+  procedure Withdraw( The:in out Account;
+                      Amount:in Pmoney; Get:out Pmoney );
+  function  Balance( The:in Account ) return Money;
+private
+  type Account is record
+    Balance_Of : Money := 0.00;           -- Amount on deposit
+  end record;
+end Class_Account;
+
+
+--[class_account.adb] Implementation
+package body Class_Account is
+
+  procedure Deposit( The:in out Account; Amount:in Pmoney ) is
+  begin
+    The.Balance_Of := The.Balance_Of + Amount;
+  end Deposit;
+
+  procedure Withdraw( The:in out Account;
+                      Amount:in Pmoney; Get:out Pmoney ) is
+  begin
+    if The.Balance_Of >= Amount then
+      The.Balance_Of := The.Balance_Of - Amount;
+      Get := Amount;
+    else
+      Get := 0.00;
+    end if;
+  end Withdraw;
+
+  function  Balance( The:in Account ) return Money is
+  begin
+    return The.Balance_Of;
+  end Balance;
+
+end Class_Account;
+
+
+--[class_tui.ads] Specification
+package Class_Tui is
+
+  type Menu_Item is ( M_1, M_2, M_3, M_4, M_Quit );
+  type Tui is private;
+
+  procedure Menu( The:in out Tui; M1,M2,M3,M4:in String );
+  function  Event( The:in Tui ) return Menu_Item;
+  procedure Message( The:in Tui; Mes:in String );
+  procedure Dialog(The:in Tui; Mes:in String; Res:out Float);
+
+private
+  type Tui is record
+    Selection : Menu_Item := M_Quit;
+  end record;
+end Class_Tui;
+
+--[class_tui.adb] Implementation
+with Ada.Text_Io, Ada.Integer_Text_Io, Ada.Float_Text_Io;
+use  Ada.Text_Io, Ada.Integer_Text_Io, Ada.Float_Text_Io;
+package body Class_Tui is
+  procedure Menu( The:in out Tui; M1,M2,M3,M4:in String ) is
+
+    Selection      : Character;
+    Valid_Response : Boolean := False;
+
+    procedure Set_Response(Choice:in Menu_Item; Mes:in String) is
+    begin
+      if Mes /= "" then               -- Allowable choice
+        The.Selection := Choice; Valid_Response := True;
+      end if;
+    end Set_Response;
+
+    procedure Display_Menu_Item(Prompt, Name:in String) is
+    begin
+      if Name/="" then Put(Prompt & Name); New_Line(2); end if;
+    end Display_Menu_Item;
+
+  begin
+    while not Valid_Response loop
+      Display_Menu_Item( "[a]  ", M1 );
+      Display_Menu_Item( "[b]  ", M2 );
+      Display_Menu_Item( "[c]  ", M3 );
+      Display_Menu_Item( "[d]  ", M4 );
+      Put( "Input selection: "); Get( Selection ); Skip_Line;
+      case Selection is
+        when 'a' | 'A' => Set_Response( M_1, M1 );
+        when 'b' | 'B' => Set_Response( M_2, M2 );
+        when 'c' | 'C' => Set_Response( M_3, M3 );
+        when 'd' | 'D' => Set_Response( M_4, M4 );
+        when 'e' | 'E' => Set_Response( M_Quit, "Quit" );
+        when others    => Valid_Response := False;
+      end case;
+      if not Valid_Response then
+        Message( The, "Invalid response" );
+      end if;
+    end loop;
+  end Menu;
+
+  function  Event( The:in Tui ) return Menu_Item is
+  begin
+    return The.Selection;
+  end;
+
+  procedure Message( The:in Tui; Mes:in String ) is
+  begin
+    New_Line; Put( Mes ); New_Line;
+  end Message;
+
+  procedure Dialog(The:in Tui; Mes:in String; Res:out Float) is
+  begin
+    New_Line(1); Put( Mes & " : " );
+    Get( Res ); Skip_Line;
+  end Dialog;
+
+  procedure Dialog(The:in Tui; Mes:in String; Res:out Integer) is
+  begin
+    New_Line(1); Put( Mes & " : " );
+    Get( Res ); Skip_Line;
+  end Dialog;
+
+end Class_Tui;
+
+--===============================================================
+
+--[class_container.ads] Specification
+package Class_Container is
+  procedure Main1;
+  procedure Main2;
+end Class_Container;
+
+--[class_container.adb] Implementation
+with Ada.Text_Io, Ada.Float_Text_Io, Class_Account, Class_Tui;
+use  Ada.Text_Io, Ada.Float_Text_Io, Class_Account, Class_Tui;
+package body Class_Container is
+
+  procedure Main1 is
+    Miles  : Float;
+    Screen : Tui;
+    function Float_Image( F:in Float ) return String is
+      Res : String( 1 .. 10 );        -- String of 10 characters
+    begin
+      Put( Res, F, Aft=>2, Exp=>0 );  -- 2 digits - NO exp
+      return Res;
+    end Float_Image;
+  begin
+    Message( Screen, "Distance converter" );
+    Dialog ( Screen, "Enter distance in miles", Miles );
+    Message( Screen, "Distance in kilometers is " &
+      Float'Image( Miles * 1.6093 )  );
+    Message( Screen, "Distance in kilometers is " &
+      Float_Image( Miles * 1.6093 )  );
+  end Main1;
+
+  procedure Main2 is
+    User     : Account;            -- The users account
+    Screen   : Tui;                -- The display screen
+    Cash     : Money;              --
+    Received : Money;              --
+
+    function Float_Image( F:in Float ) return String is
+      Res : String( 1 .. 10 );     -- String of 10 characters
+    begin
+      Put( Res, F, 2, 0 );         -- 2 digits - NO exp
+      return Res;
+    end Float_Image;
+
+  begin
+    loop
+      Menu( Screen, "Deposit", "Withdraw", "Balance", "" );
+      case Event( Screen ) is
+        when M_1 =>                                    -- Deposit
+          Dialog( Screen, "Amount to deposit", Cash );
+          if Cash <= 0.0 then
+            Message( Screen, "Must be >= 0.00" );
+          else
+            Deposit( User, Cash );
+          end if;
+        when M_2 =>                                     -- Withdraw
+          Dialog( Screen, "Amount to withdraw", Cash );
+          if Cash <= 0.0 then
+            Message( Screen, "Must be >= 0.00" );
+          else
+            Withdraw( User, Cash, Received );
+            if Received <= 0.0 then
+              Message( Screen, "Not enough money" );
+            end if;
+          end if;
+        when M_3 =>                                    -- Balance
+          Message( Screen, "Balance is " &
+            Float_Image( Balance(User)) );
+        when M_Quit =>                                 -- Exit
+          return;
+        when others =>                                 -- Not used
+          Message( Screen, "Program error");         -- oops
+      end case;
+    end loop;
+  end Main2;
+
+end Class_Container;
+
+--[main.adb] Procedure
+with Text_Io, Class_Container;
+use  Text_Io, Class_Container;
+procedure Main is
+begin
+  Put("Example 1"); New_Line; Main1;
+  Put("Example 2"); New_Line; Main2;
+end Main;
@@  x11_acc4.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:42 PM BST  --
+---------------------------------------------------------------------
+--[class_abstract_account.ads] Specification
+package Class_Abstract_Account is
+
+  type Abstract_Account is abstract tagged null record;
+  subtype Money  is Float;
+  subtype Pmoney is Float range 0.0 .. Float'Last;
+
+  procedure Deposit  ( The:in out Abstract_Account;
+                       Amount:in Pmoney ) is abstract;
+  procedure Withdraw ( The:in out Abstract_Account;
+                       Amount:in Pmoney;
+                       Get:out Pmoney ) is abstract;
+  function  Balance  ( The:in Abstract_Account )
+                       return Money is abstract;
+end Class_Abstract_Account;
+
+-- =======================================================
+
+-- FIX
+-- TYPE Abstract_account  IS TAGGED PRIVATE;
+--  MUST BE
+-- TYPE Abstract_account  IS ABSTRACT TAGGED PRIVATE;
+
+--[class_abstract_account.ads] Specification
+package Class_Abstract_Account_Other is
+
+  type Abstract_Account  is abstract tagged private;
+  type Abstract_Account2 is abstract tagged private;
+  subtype Money  is Float;
+  subtype Pmoney is Float range 0.0 .. Float'Last;
+
+  procedure Deposit  ( The:in out Abstract_Account;
+                       Amount:in Pmoney ) is abstract;
+  procedure Withdraw ( The:in out Abstract_Account;
+                       Amount:in Pmoney;
+                       Get:out Pmoney ) is abstract;
+  function  Balance  ( The:in Abstract_Account )
+                       return Money is abstract;
+private
+  type Abstract_Account  is abstract tagged record null; end record;
+  type Abstract_Account2 is abstract tagged null record;
+end Class_Abstract_Account_Other;
+
+-- =======================================================
+
+--[class_account.ads] Specification
+with Class_Abstract_Account;
+use  Class_Abstract_Account;
+package Class_Account is
+
+  type Account is new Abstract_Account with private;
+  subtype Money  is Class_Abstract_Account.Money;
+  subtype Pmoney is Class_Abstract_Account.Pmoney;
+
+  procedure Deposit  ( The:in out Account; Amount:in Pmoney );
+  procedure Withdraw ( The:in out Account; Amount:in Pmoney;
+                       Get:out Pmoney );
+  function  Balance  ( The:in Account ) return Money;
+private
+  type Account is new Abstract_Account with record
+    Balance_Of : Money := 0.00;       -- Amount in account
+  end record;
+end Class_Account;
+
+
+--[class_account.adb] Implementation
+package body Class_Account is
+
+
+  procedure Deposit( The:in out Account; Amount:in Pmoney ) is
+  begin
+    The.Balance_Of := The.Balance_Of + Amount;
+  end Deposit;
+
+  procedure Withdraw( The:in out Account;
+      Amount:in Pmoney; Get:out Pmoney ) is
+  begin
+    if The.Balance_Of >= Amount then
+      The.Balance_Of := The.Balance_Of - Amount;
+      Get := Amount;
+    else
+      Get := 0.00;
+    end if;
+  end Withdraw;
+
+  function  Balance( The:in Account ) return Money is
+  begin
+    return The.Balance_Of;
+  end Balance;
+
+end Class_Account;
+
+-- =======================================================
+
+--[class_interest_account.ads] Specification
+with Class_Account;
+use  Class_Account;
+package Class_Interest_Account is
+
+  type Interest_Account is new Account with private;
+
+  procedure Set_Rate( Rate:in Float );
+  procedure Calc_Interest( The:in out Interest_Account );
+  procedure Add_Interest( The:in out Interest_Account );
+private
+  Daily_Interest_Rate: constant Float := 0.00026116; -- 10%
+  type Interest_Account is new Account with record
+    Accumulated_Interest : Money := 0.00;            -- To date
+  end record;
+  The_Interest_Rate      : Float := Daily_Interest_Rate;
+end Class_Interest_Account;
+
+
+--[class_interest_account.adb] Implementation
+package body Class_Interest_Account is
+
+  procedure Set_Rate( Rate:in Float ) is
+  begin
+    The_Interest_Rate := Rate;
+  end Set_Rate;
+
+  procedure Calc_Interest( The:in out Interest_Account ) is
+  begin
+    The.Accumulated_Interest := The.Accumulated_Interest +
+      Balance(The) * The_Interest_Rate;
+  end Calc_Interest;
+
+  procedure Add_Interest( The:in out Interest_Account ) is
+  begin
+    Deposit( The, The.Accumulated_Interest );
+    The.Accumulated_Interest := 0.00;
+  end Add_Interest;
+
+end Class_Interest_Account;
+
+-- =======================================================
+--[class_account_ltd.ads] Specification
+with Class_Account;
+use  Class_Account;
+package Class_Account_Ltd is
+
+  type Account_Ltd is new Account with private;
+
+  procedure Withdraw ( The:in out Account_Ltd;
+                       Amount:in Pmoney; Get:out Pmoney );
+  procedure Reset( The:in out Account_Ltd );
+private
+  Withdrawals_In_A_Week : Natural := 3;
+  type Account_Ltd is new Account with record
+    Withdrawals : Natural := Withdrawals_In_A_Week;
+  end record;
+end Class_Account_Ltd;
+
+
+--[class_account_ltd.adb] Implementation
+package body Class_Account_Ltd is
+
+  procedure Withdraw ( The:in out Account_Ltd;
+      Amount:in Pmoney; Get:out Pmoney ) is
+  begin
+    if The.Withdrawals > 0 then               -- Not limit
+      The.Withdrawals := The.Withdrawals - 1;
+      Withdraw( Account(The), Amount, Get );  -- In Account
+    else
+      Get := 0.00;                             -- Sorry
+    end if;
+  end Withdraw;
+
+  procedure Reset( The:in out Account_Ltd ) is
+  begin
+    The.Withdrawals := Withdrawals_In_A_Week;
+  end Reset;
+
+end Class_Account_Ltd;
+
+with Ada.Text_Io, Ada.Float_Text_Io, Class_Account;
+use  Ada.Text_Io, Ada.Float_Text_Io, Class_Account;
+procedure Statement( An_Account:in Account ) is
+begin
+  Put("Mini statement: The amount on deposit is $" );
+  Put( Balance( An_Account), Aft=>2, Exp=>0 );
+  New_Line(2);
+end Statement;
+
+
+-- =======================================================
+-- Can not have abstract account as now two definitions for PMoney
+
+--[pack_procedures.ads] Specification
+with Ada.Text_Io, Ada.Float_Text_Io,
+     Class_Account, Class_Interest_Account, Class_Account_Ltd,
+     Statement;
+use  Ada.Text_Io, Ada.Float_Text_Io,
+     Class_Account, Class_Interest_Account, Class_Account_Ltd;
+package Pack_Procedures is
+  procedure Ex1;
+  procedure Ex2;
+  procedure Ex3;
+  procedure Ex4;
+end Pack_Procedures;
+
+
+--[pack_procedures.adb] Implementation
+package body Pack_Procedures is
+
+  procedure Ex1 is
+    Mike  : Interest_Account;
+    Obtain: Money;
+  begin
+    Statement( Account(Mike) );
+    Withdraw( Mike, 100.00, Obtain );   -- Withdraw some money
+    Statement( Account(Mike) );
+    Deposit( Account(Mike), 300.00 );   -- In credit
+    Statement( Account(Mike) );
+  end Ex1;
+
+  procedure Ex2 is
+    Mike  : Account_Ltd;
+    Obtain: Money;
+  begin
+    Deposit( Mike, 300.00 );          -- In credit
+    Statement( Account(Mike) );
+    Withdraw( Mike, 100.00, Obtain ); -- Withdraw some money
+    Withdraw( Mike,  10.00, Obtain ); -- Withdraw some money
+    Withdraw( Mike,  10.00, Obtain ); -- Withdraw some money
+    Withdraw( Mike,  20.00, Obtain ); -- Withdraw some money
+    Statement( Account(Mike) );
+  end Ex2;
+
+  procedure Ex3 is
+    Mike  : Account_Ltd;
+    Obtain: Money;
+  begin
+    Deposit( Mike, 300.00 );          -- In credit
+    Statement( Account(Mike) );
+    Withdraw( Mike, 100.00, Obtain ); -- Withdraw some money
+    Statement( Account(Mike) );
+    Withdraw( Mike,  10.00, Obtain ); -- Withdraw some money
+    Statement( Account(Mike) );
+    Withdraw( Mike,  10.00, Obtain ); -- Withdraw some money
+    Statement( Account(Mike) );
+    Withdraw( Account(Mike),  20.00, Obtain ); -- Cheat
+    Statement( Account(Mike) );
+  end Ex3;
+
+  procedure Ex4 is
+    Max_Accounts : constant := 5;
+    type P_Account is access all Account'Class;
+
+    type    Bank_Index is range 1 .. Max_Accounts;
+    type    Bank_Array is array ( Bank_Index ) of P_Account;
+
+    procedure Print_Statement( No:in Bank_Index;
+                               An_Account:in Account'Class ) is
+    begin
+      Put("Mini Statement for account number #" & 
+          Integer'Image(Integer(No)) );
+      New_Line;
+      Put("The amount in deposit is $" );
+      Put( Balance( An_Account ), Aft=>2, Exp=>0 );
+      New_Line(2);
+    end Print_Statement;
+
+    Piggy    : Bank_Array;
+    Obtained : Money;
+
+  begin
+    Piggy(1) := new Account;
+    Piggy(2) := new Account_Ltd;
+    Piggy(3) := new Interest_Account;
+    Piggy(4) := new Interest_Account;
+    Piggy(5) := new Account;
+
+
+    Deposit( Piggy(1).all, 100.00 );        -- deposit $100 #1
+    Deposit( Piggy(3).all, 100.00 );        -- deposit $100 #3
+
+    Withdraw( Piggy(2).all, 50.00, Obtained ); -- withdraw $50 #2
+    Withdraw( Piggy(4).all, 50.00, Obtained ); -- withdraw $50 #4
+
+    for I in Bank_Index loop
+      Print_Statement( I, Piggy(I).all );
+    end loop;
+    null;
+  end Ex4;
+
+end Pack_Procedures;
+
+--[main.adb] Procedure
+with Ada.Text_Io, Pack_Procedures;
+use  Ada.Text_Io, Pack_Procedures;
+procedure Main is
+begin
+  Put("Example 1"); New_Line; Ex1;
+  Put("Example 2"); New_Line; Ex2;
+  Put("Example 3"); New_Line; Ex3;
+  Put("Example 4"); New_Line; Ex4;
+end Main;
@@  x11_acc5.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:43 PM BST  --
+---------------------------------------------------------------------
+
+--[class_abstract_account.ads] Specification
+package Class_Abstract_Account is
+
+  type Abstract_Account is abstract tagged null record;
+  subtype Money  is Float;
+  subtype Pmoney is Float range 0.0 .. Float'Last;
+
+  procedure Statement( The:in Abstract_Account ) is abstract;
+  procedure Deposit  ( The:in out Abstract_Account;
+                       Amount:in Pmoney ) is abstract;
+  procedure Withdraw ( The:in out Abstract_Account;
+                       Amount:in Pmoney;
+                       Get:out Pmoney ) is abstract;
+  function  Balance  ( The:in Abstract_Account )
+                       return Money is abstract;
+end Class_Abstract_Account;
+
+-- =======================================================
+
+--[class_account.ads] Specification
+with Class_Abstract_Account;
+use  Class_Abstract_Account;
+package Class_Account is
+
+  type Account is new Abstract_Account with private;
+  subtype Money  is Class_Abstract_Account.Money;
+  subtype Pmoney is Class_Abstract_Account.Pmoney;
+
+  procedure Statement( The:in Account );
+  procedure Deposit  ( The:in out Account; Amount:in Pmoney );
+  procedure Withdraw ( The:in out Account; Amount:in Pmoney;
+                       Get:out Pmoney );
+  function  Balance  ( The:in Account ) return Money;
+private
+  type Account is new Abstract_Account with record
+    Balance_Of : Money := 0.00;       -- Amount in account
+  end record;
+end Class_Account;
+
+
+--[class_account.adb] Implementation
+with Ada.Text_Io, Ada.Float_Text_Io;
+use  Ada.Text_Io, Ada.Float_Text_Io;
+package body Class_Account is
+
+  procedure Statement( The:in Account ) is
+  begin
+    Put("Mini statement: The amount on deposit is $" );
+    Put( The.Balance_Of, Aft=>2, Exp=>0 );
+    New_Line(2);
+  end Statement;
+
+  procedure Deposit( The:in out Account; Amount:in Pmoney ) is
+  begin
+    The.Balance_Of := The.Balance_Of + Amount;
+  end Deposit;
+
+  procedure Withdraw( The:in out Account;
+      Amount:in Pmoney; Get:out Pmoney ) is
+  begin
+    if The.Balance_Of >= Amount then
+      The.Balance_Of := The.Balance_Of - Amount;
+      Get := Amount;
+    else
+      Get := 0.00;
+    end if;
+  end Withdraw;
+
+  function  Balance( The:in Account ) return Money is
+  begin
+    return The.Balance_Of;
+  end Balance;
+
+end Class_Account;
+
+-- =======================================================
+
+--[class_interest_account.ads] Specification
+with Class_Account;
+use  Class_Account;
+package Class_Interest_Account is
+
+  type Interest_Account is new Account with private;
+
+  procedure Set_Rate( Rate:in Float );
+  procedure Calc_Interest( The:in out Interest_Account );
+  procedure Add_Interest( The:in out Interest_Account );
+private
+  Daily_Interest_Rate: constant Float := 0.00026116; -- 10%
+  type Interest_Account is new Account with record
+    Accumulated_Interest : Money := 0.00;            -- To date
+  end record;
+  The_Interest_Rate      : Float := Daily_Interest_Rate;
+end Class_Interest_Account;
+
+
+--[class_interest_account.adb] Implementation
+package body Class_Interest_Account is
+
+  procedure Set_Rate( Rate:in Float ) is
+  begin
+    The_Interest_Rate := Rate;
+  end Set_Rate;
+
+  procedure Calc_Interest( The:in out Interest_Account ) is
+  begin
+    The.Accumulated_Interest := The.Accumulated_Interest +
+      Balance(The) * The_Interest_Rate;
+  end Calc_Interest;
+
+  procedure Add_Interest( The:in out Interest_Account ) is
+  begin
+    Deposit( The, The.Accumulated_Interest );
+    The.Accumulated_Interest := 0.00;
+  end Add_Interest;
+
+end Class_Interest_Account;
+
+-- =======================================================
+--[class_interest_account/inspect_interest.ads] Specification
+package Class_Interest_Account.Inspect_Interest is
+  function Interest_Is( The:in Interest_Account )
+    return Money;
+end Class_Interest_Account.Inspect_Interest;
+
+--[class_interest_account/inspect_interest.adb] Implementation
+package body Class_Interest_Account.Inspect_Interest is
+
+  function Interest_Is( The:in Interest_Account )
+      return Money is
+  begin
+    return The.Accumulated_Interest;
+  end Interest_Is;
+
+end Class_Interest_Account.Inspect_Interest;
+
+--[pack_procedures.ads] Specification
+with Ada.Text_Io, Ada.Float_Text_Io, Class_Account, 
+     Class_Interest_Account, Class_Interest_Account.Inspect_Interest;
+use  Ada.Text_Io, Ada.Float_Text_Io, Class_Account, 
+     Class_Interest_Account, Class_Interest_Account.Inspect_Interest; 
+package Pack_Procedures is
+  procedure Ex1;
+  procedure Ex2;
+  procedure Ex3;
+  procedure Ex4;
+end Pack_Procedures;
+
+--[pack_procedures.adb] Implementation
+package body Pack_Procedures is
+
+  procedure Ex1 is
+    My_Account: Interest_Account;
+    Obtained  : Money;
+  begin
+    Statement( My_Account );
+    Put("Deposit 100.00 into account"); New_Line;
+    Deposit( My_Account, 100.00 );            -- Day 1
+    Calc_Interest( My_Account );              -- End of day 1
+    Calc_Interest( My_Account );              -- End of day 2
+    Statement( My_Account );                  -- Day 3
+    Obtained := Interest_Is( My_Account );    -- How much interest
+    Put("Interest accrued so far : $" );
+    Put( Obtained, Aft=>2, Exp=>0 ); New_Line;
+  end Ex1;
+
+  procedure Ex2 is
+  begin
+    null;
+  end Ex2;
+
+  procedure Ex3 is
+  begin
+    null;
+  end Ex3;
+
+  procedure Ex4 is
+  begin
+    null;
+  end Ex4;
+
+end Pack_Procedures;
+
+--[main.adb] Procedure
+with Ada.Text_Io, Ada.Float_Text_Io, Pack_Procedures;
+use  Ada.Text_Io, Ada.Float_Text_Io, Pack_Procedures;
+procedure Main is
+begin
+  Put("Example 1"); New_Line; Ex1;
+  Put("Example 2"); New_Line; Ex2;
+  Put("Example 3"); New_Line; Ex3;
+  Put("Example 4"); New_Line; Ex4;
+end Main;
@@  x11_acc6.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:44 PM BST  --
+---------------------------------------------------------------------
+-- Initialisation of an object item
+-- Remember discriminants must have descreit or access types
+--
+--[class_account.ads] Specification
+package Class_Account is
+
+  subtype Money  is Float;
+  subtype Pmoney is Float range 0.0 .. Float'Last;
+  type Account( Number: Natural:= 0 ) is private;
+
+  procedure Statement( The:in Account );
+  procedure Deposit ( The:in out Account; Amount:in Pmoney );
+  procedure Withdraw( The:in out Account; Amount:in Pmoney;
+    Get:out Pmoney );
+  function  Balance ( The:in Account ) return Money;
+  procedure New_Number( The: in out Account; N:in Natural );
+  function  New_Account( N:in Natural;
+    Amount:in Pmoney:=0.0 ) return Account;
+
+private
+  type Account( Number: Natural:= 0) is record
+    Balance_Of : Float := 0.00;
+  end record;
+end Class_Account;
+
+
+--[class_account.adb] Implementation
+with Ada.Text_Io, Ada.Integer_Text_Io, Ada.Float_Text_Io;
+use  Ada.Text_Io, Ada.Integer_Text_Io, Ada.Float_Text_Io;
+package body Class_Account is
+
+  procedure Statement( The:in Account ) is
+  begin
+    Put("Mini statement: Account #"); Put( The.Number ); New_Line;
+    Put("The amount on deposit is $" );
+    Put( The.Balance_Of, Aft=>2, Exp=>0 );
+    New_Line(2);
+  end Statement;
+
+  procedure Deposit ( The:in out Account; Amount:in Pmoney ) is
+  begin
+    The.Balance_Of := The.Balance_Of + Amount;
+  end Deposit;
+
+  procedure Withdraw( The:in out Account; Amount:in Pmoney;
+      Get:out Pmoney ) is
+  begin
+    if The.Balance_Of >= Amount then
+      The.Balance_Of := The.Balance_Of - Amount;
+      Get := Amount;
+    else
+      Get := 0.00;
+    end if;
+  end Withdraw;
+
+  function  Balance( The:in Account ) return Money is
+  begin
+    return The.Balance_Of;
+  end Balance;
+
+  procedure New_Number( The: in out Account; N:in Natural ) is
+  begin
+    The := Account'( N, The.Balance_Of );
+  end New_Number;
+
+  function  New_Account( N:in Natural;
+      Amount:in Pmoney:=0.0 ) return Account is
+    An_Account : Account := Account'( N, Amount );
+  begin
+    return An_Account;
+  end New_Account;
+
+end Class_Account;
+
+
+--[main1.adb] Procedure
+with Ada.Text_Io, Class_Account;
+use  Ada.Text_Io, Class_Account;
+procedure Main1 is
+  My_Account: Account(10001);
+  Obtain    : Money;
+begin
+  Statement( My_Account );
+
+  Put("Deposit $100.00 into account"); New_Line;  -- Deposit
+  Deposit( My_Account, 100.00 );
+  Statement( My_Account );
+
+  Put("Withdraw $80.00 from account"); New_Line;  -- Withdraw
+  Withdraw( My_Account, 80.00, Obtain );
+  Statement( My_Account );
+
+  Put("Deposit $200.00 into account"); New_Line;  -- Deposit
+  Deposit( My_Account, 200.00 );
+  Statement( My_Account );
+
+end Main1;
+
+
+--[main2.adb] Procedure
+with Ada.Text_Io, Class_Account;
+use  Ada.Text_Io, Class_Account;
+procedure Main2 is
+  My_Account: Account(10001);
+begin
+  begin
+    Deposit( My_Account, 200.00 );
+    Statement( My_Account );
+    New_Number( My_Account, 10002 );
+    Statement( My_Account );
+  exception
+    when Constraint_Error =>
+      Put("raised CONSTRAINT_ERROR It when wrong"); New_Line;
+    when others =>
+      Put("Unknow error"); New_Line;
+  end;
+end Main2;
+
+
+--[main3.adb] Procedure
+with Class_Account;
+use  Class_Account;
+procedure Main3 is
+  My_Account : Account := New_Account( 10001, 20.0 );
+begin
+  Statement( My_Account );
+end Main3;
+
+--[main4.adb] Procedure
+procedure Main4 is
+begin
+  null;
+end Main4;
+
+--[main.adb] Procedure
+with Ada.Text_Io, Main1, Main2, Main3, Main4;
+use  Ada.Text_Io;
+procedure Main is
+begin
+  Put("Example Account 1 "); New_Line; Main1;
+  Put("Example Account 2 "); New_Line; Main2;
+  Put("Example Account 3 "); New_Line; Main3;
+  Put("Example Account 4 "); New_Line; Main4;
+end Main;
@@  x11_mlt.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:44 PM BST  --
+---------------------------------------------------------------------
+--[class_name_address.ads] Specification
+package Class_Name_Address is
+  type Name_Address is tagged private;
+
+  procedure Set( The:out Name_Address; Str:in String );
+  function Deliver_Line( The:in Name_Address;
+                         Line:in Positive ) return String;
+  function Lines( The:in Name_Address ) return Positive;
+private
+  Max_Chs : constant := 200;
+  subtype Line_Index   is Natural    range 0 .. Max_Chs;
+  subtype Line_Range   is Line_Index range 1 .. Max_Chs;
+
+  type Name_Address is tagged record
+    Text   : String( Line_Range );   -- Details
+    Length : Line_Index := 0;        -- Length of address
+  end record;
+end Class_Name_Address;
+
+
+
+
+--[class_name_address.adb] Implementation
+package body Class_Name_Address is
+
+  function Spaces( Line:in Positive ) return String;
+
+  procedure Set( The:out Name_Address; Str:in String ) is
+  begin
+    if Str'Length > Max_Chs then
+      Set( The, Str( Str'First .. Str'First+Max_Chs-1 ) );
+    else
+      The.Text( 1 .. Str'Length ) := Str;
+      The.Length := Str'Length;
+    end if;
+  end Set;
+
+  --  The reason for the line:
+  --      FOR i IN 1 .. Line_range(the.length) LOOP
+  --  is so the compiler will know that the index i can never go outside
+  --  the range of the array so no need to do array bound checking
+
+  function Deliver_Line( The:in Name_Address;
+                         Line:in Positive ) return String is
+                         Line_On : Positive := 1;
+  begin
+    for I in 1 .. The.Length loop
+      if Line_On = Line then
+        for J in I .. The.Length loop
+          if The.Text(J) = '/' then
+            return Spaces(Line_On) & The.Text(I .. J-1);
+          end if;
+        end loop;
+        return Spaces(Line_On) & The.Text(I..The.Length);
+      end if;
+      if The.Text(I) = '/' then Line_On := Line_On+1; end if;
+    end loop;
+    return "";
+  end Deliver_Line;
+
+  function Lines( The:in Name_Address ) return Positive is
+                  No_Lines : Positive := 1;
+  begin
+    for I in  1 .. The.Length loop
+      if The.Text(I) = '/' then No_Lines := No_Lines + 1; end if;
+    end loop;
+    return No_Lines;
+  end Lines;
+
+  function Spaces( Line:in Positive ) return String is
+    Spaces_Are : String( 1 .. Line ) := (others=>' ');
+  begin
+    return Spaces_Are;
+  end Spaces;
+
+end Class_Name_Address;
+
+
+-- =======================================================
+
+
+
+
+
+--[class_account.ads] Specification
+package Class_Account is
+
+  type Account is private;
+  subtype Money  is Float;
+  subtype Pmoney is Float range 0.0 .. Float'Last;
+
+  procedure Deposit ( The:in out Account; Amount:in Pmoney );
+  procedure Withdraw( The:in out Account; Amount:in Pmoney;
+                      Get:out Pmoney );
+  function  Balance ( The:in Account ) return Money;
+
+private
+  type Account is record
+    Balance_Of : Money := 0.00;      -- Amount in account
+  end record;
+end Class_Account;
+
+
+--[class_account.adb] Implementation
+package body Class_Account is
+
+
+  procedure Deposit ( The:in out Account; Amount:in Pmoney ) is
+  begin
+    The.Balance_Of := The.Balance_Of + Amount;
+  end Deposit;
+
+  procedure Withdraw( The:in out Account; Amount:in Pmoney;
+                      Get:out Pmoney ) is
+  begin
+    if The.Balance_Of >= Amount then
+      The.Balance_Of := The.Balance_Of - Amount;
+      Get := Amount;
+    else
+      Get := 0.00;
+    end if;
+  end Withdraw;
+
+  function  Balance( The:in Account ) return Money is
+  begin
+    return The.Balance_Of;
+  end Balance;
+
+end Class_Account;
+
+
+
+
+-- =======================================================
+
+--[class_named_account.ads] Specification
+with Class_Account, Class_Name_Address;
+use  Class_Account, Class_Name_Address;
+package Class_Named_Account is
+
+  type Named_Account is tagged private;
+  subtype Pmoney is Class_Account.Pmoney;
+  subtype Money  is Class_Account.Money;
+
+  procedure Set( The:out Named_Account; Str:in String );
+  function  Deliver_Line( The:in Named_Account;
+                          Line:in Positive ) return String;
+  function  Lines( The:in Named_Account ) return Positive;
+  procedure Deposit( The:in out Named_Account; Amount:in Pmoney );
+  procedure Withdraw( The:in out Named_Account; Amount:in Pmoney;
+                      Get:out Pmoney );
+  function  Balance( The:in Named_Account ) return Pmoney;
+private
+  type Named_Account is tagged record
+    Acc : Account;           -- An account object
+    Naa : Name_Address;      -- A Name and address object
+  end record;
+end Class_Named_Account;
+
+
+
+
+--[class_named_account.adb] Implementation
+package body Class_Named_Account is
+
+  procedure Set( The:out Named_Account; Str:in String ) is
+  begin
+    Set( The.Naa, Str );
+  end Set;
+
+  function Deliver_Line( The:in Named_Account;
+      Line:in Positive ) return String is
+  begin
+    return Deliver_Line( The.Naa, Line );
+  end Deliver_Line;
+
+  function Lines( The:in Named_Account ) return Positive is
+  begin
+    return Lines( The.Naa );
+  end Lines;
+
+
+  procedure Deposit(The:in out Named_Account; Amount:in Pmoney) is
+  begin
+    Deposit( The.Acc, Amount );
+  end Deposit;
+
+  procedure Withdraw( The:in out Named_Account; Amount:in Pmoney;
+      Get:out Pmoney ) is
+  begin
+    Withdraw( The.Acc, Amount, Get );
+  end Withdraw;
+
+  function  Balance  ( The:in Named_Account ) return Pmoney is
+  begin
+    return Balance( The.Acc );
+  end Balance;
+
+end Class_Named_Account;
+
+
+with Ada.Text_Io, Ada.Float_Text_Io, Class_Named_Account;
+use  Ada.Text_Io, Ada.Float_Text_Io, Class_Named_Account;
+procedure Statement( An_Account:in Named_Account ) is
+begin
+  Put("Statement for : " );
+  Put( Deliver_Line( An_Account, 1 ) ); New_Line;
+  Put("Mini statement: The amount on deposit is $" );
+  Put( Balance( An_Account), Aft=>2, Exp=>0 );
+  New_Line(2);
+end Statement;
+
+
+with Class_Named_Account, Statement;
+use  Class_Named_Account;
+procedure Main1 is
+  Mike : Named_Account;
+  Get  : Money;
+begin
+  Set      ( Mike, "A.N.Other/Brighton/UK" );
+  Deposit  ( Mike, 10.00 );
+  Statement( Mike );
+  Withdraw ( Mike, 5.00, Get );
+  Statement( Mike );
+end Main1;
+
+with Ada.Text_Io, Ada.Integer_Text_Io, Class_Name_Address;
+use  Ada.Text_Io, Ada.Integer_Text_Io, Class_Name_Address;
+procedure Main2 is
+  Name    : Name_Address;
+  Address : String := "A.N.Other/Brighton/East Sussex/UK";
+begin
+  Set( Name, Address );
+  Put( Address ); New_Line; Put("There are ");
+  Put( Lines( Name ) ); Put(" lines"); New_Line;
+  for I in 1 .. Lines(Name)+1 loop
+    Put("Line #"); Put(I); Put("  ");
+    Put( Deliver_Line(Name, I) ); New_Line;
+  end loop;
+end Main2;
+
+procedure Main3 is
+begin
+  null;
+end Main3;
+
+procedure Main4 is
+begin
+  null;
+end Main4;
+
+--[main.adb] Procedure
+with Ada.Text_Io, Main1, Main2, Main3, Main4;
+use  Ada.Text_Io;
+procedure Main is
+begin
+  Put("Example 1"); New_Line; Main1;
+  Put("Example 2"); New_Line; Main2;
+  Put("Example 3"); New_Line; Main3;
+  Put("Example 4"); New_Line; Main4;
+end Main;
@@  x11_pol1.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:51:02 PM BST  --
+---------------------------------------------------------------------
+--[class_description.ADS] Implementation Instantiation
+with Ada.Strings.Bounded; use Ada.Strings.Bounded;
+package B_String is new Generic_Bounded_Length( 80 );
+
+
+
+--[class_room.ads] Specification
+with B_String; use B_String;
+package Class_Room is
+  type Room   is tagged private;
+
+  procedure Initialize( The:in out Room; No:in Positive;
+                        Mes:in String );
+  function  Where( The:in Room ) return Positive;
+  function  Describe( The:in Room ) return String;
+private
+  type Room is tagged record
+    Desc  : Bounded_String;     -- Description of room
+    Number: Positive;           -- Room number
+  end record;
+end Class_Room;
+
+
+
+--[class_room.adb] Implementation
+with Ada.Integer_Text_Io;
+use  Ada.Integer_Text_Io;
+package body Class_Room is
+
+  procedure Initialize( The:in out Room;
+                        No:in Positive; Mes:in String ) is
+  begin
+    The.Desc := To_Bounded_String( Mes );
+    The.Number := No;
+  end Initialize;
+
+  function  Where( The:in Room ) return Positive is
+  begin
+    return The.Number;
+  end Where;
+
+  function  Describe( The:in Room ) return String is
+    Num : String( 1 .. 4 );    -- Room number as string
+  begin
+    Put( Num, The.Number );
+    return Num & " " & To_String(The.Desc);
+  end Describe;
+
+end Class_Room;
+
+
+
+
+
+
+--[class_office.ads] Specification
+with Class_Room; 
+use  Class_Room;
+package Class_Office is
+  type Office is new Room with private;
+
+  procedure Initialize( The:in out Office; No:in Positive;
+                        Desc:in String; People:in Natural );
+  function  Deliver_No_Of_People(The:in Office) return Natural;
+  function  Describe( The:in Office ) return String;
+private
+  type Office is new Room with record
+    People : Natural := 0;            -- Occupants
+  end record;
+end Class_Office;
+
+
+
+
+--[class_office.adb] Implementation
+with Ada.Integer_Text_Io;
+use  Ada.Integer_Text_Io;
+package body Class_Office is
+
+  procedure Initialize( The:in out Office; No:in Positive;
+                        Desc:in String; People:in Natural ) is
+  begin
+    Initialize( The, No, Desc );
+    The.People := People;
+  end Initialize;
+
+  function Deliver_No_Of_People( The:in Office ) return Natural is
+  begin
+    return The.People;
+  end Deliver_No_Of_People;
+
+  function  Describe( The:in Office ) return String is
+    No : String( 1 .. 4 );    -- the.people as string
+  begin
+    Put( No, The.People );
+    return Describe( Room(The) ) &
+      " occupied by" & No & " people";
+  end Describe;
+
+end Class_Office;
+
+
+
+
+
+package Class_Room.Build is
+  type P_Room is access all Room'Class;
+
+  function  Build_Room( No:in Positive;
+                        Desc:in String ) return P_Room;
+end Class_Room.Build;
+
+package body Class_Room.Build is
+
+  function  Build_Room( No:in Positive;
+                        Desc:in String ) return P_Room is
+    P : P_Room;
+  begin
+    P := new Room; Initialize( P.all, No, Desc );
+    return P;
+  end Build_Room;
+
+end Class_Room.Build;
+
+
+
+
+
+
+with Class_Room, Class_Room.Build;
+use  Class_Room, Class_Room.Build;
+package Class_Office.Build is
+
+  function  Build_Office( No:in Positive; Desc:in String;
+                          People:in Natural ) return P_Room;
+end Class_Office.Build;
+
+
+package body Class_Office.Build is
+
+  type P_Office is access all Office;
+
+  function  Build_Office( No:in Positive; Desc:in String;
+                          People:in Natural ) return P_Room is
+    P : P_Office;
+  begin
+    P := new Office; Initialize( P.all, No, Desc, People );
+    return P.all'access;
+  end Build_Office;
+end Class_Office.Build;
+
+
+
+
+
+--[class_building.ads] Specification
+with Class_Room, Class_Room.Build;
+use  Class_Room, Class_Room.Build;
+package Class_Building is
+
+  type Building is tagged private;
+
+  procedure Add( The:in out Building; Desc:in P_Room );
+  function About(The:in Building; No:in Positive) return String;
+
+private
+  Max_Rooms : constant := 15;
+  type    Rooms_Index is range 0 .. Max_Rooms;
+  subtype Rooms_Range is Rooms_Index range 1 .. Max_Rooms;
+  type    Rooms_Array is array (Rooms_Range) of P_Room;
+
+  type Building is tagged record
+    Last        : Rooms_Index := 0;  -- Last slot allocated
+    Description : Rooms_Array;       -- Rooms in building
+  end record;
+end Class_Building;
+
+
+
+
+
+--[class_building.adb] Implementation
+package body Class_Building is
+
+  procedure Add( The:in out Building; Desc:in P_Room ) is
+  begin
+    if The.Last < Max_Rooms then
+      The.Last := The.Last + 1;
+      The.Description( The.Last ) := Desc;
+    else
+      raise Constraint_Error;
+    end if;
+  end Add;
+
+  function About(The:in Building; No:in Positive) return String is
+  begin
+    for I in 1 .. The.Last loop
+      if Where(The.Description(I).all) = No then
+        return Describe(The.Description(I).all);
+      end if;
+    end loop;
+    return "Sorry room not known";
+  end About;
+end Class_Building;
+
+
+
+
+
+
+
+--[pack_procedures.ads] Specification
+with Class_Room, Class_Room.Build,
+     Class_Office, Class_Office.Build, Class_Building;
+use  Class_Room, Class_Room.Build,
+     Class_Office, Class_Office.Build, Class_Building;
+procedure Set_Up( Watts:in out Building ) is
+begin
+  Add( Watts, Build_Office( 414, "4th Floor west wing", 2 ) );
+  Add( Watts, Build_Room  ( 422, "4th Floor east wing" ) );
+end Set_Up;
+
+
+
+
+with Ada.Text_Io, Ada.Integer_Text_Io, Class_Building, Set_Up;
+use  Ada.Text_Io, Ada.Integer_Text_Io, Class_Building;
+procedure Main is
+  Watts   : Building;                      -- Watts Building
+  Room_No : Positive;                      -- Queried room
+begin
+  Set_Up( Watts );                         -- Populate building
+  loop
+    begin
+      Put( "Inquiry about room: " );       -- Ask
+      exit when End_Of_File;
+      Get( Room_No ); Skip_Line;           -- User response
+      Put( About( Watts, Room_No ) );
+      New_Line;                            -- Display answer
+    exception
+      when Data_Error =>
+        Put("Please retype the number");   -- Ask again
+        New_Line; Skip_Line;
+    end;
+  end loop;
+end Main;
+
+
@@  x20_hist.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:45 PM BST  --
+---------------------------------------------------------------------
+--[class_histogram.ads] Specification
+package Class_Histogram is
+  type Histogram is private;
+  Def_Height : constant Positive := 14;
+
+  procedure Reset( The:in out Histogram );
+  procedure Add_To( The:in out Histogram; A_Ch:in Character );
+  procedure Put(The:in Histogram; Height:in Positive:=Def_Height);
+private
+  type    Alphabet_Index is new Character range 'A' .. 'Z';
+  type    Alphabet_Array is array (Alphabet_Index) of Natural;
+
+  type Histogram is record
+    Number_Of   : Alphabet_Array := ( others => 0 );
+  end record;
+end Class_Histogram;
+
+--[class_histogram.adb] Implementation
+with Ada.Text_Io, Ada.Float_Text_Io, Ada.Characters.Handling;
+use  Ada.Text_Io, Ada.Float_Text_Io, Ada.Characters.Handling;
+package body Class_Histogram is
+
+  procedure Reset(The:in out Histogram) is
+  begin
+    The.Number_Of := ( others => 0 );  -- Reset counts to 0
+  end Reset;
+
+  procedure Add_To(The:in out Histogram; A_Ch:in Character) is
+    Ch : Character;
+  begin
+    Ch := A_Ch;                        -- As write to ch
+    if Is_Lower(Ch) then               -- Convert to upper case
+      Ch := To_Upper( Ch );
+    end if;
+    if Is_Upper( Ch ) then             -- so record
+      declare
+        C : Alphabet_Index := Alphabet_Index(Ch);
+      begin
+        The.Number_Of(C) := The.Number_Of(C) + 1;
+      end;
+    end if;
+  end Add_To;
+
+  procedure Put(The:in Histogram;
+                Height:in Positive:=Def_Height) is
+    Frequency    : Alphabet_Array;        -- Copy to process
+    Max_Height   : Natural := 0;          -- Observed max
+  begin
+    Frequency := The.Number_Of;           -- Copy data (Array)
+    for Ch in Alphabet_Array'Range loop   -- Find max frequency
+      if Frequency(Ch) > Max_Height then
+        Max_Height:= Frequency(Ch);
+      end if;
+    end loop;
+
+    if Max_Height > 0 then
+      for Ch in Alphabet_Array'Range loop -- Scale to max height
+        Frequency(Ch):=(Frequency(Ch)*Height)/(Max_Height);
+      end loop;
+    end if;
+
+    for Row in reverse 1 .. Height loop  -- Each line
+      Put( "  | " );                     -- start of line
+      for Ch in Alphabet_Array'Range loop
+        if Frequency(Ch) >= Row then
+          Put('*');                      -- bar of hist >= col
+        else
+          Put(' ');                      -- bar of hist <  col
+        end if;
+      end loop;
+      Put(" | "); New_Line;              -- end of line
+    end loop;
+    Put("  +----------------------------+"); New_Line;
+    Put("    ABCDEFGHIJKLMNOPQRSTUVWXYZ " ); New_Line;
+    Put("  *  = (approx) ");
+    Put( Float(Max_Height) / Float(Height), Aft=>2, Exp=>0 );
+    Put(" characters "); New_Line;
+  end Put;
+end Class_Histogram;
+
+--[main.adb] Procedure
+with Ada.Text_Io, Class_Histogram;
+use  Ada.Text_Io, Class_Histogram;
+procedure Main is
+  Ch:Character;                     -- Current character
+  Text_Histogram: Histogram;        -- Histogram object
+begin
+  Reset(Text_Histogram);            -- Reset to empty
+
+  while not End_Of_File loop        -- For each line
+    while not End_Of_Line loop      -- For each character
+      Get(Ch);                      -- Get current character
+      Add_To( Text_Histogram, Ch ); -- Add to histogram
+    end loop;
+    Skip_Line;                      -- Next line
+  end loop;
+
+  Put( Text_Histogram );            -- Print histogram
+
+end Main;
@@  x20_st_a.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:45 PM BST  --
+---------------------------------------------------------------------
+--[class_stack.ads] Specification
+package Class_Stack is
+  type Stack is private;                -- Copying allowed
+  Stack_Error: exception;               -- When error
+
+  procedure Reset( The:in out Stack);
+  procedure Push( The:in out Stack; Item:in Integer );
+  procedure Pop(The:in out Stack; Item:out Integer );
+private
+
+  Max_Stack: constant := 3;
+  type    Stack_Index is range 0 .. Max_Stack;
+  subtype Stack_Range is Stack_Index range 1 .. Max_Stack;
+  type    Stack_Array is array ( Stack_Range ) of Integer;
+
+  type Stack is record
+    Elements: Stack_Array;          -- Array of elements
+    Tos     : Stack_Index := 0;     -- Index
+  end record;
+
+end Class_Stack;
+
+
+--[class_stack.adb] Implementation
+package body Class_Stack is
+
+  procedure Push( The:in out Stack; Item:in Integer ) is
+  begin
+    if The.Tos /= Max_Stack then
+      The.Tos := The.Tos + 1;               -- Next element
+      The.Elements( The.Tos ) := Item;      -- Move in
+    else
+      raise Stack_Error;                    -- Failed
+    end if;
+  end Push;
+
+  procedure Pop( The:in out Stack; Item :out Integer ) is
+  begin
+    if The.Tos > 0 then
+      Item := The.Elements( The.Tos );      -- Top element
+      The.Tos := The.Tos - 1;               -- Move down
+    else
+      raise Stack_Error;                    -- Failed
+    end if;
+  end Pop;
+
+  procedure Reset( The:in out Stack ) is
+  begin
+    The.Tos := 0;  -- Set TOS to 0 (Non existing element)
+  end Reset;
+
+end Class_Stack;
+
+--[main.adb] Procedure
+with Ada.Text_Io, Ada.Integer_Text_Io, Class_Stack;
+use  Ada.Text_Io, Ada.Integer_Text_Io, Class_Stack;
+procedure Main is
+  Number_Stack : Stack;              -- Stack of numbers
+  Action       : Character;          -- Action
+  Number       : Integer;            -- Number processed
+begin
+  while not End_Of_File loop
+    while not End_Of_Line loop
+      begin
+        Get( Action );
+        case Action is               -- Process action
+          when '+' =>
+            Get( Number ); Push(Number_Stack,Number);
+            Put("push number = "); Put(Number); New_Line;
+          when '-' =>
+            Pop(Number_Stack,Number);
+            Put("Pop number  = "); Put(Number); New_Line;
+          when others =>
+            Put("Invalid action"); New_Line;
+        end case;
+      exception
+        when Stack_Error =>
+          Put("Stack_error"); New_Line;
+        when Data_Error  =>
+          Put("Not a number"); New_Line; Skip_Line;
+        when End_Error   =>
+          Put("Unexpected end of file"); New_Line; exit;
+      end;
+    end loop;
+    Skip_Line;
+  end loop;
+  Reset( Number_Stack );
+end Main;
@@  x21_sor3.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:45 PM BST  --
+---------------------------------------------------------------------
+--[class_sort.ads] Specification
+generic
+  type T         is private;          -- Any non limited type
+  type Vec_Range is (<>);             -- Any discrete type
+  type Vec       is array( Vec_Range ) of T;
+  with function  ">"( First, Second:in T ) return Boolean is <>;
+procedure Sort( Items:in out Vec );
+
+--[class_sort.adb] Implementation
+procedure Sort( Items:in out Vec ) is
+  Swaps : Boolean := True;
+  Tmp   : T;
+begin
+  while Swaps loop
+    Swaps := False;
+    for I in Items'First .. Vec_Range'Pred(Items'Last) loop
+      if Items( I ) > Items( Vec_Range'Succ(I) ) then
+        Swaps := True;
+        Tmp := Items( Vec_Range'Succ(I) );
+        Items( Vec_Range'Succ(I) ) := Items( I );
+        Items( I ) := Tmp;
+      end if;
+    end loop;
+  end loop;
+end Sort;
+
+--[main.adb] Procedure
+with Ada.Text_Io, Sort;
+use  Ada.Text_Io;
+procedure Main1 is
+
+  type Chs_Range is range 1 .. 6;
+  type Chs       is array( Chs_Range ) of Character;
+
+  procedure Sort_Chs is new Sort (
+    T         => Character,
+    Vec_Range => Chs_Range,
+    Vec       => Chs,
+    ">"       => ">" );
+  Some_Characters : Chs := ( 'q', 'w', 'e', 'r', 't', 'y' );
+begin
+  Sort_Chs( Some_Characters );
+  for I in Chs_Range loop
+    Put( Some_Characters( I ) ); Put( " " );
+  end loop;
+  New_Line;
+end Main1;
+
+
+--[main2.adb] Procedure
+with Ada.Text_Io, Sort;
+use  Ada.Text_Io;
+procedure Main2 is
+  type Chs_Range is ( Red, Blue, Green );
+  type Chs is array( Chs_Range ) of Character;
+
+  procedure Sort_Chs is new Sort (
+    T         => Character,
+    Vec_Range => Chs_Range,
+    Vec       => Chs,
+    ">"       => ">" );
+  Some_Items : Chs := ( 'q', 'w', 'e' );
+begin
+  Sort_Chs( Some_Items );
+  for I in Chs_Range loop
+    Put( Some_Items( I ) ); Put( " " );
+  end loop;
+  New_Line;
+end Main2;
+
+
+--[main3.adb] Procedure
+with Ada.Text_Io, Sort;
+use  Ada.Text_Io;
+procedure Main3 is
+  Max_Chs : constant := 7;
+  type Height_Cm is range 0 .. 300;
+  type Person is record
+    Name   : String( 1 .. Max_Chs );  -- Name as a String
+    Height : Height_Cm := 0;          -- Height in cm.
+  end record;
+  type People_Range is (First, Second, Third, Forth );
+  type People       is array( People_Range ) of Person;
+
+  function Cmp_Height(First, Second:in Person) return Boolean is
+  begin
+    return First.Height > Second.Height;
+  end Cmp_Height;
+
+  function Cmp_Name( First, Second:in Person ) return Boolean is
+  begin
+    return First.Name > Second.Name;
+  end Cmp_Name;
+
+  procedure Sort_People_Height is new Sort (
+    T         => Person,
+    Vec_Range => People_Range,
+    Vec       => People,
+    ">"       => Cmp_Height );
+
+  procedure Sort_People_Name is new Sort (
+    T         => Person,
+    Vec_Range => People_Range,
+    Vec       => People,
+    ">"       => Cmp_Name );
+
+  Friends : People := ( ("Paul   ", 146 ), ("Carol  ", 147 ),
+    ("Mike   ", 183 ), ("Corinna", 171 ) );
+begin
+  Sort_People_Name( Friends );                    -- Name order
+  Put( "The first in ascending name order is   " );
+  Put( Friends( First ).Name ); New_Line;
+  Sort_People_Height( Friends );                  -- Height order
+  Put( "The first in ascending height order is " );
+  Put( Friends( First ).Name ); New_Line;
+end Main3;
+
+--[main4.adb] Procedure
+procedure Main4 is
+begin
+  null;
+end Main4;
+
+--[main.adb] Procedure
+with Ada.Text_Io, Main1, Main2, Main3, Main4;
+use  Ada.Text_Io;
+procedure Main is
+begin
+  Put("Example 1 "); New_Line; Main1;
+  Put("Example 2 "); New_Line; Main2;
+  Put("Example 3 "); New_Line; Main3;
+  Put("Example 4 "); New_Line; Main4;
+end Main;
@@  x21_ttt.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:46 PM BST  --
+---------------------------------------------------------------------
+package Class_Board is
+
+  type Board      is private;
+  type Game_State is ( Win, Playable, Draw );
+
+  procedure Add( The:in out Board; Pos:in Integer;
+                 Piece:in Character );
+  function  Valid( The:in Board; Pos:in Integer ) return Boolean;
+  function  State( The:in Board ) return Game_State;
+  function  Cell( The:in Board; Pos:in Integer ) return Character;
+  procedure Reset( The:in out Board );
+
+private
+  subtype Board_Index is Integer range 1 .. 9;
+  type    Board_Array is array( Board_Index ) of Character;
+  type Board is record
+    Sqrs  : Board_Array := ( others => ' ');   -- Initialize
+    Moves : Natural     := 0;
+  end record;
+end Class_Board;
+
+package body Class_Board is
+
+  procedure Add( The:in out Board; Pos:in Integer;
+                 Piece:in Character ) is
+  begin
+    The.Sqrs( Pos ) := Piece;
+  end Add;
+
+  function Valid(The:in Board; Pos:in Integer) return Boolean is
+  begin
+    return Pos in Board_Array'Range and then The.Sqrs( Pos ) = ' ';
+  end Valid;
+
+  function  State( The:in Board ) return Game_State is
+    subtype Position   is Integer range 1 .. 9;
+    type Win_Line      is array( 1 .. 3 ) of Position;
+    type All_Win_Lines is range 1 .. 8;
+    Cells: constant array ( All_Win_Lines ) of Win_Line :=
+      ( (1,2,3), (4,5,6), (7,8,9), (1,4,7),
+        (2,5,8), (3,6,9), (1,5,9), (3,5,7) ); -- All win lines
+    First : Character;
+  begin
+    for Pwl in All_Win_Lines loop         -- All Pos Win Lines
+      First := The.Sqrs( Cells(Pwl)(1) ); -- First cell in line
+      if First /= ' ' then                --  Looks promising
+        if First = The.Sqrs( Cells(Pwl)(2) ) and then
+            First = The.Sqrs( Cells(Pwl)(3) ) then return Win;
+        end if;
+      end if;
+    end loop;
+    if The.Moves >= 9 then                -- Check for draw
+      return Draw;                        --  Board full
+    else
+      return Playable;                    --  Still playable
+    end if;
+  end State;
+
+  function Cell( The:in Board; Pos:in Integer ) return Character is
+  begin
+    return The.Sqrs( Pos );
+  end Cell;
+
+  procedure Reset( The:in out Board ) is
+  begin
+    The.sqrs  := ( others => ' ');   -- All spaces
+    The.moves := 0;                  -- No of moves
+  end reset;
+
+end Class_Board;
+
+
+
+with Class_Board, Ada.Text_Io;
+use  Class_Board, Ada.Text_Io;
+procedure Display( The:in Board ) is
+begin
+  for I in 1 .. 9 loop
+    Put( Cell( The, I ) );
+    case I is                        -- after printing counter
+      when 3 | 6  =>                 --  print Row Separator
+        New_Line; Put("---------");  --
+        New_Line;
+      when 9      =>                 --  print new line
+        New_Line;
+      when 1 | 2 | 4 | 5 | 7 | 8 =>  --  print Col separator
+        Put(" | ");
+    end case;
+  end loop;
+end Display;
+
+with Class_Board, Ada.Text_Io, Ada.Integer_Text_Io, Display;
+use  Class_Board, Ada.Text_Io, Ada.Integer_Text_Io;
+procedure Main is
+  Player : Character;          -- Either 'X' or 'O'
+  Game   : Board;              -- An instance of Class Board
+  Move   : Integer;            -- Move from user
+begin
+  Player := 'X';                           -- Set player
+
+  while State( Game ) = Playable loop      -- While playable
+    Put( Player & " enter move (1-9) : "); --   move
+    Get( Move ); Skip_Line;                --  Get move
+    if Valid( Game, Move ) then            -- Valid
+      Add( Game, Move, Player );           --  Add to board
+      Display( Game );                     --  Display board
+      case State( Game ) is                -- Game is
+        when Win       =>
+          Put( Player & " wins");
+        when Playable  =>
+          case Player is                   -- Next player
+            when 'X'    => Player := 'O';  --  'X' => 'O'
+            when 'O'    => Player := 'X';  --  'O' => 'X'
+            when others => null;           --
+          end case;
+        when Draw      =>
+          Put( "It's a draw ");
+      end case;
+      New_Line;
+    else
+      Put("Move invalid"); New_Line;       -- for board
+    end if;
+  end loop;
+  New_Line(2);
+end Main;
@@  x22_st_g.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:46 PM BST  --
+---------------------------------------------------------------------
+--[class_stack.ads] Specification
+generic
+  type Stack_Element is private;  -- Can specify any type
+  Max_Stack:in Positive := 3;     -- Has to be typed / not const
+package Class_Stack is
+  type Stack is private;
+  Stack_Error: exception;
+
+  procedure Reset( The:in out Stack);
+  procedure Push( The:in out Stack; Item:in Stack_Element );
+  procedure Pop( The:in out Stack; Item:out Stack_Element );
+private
+
+  type    Stack_Index is new Integer range 0 .. Max_Stack;
+  subtype Stack_Range is Stack_Index
+                      range 1 .. Stack_Index(Max_Stack);
+  type    Stack_Array is array ( Stack_Range ) of Stack_Element;
+
+  type Stack is record
+    Elements: Stack_Array;          -- Array of elements
+    Tos     : Stack_Index := 0;     -- Index
+  end record;
+
+end Class_Stack;
+
+--[class_stack.adb] Implementation
+package body Class_Stack is
+
+  procedure Push( The:in out Stack; Item:in Stack_Element ) is
+  begin
+    if The.Tos /= Stack_Index(Max_Stack) then
+      The.Tos := The.Tos + 1;               -- Next element
+      The.Elements( The.Tos ) := Item;      -- Move in
+    else
+      raise Stack_Error;                    -- Failed
+    end if;
+  end Push;
+
+  procedure Pop( The:in out Stack; Item :out Stack_Element ) is
+  begin
+    if The.Tos > 0 then
+      Item := The.Elements( The.Tos );      -- Top element
+      The.Tos := The.Tos - 1;               -- Move down
+    else
+      raise Stack_Error;                    -- Failed
+    end if;
+  end Pop;
+
+  procedure Reset( The:in out Stack ) is
+  begin
+    The.Tos := 0;  -- Set TOS to 0 (Non existing element)
+  end Reset;
+
+end Class_Stack;
+
+--[class_stack_char.ADS] Implementation Instantiation
+with Class_Stack;
+pragma Elaborate_All( Class_Stack );
+package Class_Stack_Char is new Class_Stack(Character,3);
+
+--[class_stack_int.ADS] Implementation Instantiation
+with Class_Stack;
+pragma Elaborate_All( Class_Stack );
+package Class_Stack_Int is new Class_Stack(Integer);
+
+--[class_stack_stack_int.adb] Implementation Instantiation
+with Class_Stack, Class_Stack_Int;
+package Class_Stack_Stack_Int is
+  new Class_Stack(Class_Stack_Int.Stack);
+
+--[main1.adb] Procedure
+with Ada.Text_Io, Ada.Integer_Text_Io, Ada.Float_Text_Io, Class_Stack_Int;
+use  Ada.Text_Io, Ada.Integer_Text_Io, Ada.Float_Text_Io, Class_Stack_Int;
+procedure Main1 is
+  Number_Stack : Stack;              -- Stack of numbers
+  Action       : Character;          -- Action
+  Number       : Integer;            -- Number processed
+begin
+  while not End_Of_File loop
+    while not End_Of_Line loop
+      begin
+        Get( Action );
+        case Action is               -- Process action
+          when '+' =>
+            Get( Number ); Push(Number_Stack,Number);
+            Put("push number = "); Put(Number); New_Line;
+          when '-' =>
+            Pop(Number_Stack,Number);
+            Put("Pop number  = "); Put(Number); New_Line;
+          when others =>
+            Put("Invalid action"); New_Line;
+        end case;
+      exception
+        when Stack_Error =>
+          Put("Stack_error"); New_Line;
+        when Data_Error  =>
+          Put("Not a number"); New_Line; Skip_Line;
+        when End_Error   =>
+          Put("Unexpected end of file"); New_Line; exit;
+      end;
+    end loop;
+    Skip_Line;
+  end loop;
+
+  Reset( Number_Stack );
+end Main1;
+
+--[main2.adb] Procedure
+with Ada.Text_Io, Ada.Float_Text_Io, Class_Stack_Int, Class_Stack_Stack_Int;
+use  Ada.Text_Io, Ada.Float_Text_Io, Class_Stack_Int, Class_Stack_Stack_Int;
+procedure Main2 is
+  Number_Stack1      : Class_Stack_Int.Stack;
+  Number_Stack2      : Class_Stack_Int.Stack;
+  Stack_Number_Stack : Class_Stack_Stack_Int.Stack;
+  Number             : Integer;
+begin
+  Push( Number_Stack1, 1 );
+  Push( Number_Stack1, 2 );
+  Push( Stack_Number_Stack, Number_Stack1 );
+  Pop(  Stack_Number_Stack, Number_Stack2 );
+  Pop(  Number_Stack2, Number );
+  if Number = 2 then Put("ok "); else Put("Fail "); end if;
+  Pop(  Number_Stack2, Number );
+  if Number = 1 then Put("ok "); else Put("Fail "); end if;
+  New_Line;
+end Main2;
+
+
+--[main.adb] Procedure
+with Ada.Text_Io, Main1, Main2;
+use  Ada.Text_Io;
+procedure Main is
+begin
+  Put("Example 1"); New_Line; Main1;
+  Put("Example 2"); New_Line; Main2;
+end Main;
@@  x35_rat.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:47 PM BST  --
+---------------------------------------------------------------------
+--[class_rational.ads] Specification
+package Class_Rational is
+  type Rational is private;
+
+  function "+" ( F:in Rational; S:in Rational ) return Rational;
+  function "-" ( F:in Rational; S:in Rational ) return Rational;
+  function "*" ( F:in Rational; S:in Rational ) return Rational;
+  function "/" ( F:in Rational; S:in Rational ) return Rational;
+
+  function Rat_Const( F:in Integer;
+                      S:in Integer:=1 ) return Rational;
+  function  Image( The:in Rational ) return String;
+private
+  function Sign( The:in Rational ) return Rational;
+  function Simplify( The:in Rational ) return Rational;
+  type Rational is record
+    Above : Integer := 0;      -- Numerator
+    Below : Integer := 1;      -- Denominator
+  end record;
+end Class_Rational;
+
+--[class_rational.adb] Implementation
+package body Class_Rational is
+
+  function "+" (F:in Rational; S:in Rational) return Rational is
+    Res : Rational;
+  begin
+    Res.Below := F.Below * S.Below;
+    Res.Above := F.Above * S.Below + S.Above * F.Below;
+    return Simplify(Res);
+  end "+";
+
+  function "-" (F:in Rational; S:in Rational) return Rational is
+    Res : Rational;
+  begin
+    Res.Below := F.Below * S.Below;
+    Res.Above := F.Above * S.Below - S.Above * F.Below;
+    return Simplify(Res);
+  end "-";
+
+  function "*" (F:in Rational; S:in Rational) return Rational is
+    Res : Rational;
+  begin
+    Res.Above := F.Above * S.Above;
+    Res.Below := F.Below * S.Below;
+    return Simplify(Res);
+  end "*";
+
+  function "/" (F:in Rational; S:in Rational) return Rational is
+    Res : Rational;
+  begin
+    Res.Above := F.Above * S.Below;
+    Res.Below := F.Below * S.Above;
+    return Simplify(Res);
+  end "/";
+
+  function Rat_Const( F:in Integer; S:in Integer:=1 ) return Rational is
+  begin
+    if F = 0 then
+      return Rational'(0,1);
+    else
+      return Simplify( Sign( Rational'( F, S ) ) );
+    end if;
+  end Rat_Const;
+
+  function Image( The:in Rational ) return String is
+    Above : Integer := The.Above;
+    Below : Integer := The.Below;
+
+    function Trim( Str:in String ) return String is
+    begin
+      return Str( Str'First+1 .. Str'Last );
+    end Trim;
+
+    function To_String( Above, Below : in Integer )
+             return String is
+    begin
+      if Above = 0 then            -- No fraction
+        return "";
+      elsif Above >= Below then    -- Whole number
+        return Trim( Integer'Image(Above/Below) ) & " " &
+               To_String( Above rem below, Below );
+      else
+        return Trim( Integer'Image( Above ) ) & "/" &
+               Trim( Integer'Image( Below ) );
+      end if;
+    end To_String;
+
+  begin
+   if Above = 0 then
+     return "0";                                 -- Zero
+   elsif Above < 0 then
+     return "-" & To_String( abs Above, Below ); -- -ve
+   else
+     return To_String( Above, Below );           -- +ve
+   end if;
+  end Image;
+
+  function Sign( The:in Rational ) return Rational is
+  begin
+    if The.Below >= 0 then            --   -a/b or a/b
+      return The;
+    else                              --   a/-b or -a/-b
+      return Rational'( -The.Above, -The.Below );
+    end if;
+  end Sign;
+
+  function Simplify( The:in Rational ) return Rational is
+    Res: Rational := The;
+    D  : Positive;                    -- Divisor to reduce with
+  begin
+    if Res.Below = 0 then             -- Invalid treat as 0
+      Res.Above := 0; Res.Below := 1;
+    end if;
+    D := 2;                           -- Divide by 2, 3, 4 ...
+    while D < Res.Below loop
+      while Res.Below rem D = 0 and then Res.Above rem D = 0 loop
+        Res.Above := Res.Above / D;
+        Res.Below := Res.Below / D;
+      end loop;
+      D := D + 1;
+    end loop;
+    return Res;
+  end Simplify;
+
+end Class_Rational;
+
+--[Main.adb] Procedure
+with Ada.Text_Io, Class_Rational;
+use  Ada.Text_Io, Class_Rational;
+procedure Main1 is
+  A,B : Rational;
+begin
+  A := Rat_Const( 1, 2 );
+  B := Rat_Const( 1, 3 );
+
+  Put( "a     = " ); Put( Image(A) );   New_Line;
+  Put( "b     = " ); Put( Image(B) );   New_Line;
+  Put( "a + b = " ); Put( Image(A+B) ); New_Line;
+  Put( "a - b = " ); Put( Image(A-B) ); New_Line;
+  Put( "b - a = " ); Put( Image(B-A) ); New_Line;
+  Put( "a * b = " ); Put( Image(A*B) ); New_Line;
+  Put( "a / b = " ); Put( Image(A/B) ); New_Line;
+end Main1;
+
+--[Main.adb] Procedure
+with Ada.Text_Io, Class_Rational;
+use  Ada.Text_Io, Class_Rational;
+procedure Main2 is
+  A,B : Rational;
+begin
+  A := Rat_Const(1, 2);
+  B := Rat_Const(1, 3);
+
+  Put( "a     = " ); Put( Image(A) );   Put(" <1/2> "); New_Line;
+  Put( "b     = " ); Put( Image(B) );   Put("  <1/3> "); New_Line;
+  Put( "a + b = " ); Put( Image(A+B) ); Put(" <5/6> "); New_Line;
+  Put( "a - b = " ); Put( Image(A-B) ); Put(" <1/6> "); New_Line;
+  Put( "b - a = " ); Put( Image(B-A) ); Put(" <-1/6> "); New_Line;
+  Put( "a * b = " ); Put( Image(A*B) ); Put(" <1/6> "); New_Line;
+  Put( "a / b = " ); Put( Image(A/B) ); Put(" <1 1/2> "); New_Line;
+
+  New_Line;
+  A := Rat_Const(3, 2);
+  B := Rat_Const(4, 5);
+  Put( "a     = " ); Put( Image(A) );   Put(" <3/2> "); New_Line;
+  Put( "b     = " ); Put( Image(B) );   Put(" <4/5> "); New_Line;
+  Put( "a + b = " ); Put( Image(A+B) ); Put(" <2 3/10> "); New_Line;
+  Put( "a - b = " ); Put( Image(A-B) ); Put(" <7/10> "); New_Line;
+  Put( "b - a = " ); Put( Image(B-A) ); Put(" <-7/10> "); New_Line;
+  Put( "a * b = " ); Put( Image(A*B) ); Put(" <1 1/5> "); New_Line;
+  Put( "a / b = " ); Put( Image(A/B) ); Put(" <1 7/8> "); New_Line;
+end Main2;
+
+--[Main.adb] Procedure
+with Ada.Text_Io, Class_Rational;
+use  Ada.Text_Io, Class_Rational;
+procedure Main3 is
+  A : Rational;
+begin
+  -- put( 8/16 ) is ambiguous;
+  New_Line;
+  Put( " 0, 0      = " ); A := Rat_Const(0, 0);   Put( Image(A) ); New_Line;
+  Put( " 0, 5      = " ); A := Rat_Const(0, 5);   Put( Image(A) ); New_Line;
+  Put( " 5, 0      = " ); A := Rat_Const(5, 0);   Put( Image(A) ); New_Line;
+  Put( " 8, 16     = " ); A := Rat_Const(8, 16);  Put( Image(A) ); New_Line;
+  Put( " 8, 8      = " ); A := Rat_Const(8, 8);   Put( Image(A) ); New_Line;
+  Put( " -17, 8    = " ); A := Rat_Const(-17, 8); Put( Image(A) ); New_Line;
+  Put( " -17, -8   = " ); A := Rat_Const(-17, -8);Put( Image(A) ); New_Line;
+  Put( " 17, -8    = " ); A := Rat_Const(17, -8); Put( Image(A) ); New_Line;
+  Put( " 7, 97     = " ); A := Rat_Const(7, 97);  Put( Image(A) ); New_Line;
+  Put( " 40, 20    = " ); A := Rat_Const(40, 20); Put( Image(A) ); New_Line;
+  Put( " 20, 40    = " ); A := Rat_Const(20, 40); Put( Image(A) ); New_Line;
+  Put( " 648, 972  = " ); A := Rat_Const(648,972);Put( Image(A) ); New_Line;
+end Main3;
+
+--[Main.adb] Procedure
+with Ada.Text_Io, Class_Rational;
+use  Ada.Text_Io, Class_Rational;
+procedure Main4 is
+  A : Rational;
+begin
+  A := Rat_Const(0, 0);
+  for I in 1 .. 5 loop
+    A := A + Rat_Const(1,I);
+  end loop;
+  Put("Sum of 1/1 + 1/2 + ... 1/5 is "); Put( Image(A) ); New_Line;
+end Main4;
+
+--[Main.adb] Procedure
+with Ada.Text_Io, Class_Rational;
+use  Ada.Text_Io, Class_Rational;
+procedure Main5 is
+  A : Rational;
+  Up_To : constant := 7;
+begin
+  A := Rat_Const(1, 1);
+  for I in 1 .. Up_To loop
+    A := A + Rat_Const(1, I);
+  end loop;
+  for I in reverse 1 .. Up_To loop
+    A := A - Rat_Const(1, I);
+  end loop;
+  Put("Sum  check answer should be 1 <=> "); Put( Image(A) ); New_Line;
+  A := Rat_Const(1);
+  for I in 1 .. Up_To loop
+    A := A * Rat_Const(1, I);
+  end loop;
+  for I in reverse 1 .. Up_To loop
+    A := A / Rat_Const(1,I);
+  end loop;
+  Put("Mult check answer should be 1 <=> "); Put( Image(A) ); New_Line;
+end Main5;
+
+
+with Ada.Text_Io, Class_Rational;
+use  type Class_Rational.Rational;
+procedure Main6 is
+  A,B : Class_Rational.Rational;
+begin
+  A := Class_Rational.Rat_Const( 1, 2 );
+  B := Class_Rational.Rat_Const( 1, 3 );
+
+  Ada.Text_Io.Put( "a + b = " ); 
+  Ada.Text_Io.Put( Class_Rational.Image(A+B) );
+  Ada.Text_Io.New_Line;
+end Main6;
+
+--[main.adb] Procedure
+with Ada.Text_Io, Main1, Main2, Main3, Main4, Main5, Main6;
+use  Ada.Text_Io;
+procedure Main is
+begin
+  Put("Example Account 1 "); New_Line; Main1;
+  Put("Example Account 2 "); New_Line; Main2;
+  Put("Example Account 3 "); New_Line; Main3;
+  Put("Example Account 4 "); New_Line; Main4;
+  Put("Example Account 5 "); New_Line; Main5;
+  Put("Example Account 6 "); New_Line; Main6;
+end Main;
@@  x36_str5.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:47 PM BST  --
+---------------------------------------------------------------------
+--[class_string.ads] Specification
+package Class_Bounded_String is
+  type Bounded_String is private;
+
+  function To_Bounded_String(Str:in String)
+    return Bounded_String;
+
+  function To_String(The:in Bounded_String) return String;
+
+  function "&" (F:in Bounded_String; S:in Bounded_String)
+    return Bounded_String;
+  function "&" (F:in Bounded_String; S:in String)
+    return Bounded_String;
+  function "&" (F:in String; S:in Bounded_String)
+    return Bounded_String;
+
+  function Slice( The:in Bounded_String;
+                  Low:in Positive; High:in Natural )
+    return String;
+
+  function "="  ( F:in Bounded_String; S:in Bounded_String )
+    return Boolean;
+
+  function ">"  ( F:in Bounded_String; S:in Bounded_String )
+    return Boolean;
+  function ">=" ( F:in Bounded_String; S:in Bounded_String )
+    return Boolean;
+  function "<"  ( F:in Bounded_String; S:in Bounded_String )
+    return Boolean;
+  function "<=" ( F:in Bounded_String; S:in Bounded_String )
+    return Boolean;
+private
+  Max_String: constant := 80;
+  subtype Str_Range is Natural range 0 .. Max_String;
+  type A_Bounded_String( Length: Str_Range := 0 ) is record
+    Chrs: String( 1 .. Length );  -- Stored string
+  end record;
+  type Bounded_String is record
+    V_Str : A_Bounded_String;
+  end record;
+end Class_Bounded_String;
+
+--[class_string.adb] Implementation
+package body Class_Bounded_String is
+
+  function To_Bounded_String( Str:in String )
+      return Bounded_String is
+  begin
+    return (V_Str=>(Str'Length, Str));
+  end To_Bounded_String;
+
+  function To_String(The:in Bounded_String) return String is
+  begin
+    return The.V_Str.Chrs( 1 .. The.V_Str.Length );
+  end To_String;
+
+  function "&" ( F:in Bounded_String; S:in Bounded_String )
+      return Bounded_String is
+  begin
+    return (V_Str=>(F.V_Str.Chrs'Length + S.V_Str.Chrs'Length,
+        F.V_Str.Chrs & S.V_Str.Chrs));
+  end "&";
+
+  function "&" ( F:in Bounded_String; S:in String )
+      return Bounded_String is
+  begin
+    return (V_Str=>(F.V_Str.Chrs'Length + S'Length,
+        F.V_Str.Chrs & S ) );
+  end "&";
+
+  function "&" ( F:in String; S:in Bounded_String )
+      return Bounded_String is
+  begin
+    return ( V_Str=>(F'Length + S.V_Str.Chrs'Length,
+        F & S.V_Str.Chrs ) );
+  end "&";
+
+  function Slice( The:in Bounded_String;
+                   Low:in Positive; High:in Natural)
+    return String is
+  begin
+    if Low <= High and then High <= The.V_Str.Length then
+      return The.V_Str.Chrs( Low .. High );
+    end if;
+    return "";
+  end Slice;
+
+  function "="  ( F:in Bounded_String; S:in Bounded_String )
+      return Boolean is
+  begin
+    return F.V_Str.Chrs = S.V_Str.Chrs;
+  end "=";
+
+  function ">"  ( F:in Bounded_String; S:in Bounded_String )
+      return Boolean is
+  begin
+    return F.V_Str.Chrs > S.V_Str.Chrs;
+  end ">";
+
+  function ">=" ( F:in Bounded_String; S:in Bounded_String )
+      return Boolean is
+  begin
+    return F.V_Str.Chrs >= S.V_Str.Chrs;
+  end ">=";
+
+  function "<"  ( F:in Bounded_String; S:in Bounded_String )
+      return Boolean is
+  begin
+    return F.V_Str.Chrs < S.V_Str.Chrs;
+  end "<";
+
+  function "<=" ( F:in Bounded_String; S:in Bounded_String )
+      return Boolean is
+  begin
+    return F.V_Str.Chrs <= S.V_Str.Chrs;
+  end "<=";
+
+end Class_Bounded_String;
+
+--[class_container.ads] Specification
+package Class_Container is
+  procedure Main1;
+  procedure Main2;
+end Class_Container;
+
+--[class_container.adb] Implementation
+with Ada.Text_Io, Class_Bounded_String;
+use  Ada.Text_Io, Class_Bounded_String;
+package body Class_Container is
+
+  procedure Main1 is
+    Town, County, Address : Bounded_String;
+  begin
+    Town   := To_Bounded_String( "Brighton" );
+    County := To_Bounded_String( "East Sussex" );
+
+    Address := Town & " " & County;
+
+    Put( To_String(Address) ); New_Line;
+    Put( Slice( County & " UK", 6, 14 ) );
+    New_Line;
+
+  end Main1;
+
+  procedure Main2 is
+    Text: Bounded_String;
+    procedure Check(B:in Boolean; Str1,Str2:in String) is
+    begin
+      if B then Put(Str1); else Put(Str2); end if;
+      Put(" ");
+    end Check;
+  begin
+    Put("=    /=   >    >=   >=   <    <=   <=    "); New_Line;
+    Check(To_Bounded_String("ABC") =  To_Bounded_String("ABC") , "Pass",  "Fail");
+    Check(To_Bounded_String("ABC") /= To_Bounded_String("AB ") , "Pass",  "Fail");
+    Check(To_Bounded_String("ABC") >  To_Bounded_String("ABBB"), "Pass",  "Fail");
+    Check(To_Bounded_String("ABC") >= To_Bounded_String("ABBB"), "Pass",  "Fail");
+    Check(To_Bounded_String("ABC") >= To_Bounded_String("ABC") , "Pass",  "Fail");
+    Check(To_Bounded_String("ABBB")<  To_Bounded_String("ABC") , "Pass",  "Fail");
+    Check(To_Bounded_String("ABBB")<= To_Bounded_String("ABC") , "Pass",  "Fail");
+    Check(To_Bounded_String("ABC") <= To_Bounded_String("ABC") , "Pass",  "Fail");
+    New_Line;
+
+    Put("/=    =   <=   <    <    >=   >    >     "); New_Line;
+    Check(To_Bounded_String("ABC") /= To_Bounded_String("ABC") , "Fail",  "Pass");
+    Check(To_Bounded_String("ABC") =  To_Bounded_String("AB ") , "Fail",  "Pass");
+    Check(To_Bounded_String("ABC") <= To_Bounded_String("ABBB"), "Fail",  "Pass");
+    Check(To_Bounded_String("ABC") <  To_Bounded_String("ABBB"), "Fail",  "Pass");
+    Check(To_Bounded_String("ABC") <  To_Bounded_String("ABC") , "Fail",  "Pass");
+    Check(To_Bounded_String("ABBB")>= To_Bounded_String("ABC") , "Fail",  "Pass");
+    Check(To_Bounded_String("ABBB")>  To_Bounded_String("ABC") , "Fail",  "Pass");
+    Check(To_Bounded_String("ABC") >  To_Bounded_String("ABC") , "Fail",  "Pass");
+    New_Line;
+
+    Put("Equality test"); New_Line;
+    for I in 1 .. 6 loop
+      Text := To_Bounded_String("ABCDEFGH-ABCDEFGH");
+      if Slice(Text,I,4) = Slice(Text,9+I,13) then
+        Put("Pass");
+      else
+        Put("Fail");
+      end if;
+      Put(" ");
+    end loop;
+    New_Line;
+
+  end Main2;
+
+end Class_Container;
+
+with Ada.Text_Io, Class_Bounded_String;
+use  type Class_Bounded_String.Bounded_String;
+procedure Main3 is
+  Town  : Class_Bounded_String.Bounded_String :=
+    Class_Bounded_String.To_Bounded_String("Brighton");
+  County: Class_Bounded_String.Bounded_String :=
+    Class_Bounded_String.To_Bounded_String("E Sussex");
+begin
+  Ada.Text_Io.Put(
+    Class_Bounded_String.To_String( Town & " " & County )
+    );
+end Main3;
+
+--[main.adb] Procedure
+with Class_Container, Main3;
+use  Class_Container;
+procedure Main is
+begin
+  Main1; Main2; Main3;
+end Main;
@@  x40_st_g.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:48 PM BST  --
+---------------------------------------------------------------------
+--[class_stack.ads] Specification
+generic
+  type Stack_Element is private;        --
+
+package Class_Stack is
+  type Stack is limited private;        -- NO copying
+  Stack_Error : exception;
+
+  procedure Push( The:in out Stack; Item:in Stack_Element );
+  procedure Pop(The:in out Stack; Item :out Stack_Element );
+  procedure Reset( The:in out Stack );
+private
+
+  type Node;                            -- Mutually recursive def
+  type P_Node is access Node;           -- Pointer to a Node
+  pragma Controlled( P_Node );          -- We do deallocation
+
+  type Node is record                   -- Node holds the data
+    Item   : Stack_Element;             -- The stored item
+    P_Next : P_Node;                    -- Next in list
+  end record;
+
+  type Stack is record
+    P_Head : P_Node := null;            -- First node in list
+  end record;
+end Class_Stack;
+
+
+
+
+
+--[class_stack.adb] Implementation
+
+with Unchecked_Deallocation;
+pragma Elaborate_All( Unchecked_Deallocation );
+package body Class_Stack is
+
+  procedure Dispose is
+    new Unchecked_Deallocation( Node, P_Node );
+
+  procedure Push( The:in out Stack; Item:in Stack_Element ) is
+    Tmp : P_Node;                       -- Allocated node
+  begin
+    Tmp := new Node'(Item=>Item, P_Next=>The.P_Head);
+    The.P_Head := Tmp;
+  end Push;
+
+  procedure Pop( The:in out Stack; Item :out Stack_Element ) is
+    Tmp : P_Node;                        -- Free node
+  begin
+    if The.P_Head /= null then           -- if item then
+      Tmp := The.P_Head;                 -- isolate top node
+      Item := The.P_Head.Item;           -- extract item stored
+      The.P_Head := The.P_Head.P_Next;   -- Relink
+      Dispose( Tmp );                    -- return storage
+    else
+      raise Stack_Error;                 -- Failure
+    end if;
+  end Pop;
+
+  procedure Reset( The:in out Stack ) is
+    Tmp : Stack_Element;
+  begin
+    while The.P_Head /= null loop        -- Re-initialize stack
+      Pop( The, Tmp );
+    end loop;
+  end Reset;
+
+end Class_Stack;
+
+
+
+
+--[class_stack_int.ADS] Specification
+with Class_Stack;
+  pragma Elaborate_All( Class_Stack );
+  package Class_Stack_Int is new Class_Stack(Integer);
+
+--[main.adb] Procedure
+with Ada.Text_Io, Ada.Integer_Text_Io, Class_Stack_Int;
+use  Ada.Text_Io, Ada.Integer_Text_Io, Class_Stack_Int;
+procedure Main is
+  Number_Stack : Stack;              -- Stack of numbers
+  Action       : Character;          -- Action
+  Number       : Integer;            -- Number processed
+begin
+  Reset( Number_Stack );             -- Reset stack to empty
+  while not End_Of_File loop
+    while not End_Of_Line loop
+      begin
+        Get( Action );
+        case Action is               -- Process action
+          when '+' =>
+            Get( Number ); Push(Number_Stack,Number);
+            Put("push number = "); Put(Number); New_Line;
+          when '-' =>
+            Pop(Number_Stack,Number);
+            Put("Pop number  = "); Put(Number); New_Line;
+          when others =>
+            Put("Invalid action"); New_Line;
+        end case;
+      exception
+        when Stack_Error =>
+          Put("Stack_error"); New_Line;
+        when Data_Error  =>
+          Put("Not a number"); New_Line;
+        when End_Error   =>
+          Put("Unexpected end of file"); New_Line; exit;
+      end;
+    end loop;
+    Skip_Line;
+  end loop;
+
+  Reset( Number_Stack );
+end Main;
@@  x56_tree.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:48 PM BST  --
+---------------------------------------------------------------------
+--[class_pic.ads] Specification
+with Ada.Strings.Unbounded, Ada.Finalization;
+use  Ada.Strings.Unbounded, Ada.Finalization;
+generic
+  type Index is private;                  -- Index for record
+  type Data  is private;                  -- Data for record
+  with function  ">"( F:in Index; S:in Index ) return Boolean;
+package Class_Pic is
+  Not_There, Mainists, Per_Error : exception; -- Raised Exceptions
+  type Pic  is new Limited_Controlled with private;
+  procedure Initialize( The:in out Pic );
+  procedure Initialize( The:in out Pic; Id:in String );
+  procedure Finalize( The:in out Pic );
+  procedure Discard( The:in out Pic );
+  procedure Set_Name( The:in out Pic; Id:in String );
+  function  Get_Name( The:in Pic ) return String;
+
+  procedure Add( The:in out Pic; I:in Index; D:in Data );
+  procedure Extract( The:in out Pic; I:in Index; D:in out Data );
+  procedure Update( The:in out Pic; I:in Index; D:in out Data );
+private
+  type Leaf;                     -- Index + Data
+  type Subtree is access Leaf;   --
+  type Pic is new Limited_Controlled with record
+    Tree   : Subtree := null;    --  Storage
+    Obj_Id : Unbounded_String;     --  Name of object
+  end record;
+
+  function  Find( The:in Subtree; I:in Index) return Subtree;
+  procedure Release_Storage( The:in out Subtree );
+
+end Class_Pic;
+
+--[class_pic.adb] Implementation
+with Unchecked_Deallocation, Sequential_Io;
+package body Class_Pic is
+
+  type Element is record    --
+    S_Index: Index;         -- The Index
+    S_Data : Data;          -- The Data
+  end record;
+
+  type Leaf is record       --
+    Left   : Subtree;       -- Possible left node
+    Rec    : Element;       -- Index + data
+    Right  : Subtree;       -- Possible right node;
+  end record;
+
+  package Io is new Sequential_Io( Element );
+
+  procedure Initialize( The:in out Pic ) is
+  begin
+    The.Tree := null;    -- No storage
+  end Initialize;
+
+  procedure Initialize( The:in out Pic; Id:in String ) is
+    Per : Io.File_Type;    -- File descriptor
+    Cur : Element;         -- Persistent data record element
+  begin
+    Set_Name( The, Id );                  -- Name object
+    Io.Open( Per, Io.In_File, Id );       -- Open saved state
+    while not Io.End_Of_File( Per ) loop  -- Restore saved state
+      Io.Read( Per, Cur );
+      Add( The, Cur.S_Index, Cur.S_Data );
+    end loop;
+    Io.Close( Per );
+  exception                               -- Return real exception
+    when others => raise Per_Error;      --  as sub code
+  end Initialize;
+
+  procedure Finalize( The:in out Pic ) is
+    Per : Io.File_Type;    -- File descriptor
+    procedure Rec_Finalize( The:in Subtree ) is -- Save state
+    begin
+      if The /= null then                   -- Subtree save as
+        Io.Write( Per, The.Rec );           --  Item
+        Rec_Finalize( The.Left );           --  LHS
+        Rec_Finalize( The.Right );          --  RHS
+      end if;
+    end Rec_Finalize;
+  begin
+    if To_String(The.Obj_Id) /= "" then     -- If save state
+      Io.Create( Per, Io.Out_File,
+        To_String( The.Obj_Id ) );
+      Rec_Finalize( The.Tree );
+      Io.Close( Per );
+    end if;
+    Release_Storage( The.Tree );
+  exception                              -- Return real exception
+    when others => raise Per_Error;     --  as sub code
+  end Finalize;
+
+  procedure Discard( The:in out Pic ) is
+  begin
+    Set_Name( The, "" );                 -- No name
+    Release_Storage( The.Tree );         -- Release storage
+  end Discard;
+
+  procedure Set_Name( The:in out Pic; Id:in String ) is
+  begin
+    The.Obj_Id := To_Unbounded_String(Id); -- Set object name
+  end Set_Name;
+
+  function  Get_Name( The:in Pic ) return String is
+  begin
+    return To_String( The.Obj_Id );     -- Name of object
+  end Get_Name;
+
+  procedure Add( The:in out Pic; I:in Index; D:in Data ) is
+    procedure Add_S(The:in out Subtree; I:in Index; D:in Data) is
+    begin
+      if The = null then
+        The := new Leaf'( null, Element'(I,D), null );
+      else
+        if I = The.Rec.S_Index then     -- Index all ready exists
+          raise Mainists;
+        elsif I > The.Rec.S_Index then  -- Try on RHS
+          Add_S( The.Right, I, D );
+        else                            -- LHS
+          Add_S( The.Left, I, D );
+        end if;
+      end if;
+    end Add_S;
+  begin
+    Add_S( The.Tree, I, D );
+  end Add;
+
+  procedure Extract(The:in out Pic; I:in Index; D:in out Data) is
+    Node_Is : Subtree;
+  begin
+    Node_Is := Find( The.Tree, I );     -- Find node with iey
+    D := Node_Is.Rec.S_Data;            -- return data
+  end Extract;
+
+  procedure Update(The:in out Pic; I:in Index; D:in out Data) is
+    Node_Is : Subtree;
+  begin
+    Node_Is := Find( The.Tree, I );     -- Find node with iey
+    Node_Is.Rec.S_Data := D;            -- Update data
+  end Update;
+
+  function Find( The:in Subtree; I:in Index) return Subtree is
+  begin
+    if The = null then raise Not_There; end if;
+    if I = The.Rec.S_Index then
+      return The;                           -- Found
+    else
+      if I > The.Rec.S_Index
+          then return Find( The.Right, I );   -- Try RHS
+      else return Find( The.Left,  I );   -- Try LHS
+      end if;
+    end if;
+  end Find;
+
+  procedure Dispose is
+    new Unchecked_Deallocation( Leaf, Subtree );
+
+  procedure Release_Storage( The:in out Subtree ) is
+  begin
+    if The /= null then             -- Not empty
+      Release_Storage( The.Left );  -- Free LHS
+      Release_Storage( The.Right ); -- Free RHS
+      Dispose( The );               -- Dispose of item
+    end if;
+    The := null;                    -- Subtree root NULL
+  end Release_Storage;
+
+end Class_Pic;
+
+--[pack_types.ads] Specification
+-- Subtype as get demands a String
+package Pack_Types is
+  subtype  Country is String(1 .. 12); -- Country 
+  subtype  Idc     is String(1 .. 6); -- International Dialling Code
+end Pack_Types;
+
+--[class_tel_list.ADS] Implementation Instantiation
+with Class_Pic, Pack_Types;
+use  Pack_Types;
+pragma Elaborate_All( Class_Pic );
+package Class_Tel_List is new
+  Class_Pic( Country, Idc, ">" );
+
+--[pack_procedures.adb] Implementation
+with Ada.Text_Io, Class_Tel_List;
+use  Ada.Text_Io, Class_Tel_List;
+procedure Main1 is
+  Tel_List : Pic;
+begin
+  Put("Creating Telephone list"); New_Line;
+  Set_Name( Tel_List, "tel_list.per" );
+  Add( Tel_List, "Canada      ", "+1    " );
+  Add( Tel_List, "USA         ", "+1    " );
+  Add( Tel_List, "Netherlands ", "+31   " );
+  Add( Tel_List, "Belgium     ", "+32   " );
+  Add( Tel_List, "France      ", "+33   " );
+  Add( Tel_List, "Gibraltar   ", "+350  " );
+  Add( Tel_List, "Ireland     ", "+353  " );
+  Add( Tel_List, "Switzerland ", "+41   " );
+  Add( Tel_List, "UK          ", "+44   " );
+  Add( Tel_List, "Denmark     ", "+45   " );
+  Add( Tel_List, "Norway      ", "+47   " );
+  Add( Tel_List, "Germany     ", "+49   " );
+  Add( Tel_List, "Australia   ", "+61   " );
+  Add( Tel_List, "Japan       ", "+81   " );
+end Main1;
+
+
+
+with Ada.Text_Io, Pack_Types, Class_Tel_List;
+use  Ada.Text_Io, Pack_Types, Class_Tel_List;
+procedure Main2 is
+  Tel_List : Pic;
+  Action   : Character;
+  Name     : Country;
+  Tel      : Idc;
+begin
+  Initialize( Tel_List, "tel_list.per" );
+  while not End_Of_File loop
+    begin
+      Get( Action );                       -- Action to perform
+      case Action is
+        when '+' =>                        -- Add
+          Get( Name ); Get( Tel );
+          Add( Tel_List, Name, Tel );
+        when '=' =>                        -- Extract
+          Get( Name );
+          Extract( Tel_List, Name, Tel );
+          Put( "IDC for " ); Put( Name );
+          Put( " is "); Put( Tel ); New_Line;
+        when '*' =>                        -- Update
+          Get( Name ); Get( Tel );
+          Update( Tel_List, Name, Tel );
+        when others =>                     -- Invalid action
+          null;
+      end case;
+    exception
+      when Not_There =>                    -- Not there
+        Put("Name not in directory"); New_Line;
+      when Mainists =>                       -- Exists
+        Put("Name already in directory"); New_Line;
+    end;
+    Skip_Line;
+  end loop;
+end Main2;
+
+
+
+with Ada.Text_Io, Pack_Types, Class_Tel_List;
+use  Ada.Text_Io, Pack_Types, Class_Tel_List;
+procedure Main3 is
+  Tel_List : Pic;
+  Name     : Country;
+  Tel      : Idc;
+begin
+  Add( Tel_List, "Canada      ", "+1    " );
+  Add( Tel_List, "USA         ", "+1    " );
+  Add( Tel_List, "Netherlands ", "+31   " );
+  Add( Tel_List, "Belgium     ", "+32   " );
+  Add( Tel_List, "France      ", "+33   " );
+  Add( Tel_List, "Gibraltar   ", "+350  " );
+  Name := "France      ";
+  Extract( Tel_List, Name, Tel );
+  Put( "IDC for " ); Put( Name ); Put( " is "); Put( Tel ); New_Line;
+  Name := "USA         ";
+  Extract( Tel_List, Name, Tel );
+  Put( "IDC for " ); Put( Name ); Put( " is "); Put( Tel ); New_Line;
+end Main3;
+
+
+
+with Ada.Text_Io, Class_Tel_List;
+use  Ada.Text_Io, Class_Tel_List;
+procedure Main4 is
+  Tel_List : Pic;
+begin
+  Add( Tel_List, "Canada      ", "+1    " );
+  Put("Object identity is [" & Get_Name(Tel_List) & "]"); New_Line;
+  Set_Name( Tel_List, "tel_list.per" );
+  Put("Object identity is [" & Get_Name(Tel_List) & "]"); New_Line;
+  Discard( Tel_List );
+end Main4;
+
+
+
+
+--[main.adb] Procedure
+with Ada.Text_Io, Main1, Main2, Main3, Main4;
+use  Ada.Text_Io;
+procedure Main is
+begin
+  Put("Example Account 1 "); New_Line; Main1;
+  Put("Example Account 2 "); New_Line; Main2;
+  Put("Example Account 3 "); New_Line; Main3;
+  Put("Example Account 4 "); New_Line; Main4;
+end Main;
@@  x60_ll5.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:49 PM BST  --
+---------------------------------------------------------------------
+--[class_list.ads] Specification
+with Ada.Finalization, Unchecked_Deallocation;
+use  Ada.Finalization;
+generic
+  type T is private;                  -- Any type
+package Class_List is
+  type List is new Controlled with private;
+
+  procedure Initialize( The:in out List );
+  procedure Initialize( The:in out List; Data:in T );
+  procedure Finalize( The:in out List );
+  procedure Adjust( The:in out List );
+  function "="  ( F:in List; S:in List ) return Boolean;
+private
+  type Node;                       -- Tentative declaration
+  type P_Node is access all Node;  -- Pointer to Node
+
+  type Node is record
+    Prev    : P_Node;              -- Previous Node
+    Item    : T;                   -- The physical item
+    Next    : P_Node;              -- Next Node
+  end record;
+
+  type List is new Controlled with record
+    First_Node : aliased P_Node := null;   -- First item in list
+    Last_Node  : aliased P_Node := null;   -- First item in list
+  end record;
+
+end Class_List;
+
+
+
+
+
+--[class_list.adb] Implementation
+package body Class_List is
+
+  procedure Dispose_Node is
+    new Unchecked_Deallocation( Node, P_Node );
+
+  procedure Release_Storage( The:in out List ) is
+    Cur : P_Node := The.First_Node; -- Pointer to curr node
+    Tmp : P_Node;                   -- Node to dispose
+  begin
+    while Cur /= null loop          -- For each item in list
+      Tmp := Cur;                   -- Item to dispose
+      Cur := Cur.Next;              -- Next node
+      Dispose_Node( Tmp );          -- Dispose of item
+    end loop;
+  end Release_Storage;
+
+
+  procedure Initialize( The:in out List ) is
+  begin
+    The.First_Node := null;   -- Empty list
+    The.Last_Node  := null;   -- Empty list
+  end Initialize;
+
+  procedure Initialize( The:in out List; Data:in T ) is
+  begin
+    The.First_Node := new Node'(null, Data, null);
+    The.Last_Node  := The.First_Node;
+  end Initialize;
+
+  procedure Finalize( The:in out List ) is
+  begin
+    if The.First_Node /= null then
+      Release_Storage( The );
+      The.First_Node := null;
+    end if;
+  end Finalize;
+
+  procedure Adjust( The:in out List ) is
+    Cur : P_Node := The.First_Node;  -- Original list
+    Lst : P_Node := null;            -- Last created node
+    Prv : P_Node := null;            -- Previously created node
+    Fst : P_Node := null;            -- The first node
+
+  begin
+    while Cur /= null loop
+      Lst := new Node'( Prv, Cur.Item, null );
+      if Fst =  null then Fst := Lst; end if;
+      if Prv /= null then Prv.Next := Lst; end if;
+      Prv := Lst;
+      Cur := Cur.Next;               -- Next node
+    end loop;
+    The.First_Node := Fst;           -- Update
+    The.Last_Node  := Lst;
+  end Adjust;
+
+  function "="  ( F:in List; S:in List ) return Boolean is
+    F_Node : P_Node := F.First_Node;  -- First list
+    S_Node : P_Node := S.First_Node;  -- Second list
+  begin
+    while F_Node /= null and S_Node /= null loop
+      if F_Node.Item /= S_Node.Item then
+        return False;                 -- Different items
+      end if;
+      F_Node := F_Node.Next; S_Node := S_Node.Next;
+    end loop;
+    return F_Node = S_Node;           -- Both NULL if equal
+  end "=";
+
+end Class_List;
+
+
+
+--[class_list/iterator.ads] Specification
+--WITH Ada.Finalization; USE  Ada.Finalization;
+generic
+package Class_List.Iterator is
+
+  type List_Iter is limited private;
+
+  procedure First( The:in out List_Iter; L:in out List );
+  procedure Last( The:in out List_Iter; L:in out List );
+
+  function  Deliver( The:in List_Iter) return T;
+  procedure Insert( The:in out List_Iter; Data:in T );
+  procedure Delete( The:in out List_Iter );
+  function  Is_End( The:in List_Iter ) return Boolean;
+  procedure Next( The:in out List_Iter );
+  procedure Prev( The:in out List_Iter );
+private
+  type P_P_Node is access all P_Node;
+  type List_Iter is record
+    Cur_List_First: P_P_Node := null;    -- First in chain
+    Cur_List_Last : P_P_Node := null;    -- Last in chain
+    Cur_Node      : P_Node   := null;    -- Current item
+  end record;
+end Class_List.Iterator;
+
+
+
+--[class_list/iterator.adb] Implementation
+package body Class_List.Iterator is
+
+  procedure Dispose_Node is
+    new Unchecked_Deallocation( Node, P_Node );
+
+  procedure First( The:in out List_Iter; L:in out List ) is
+  begin
+    The.Cur_Node      := L.First_Node;       -- Set to first
+    The.Cur_List_First:= L.First_Node'Unchecked_Access;
+    The.Cur_List_Last := L.Last_Node'Unchecked_Access;
+  end First;
+
+  procedure Last( The:in out List_Iter; L:in out List ) is
+  begin
+    The.Cur_Node      := L.Last_Node;        -- Set to last
+    The.Cur_List_First:= L.First_Node'Unchecked_Access;
+    The.Cur_List_Last := L.Last_Node'Unchecked_Access;
+  end Last;
+
+  function Deliver( The:in List_Iter ) return T is
+  begin
+    return The.Cur_Node.Item;  -- The current item
+  end Deliver;
+
+  procedure Insert( The:in out List_Iter; Data:in T ) is
+    Tmp   : P_Node;
+    Cur   : P_Node   := The.Cur_Node;   -- Current element
+    First : P_P_Node := The.Cur_List_First;
+    Last  : P_P_Node := The.Cur_List_Last;
+  begin
+    if Cur = null then            -- Empty or last item
+      if First.all = null then    --  Empty list
+        Tmp := new Node'( null, Data, null );
+        First.all := Tmp;
+        Last.all  := Tmp;
+        The.Cur_Node := Tmp;
+      else                        --  Last
+        Tmp := new Node'( Last.all, Data, null );
+        Last.all.Next := Tmp;
+        Last.all      := Tmp;
+        The.Cur_Node := Tmp;
+      end if;
+    else
+      Tmp := new Node'( Cur.Prev, Data, Cur );
+      if Cur.Prev = null then      -- First item
+        First.all := Tmp;
+      else
+        Cur.Prev.Next := Tmp;
+      end if;
+      Cur.Prev := Tmp;
+    end if;
+  end Insert;
+
+  procedure Delete( The:in out List_Iter) is
+    Cur   : P_Node   := The.Cur_Node;   -- Current element
+    First : P_P_Node := The.Cur_List_First;
+    Last  : P_P_Node := The.Cur_List_Last;
+  begin
+    if Cur /= null then             -- Something to delete
+      if Cur.Prev /= null then      -- Fix forward pointer;
+        Cur.Prev.Next := Cur.Next;  --  Not first in chain
+      else
+        First.all := Cur.Next;      --  First in chain
+        if First.all = null then
+          Last.all := null;         --   Empty list
+        end if;
+      end if;
+      if Cur.Next /= null then      -- Fix backward pointer;
+        Cur.Next.Prev := Cur.Prev;  --  Not last in chain
+      else
+        Last.all := Cur.Prev;       --  Last in chain
+        if Last.all = null then
+          First.all := null;        --   Empty list
+        end if;
+      end if;
+      if Cur.Next /= null then      -- Fix current pointer
+        The.Cur_Node := Cur.Next;   --  next
+      elsif Cur.Prev /= null then
+        The.Cur_Node := Cur.Prev;   --  previous
+      else
+        The.Cur_Node := null;       --  none empty list
+      end if;
+      Dispose_Node( Cur );          -- Release storage
+    end if;
+  end Delete;
+
+  function  Is_End( The:in List_Iter ) return Boolean is
+  begin
+    return The.Cur_Node = null;               -- True if end
+  end Is_End;
+
+  procedure Next( The:in out List_Iter ) is
+  begin
+    if The.Cur_Node /= null then               --
+      The.Cur_Node  := The.Cur_Node.Next;      -- Next
+    end if;
+  end Next;
+
+  procedure Prev( The:in out List_Iter ) is
+  begin
+    if The.Cur_Node /= null then               --
+      The.Cur_Node  := The.Cur_Node.Prev;      -- Previous
+    end if;
+  end Prev;
+
+end Class_List.Iterator;
+
+
+--[class_list_nat.ADS] Implementation Instantiation
+with Class_List;
+  pragma Elaborate_All( Class_List );
+  package Class_List_Nat is new Class_List(Natural);
+
+
+--[class_list/Nat_Iterator.ADS] Implementation Instantiation
+with Class_List_Nat, Class_List.Iterator;
+  pragma Elaborate_All( Class_List_Nat, Class_List.Iterator );
+  package Class_List_Nat_Iterator is new Class_List_Nat.Iterator;
+
+
+
+
+--[pack_procedures.ads] Specification
+with Ada.Text_Io, Ada.Integer_Text_Io, Class_List_Nat, 
+     Class_List_Nat_Iterator;
+use  Ada.Text_Io, Ada.Integer_Text_Io, 
+     Class_List_Nat, Class_List_Nat_Iterator;
+
+procedure Main1 is
+  Numbers    : List;            -- List of Natural numbers
+  Numbers_It : List_Iter;       -- Iterator for list
+begin
+  First( Numbers_It, Numbers );
+  Insert( Numbers_It, 50 );
+  Insert( Numbers_It, 5 );
+  Insert( Numbers_It, 40 );
+  Last( Numbers_It, Numbers );
+  Next( Numbers_It );
+  Insert( Numbers_It, 100 );
+  Prev( Numbers_It );
+  Prev( Numbers_It );
+  Insert( Numbers_It, 30 );
+  First( Numbers_It, Numbers );
+  while not Is_End( Numbers_It ) loop
+    Put( Deliver( Numbers_It ) );
+    Next( Numbers_It );
+  end loop;
+  New_Line;
+end Main1;
+
+
+
+with Ada.Text_Io, Ada.Integer_Text_Io, Class_List_Nat, 
+     Class_List_Nat_Iterator;
+use  Ada.Text_Io, Ada.Integer_Text_Io, 
+     Class_List_Nat, Class_List_Nat_Iterator;
+procedure Main2 is
+  Numbers    : List;            -- List of Natural numbers
+  Numbers_It : List_Iter;       -- Iterator for list
+
+  procedure Insert( Pos:in Integer; Num:in Integer ) is
+    Count : Integer := Pos;
+  begin
+    First( Numbers_It, Numbers );
+    while Count >= 1 loop
+      Next( Numbers_It ); Count := Count-1;
+    end loop;
+    Insert( Numbers_It, Num );
+  end Insert;
+
+  procedure Delete( Pos:in Integer ) is
+    Count : Integer := Pos;
+  begin
+    First( Numbers_It, Numbers );
+    while Count >= 1 loop
+      Next( Numbers_It ); Count := Count-1;
+    end loop;
+    Delete( Numbers_It );
+  end Delete;
+
+  procedure Print is
+  begin
+    First( Numbers_It, Numbers );
+    while not Is_End(Numbers_It) loop
+      Put( Deliver(Numbers_It), Width=>3 );
+      Next( Numbers_It );
+    end loop;
+    New_Line;
+  end Print;
+
+begin
+  Insert( 0, 50 ); Print;
+  Put(" 50 <Should be>"); New_Line;
+  Delete( 0 ); Print;
+  Put(" <Should be>"); New_Line;
+
+  Insert( 0, 50 ); Print;
+  Put(" 50 <Should be>"); New_Line;
+  Insert( 0, 30 ); Print;
+  Put(" 30 50 <Should be>"); New_Line;
+  Insert( 1, 40 ); Print;
+  Put(" 30 40 50 <Should be>"); New_Line;
+  Insert( 2, 45 ); Print;
+  Put(" 30 40 45 50 <Should be>"); New_Line;
+  Insert( 2, 42 ); Print;
+  Put(" 30 40 42 45 50 <Should be>"); New_Line;
+  Insert( 5, 99 ); Print;
+  Put(" 30 40 42 45 50 99<Should be>"); New_Line;
+
+  Delete( 5 ); Print;
+  Put(" 30 40 42 45 50 <Should be>"); New_Line;
+  Delete( 0 ); Print;
+  Put(" 40 42 45 50 <Should be>"); New_Line;
+  Delete( 1 ); Print;
+  Put(" 40 45 50 <Should be>"); New_Line;
+  Delete( 2 ); Print;
+  Put(" 40 45 <Should be>"); New_Line;
+  Delete( 1 ); Print;
+  Put(" 40 <Should be>"); New_Line;
+  Delete( 0 ); Print;
+  Put(" <Should be>"); New_Line;
+end Main2;
+
+
+
+
+with Ada.Text_Io, Ada.Integer_Text_Io, Class_List_Nat, 
+     Class_List_Nat_Iterator;
+use  Ada.Text_Io, Ada.Integer_Text_Io, 
+     Class_List_Nat, Class_List_Nat_Iterator;
+procedure Main3 is
+  Numbers    : List;            -- List of Natural numbers
+  Numbers_It : List_Iter;       -- Iterator for list
+begin
+  First( Numbers_It, Numbers );
+  Insert( Numbers_It, 100 );
+  Insert( Numbers_It, 50 );
+
+  First( Numbers_It, Numbers );
+  while not Is_End(Numbers_It) loop
+    Put( Deliver(Numbers_It) ); Next( Numbers_It );
+  end loop;
+  New_Line;
+end Main3;
+
+
+
+
+with Ada.Text_Io, Ada.Integer_Text_Io, Class_List_Nat, 
+     Class_List_Nat_Iterator;
+use  Ada.Text_Io, Ada.Integer_Text_Io, 
+     Class_List_Nat, Class_List_Nat_Iterator;
+procedure Main4 is
+  Numbers    : List;
+  Numbers_It : List_Iter;
+  Value      : Integer;
+begin
+
+  First( Numbers_It, Numbers );             -- Setup iterator
+  for Number in 1 .. 10 loop
+    First( Numbers_It, Numbers );           -- Set iterator first
+    Insert( Numbers_It, Number );           -- Insert before
+  end loop;
+
+  First(Numbers_It,Numbers);                -- Set to start
+  while not Is_End( Numbers_It ) loop       -- Not end of list
+    Put( Deliver(Numbers_It) , Width=>3);   --  Print
+    Next( Numbers_It );                     -- Next item
+  end loop;
+  New_Line;
+
+  First(Numbers_It,Numbers);                -- Set to start
+  for Number in 1 .. 10 loop
+    delete( Numbers_It );                   -- Delete numbers
+  end loop;
+
+  Value := 1;
+  While Value <= 10 loop
+    Last( Numbers_It, Numbers );            -- Set iterator Last
+    Next( Numbers_It );                     -- Move beyond last
+    Insert( Numbers_It, Value );            -- Insert before
+    value := Value + 1;                     -- Increment
+  end loop;
+
+  First(Numbers_It,Numbers);                -- Set to start
+  while not Is_End( Numbers_It ) loop       -- Not end of list
+    Put( Deliver(Numbers_It) , Width=>3);   --  Print
+    Next( Numbers_It );                     -- Next item
+  end loop;
+  New_Line;
+
+
+end Main4;
+
+
+
+
+with Ada.Text_Io, Ada.Integer_Text_Io, Class_List_Nat, 
+     Class_List_Nat_Iterator;
+use  Ada.Text_Io, Ada.Integer_Text_Io, 
+     Class_List_Nat, Class_List_Nat_Iterator;
+procedure Main5 is
+  Numbers    : List;
+  Numbers_It : List_Iter;
+  Num,In_List: Natural;
+begin
+
+  while not End_Of_File loop               -- While data
+    while not End_Of_Line loop
+
+      Get(Num);                            -- Read number
+
+      First(Numbers_It,Numbers);           -- Iterator at start
+      while not Is_End( Numbers_It ) loop  -- scan through list
+        In_List := Deliver(Numbers_It);
+        exit when In_List > Num;           -- Exit when larger no.
+        Next( Numbers_It );                -- Next item
+      end loop;
+
+      Insert( Numbers_It, Num );           -- Insert before cur_node
+
+    end loop;
+    Skip_Line;                             -- Next line
+  end loop;
+
+  Put("Numbers sorted are: ");
+  First(Numbers_It,Numbers);                -- Set at start
+  while not Is_End( Numbers_It ) loop
+    In_List := Deliver( Numbers_It );       -- Current number
+    Put( In_List, width=>2 ); Put(" ");     --  Print
+    Next( Numbers_It );                     -- Next number
+  end loop;
+  New_Line;
+end Main5;
+
+
+with Ada.Text_Io, Ada.Integer_Text_Io, Class_List_Nat, 
+     Class_List_Nat_Iterator;
+use  Ada.Text_Io, Ada.Integer_Text_Io, 
+     Class_List_Nat, Class_List_Nat_Iterator;
+procedure Main6 is
+  Original: List;                      -- List of numbers
+  Copy    : List;                      -- List of numbers
+  Num_It  : List_Iter;                 -- Iterator
+  Number  : Integer;
+begin
+  Number := 1;
+  while Number <= 10 loop
+    Last( Num_It, Original );          -- Set iterator last
+    Next( Num_It );                    -- So can insert
+    Insert( Num_It, Number );          --   after last item
+    Number := Number + 1;
+  end loop;
+
+  Put("copy := original "); New_Line;
+  Copy := Original;
+
+  Put("copy = original ");
+  if Copy = Original then Put("True"); else Put("False"); end if;
+  New_Line;
+
+  Put("Append 99 to copy "); New_Line;
+  Last( Num_It, Copy ); Next( Num_It );
+  Insert( Num_It, 99 );
+
+  Put("copy = original ");
+  if Copy = Original then Put("True"); else Put("False"); end if;
+  New_Line;
+
+  First(Num_It,Original);               -- Set to start
+  while not Is_End( Num_It ) loop       -- Not end of list
+    Put( Deliver(Num_It), Width=>4 );   --  Print
+    Next( Num_It );                     -- Next item
+  end loop;
+
+  New_Line;
+  First(Num_It,Copy);                   -- Set to start
+  while not Is_End( Num_It ) loop       -- Not end of list
+    Put( Deliver(Num_It), Width=>4 );   --  Print
+    Next( Num_It );                     -- Next item
+  end loop;
+  New_Line;
+end Main6;
+
+
+
+--[main.adb] Procedure
+with Ada.Text_Io, Main1, Main2, Main3, Main4, Main5, Main6;
+use  Ada.Text_Io;
+procedure Main is
+begin
+  Put("Example Account 1 "); New_Line; Main1;
+  Put("Example Account 2 "); New_Line; Main2;
+  Put("Example Account 3 "); New_Line; Main3;
+  Put("Example Account 4 "); New_Line; Main4;
+  Put("Example Account 5 "); New_Line; Main5;
+  Put("Example Account 6 "); New_Line; Main6;
+end Main;
@@  x60_set.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:50 PM BST  --
+---------------------------------------------------------------------
+with Ada.Finalization, Unchecked_Deallocation;
+use  Ada.Finalization;
+generic
+  type T is private;                  -- Any type
+package Class_List is
+  type List is new Controlled with private;
+
+  procedure Initialize( The:in out List );
+  procedure Initialize( The:in out List; Data:in T );
+  procedure Finalize( The:in out List );
+  procedure Adjust( The:in out List );
+  function "="  ( F:in List; S:in List ) return Boolean;
+private
+  procedure Release_Storage( The:in out List );
+
+  type Node;                       -- Tentative declaration
+  type P_Node is access all Node;  -- Pointer to Node
+
+  type Node is record
+    Prev    : P_Node;              -- Previous Node
+    Item    : T;                   -- The physical item
+    Next    : P_Node;              -- Next Node
+  end record;
+
+  procedure Dispose_Node is
+    new Unchecked_Deallocation( Node, P_Node );
+  type List is new Controlled with record
+    First_Node : aliased P_Node := null;   -- First item in list
+    Last_Node  : aliased P_Node := null;   -- First item in list
+  end record;
+
+end Class_List;
+
+--[class_list.adb] Implementation
+--WITH Simple_io; USE  Simple_io;
+package body Class_List is
+
+  procedure Initialize( The:in out List ) is
+  begin
+    The.First_Node := null;   -- Empty list
+    The.Last_Node  := null;   -- Empty list
+  end Initialize;
+
+  procedure Initialize( The:in out List; Data:in T ) is
+  begin
+    The.First_Node := new Node'(null, Data, null);
+    The.Last_Node  := The.First_Node;
+  end Initialize;
+
+  procedure Finalize( The:in out List ) is
+  begin
+    if The.First_Node /= null then
+      Release_Storage( The );
+      The.First_Node := null;
+    end if;
+  end Finalize;
+
+  procedure Adjust( The:in out List ) is
+    Cur : P_Node := The.First_Node;  -- Original list
+    Lst : P_Node := null;            -- Last created node
+    Prv : P_Node := null;            -- Previously created node
+    Fst : P_Node := null;            -- The first node
+
+  begin
+    while Cur /= null loop
+      Lst := new Node'( Prv, Cur.Item, null );
+      if Fst =  null then Fst := Lst; end if;
+      if Prv /= null then Prv.Next := Lst; end if;
+      Prv := Lst;
+      Cur := Cur.Next;               -- Next node
+    end loop;
+    The.First_Node := Fst;           -- Update
+    The.Last_Node  := Lst;
+  end Adjust;
+
+  function "="  ( F:in List; S:in List ) return Boolean is
+    F_Node : P_Node := F.First_Node;  -- First list
+    S_Node : P_Node := S.First_Node;  -- Second list
+  begin
+    while F_Node /= null and S_Node /= null loop
+      if F_Node.Item /= S_Node.Item then
+        return False;                 -- Different items
+      end if;
+      F_Node := F_Node.Next; S_Node := S_Node.Next;
+    end loop;
+    return F_Node = S_Node;           -- Both NULL if equal
+  end "=";
+
+  procedure Release_Storage( The:in out List ) is
+    Cur : P_Node := The.First_Node; -- Pointer to curr node
+    Tmp : P_Node;                   -- Node to dispose
+  begin
+    while Cur /= null loop          -- For each item in list
+      Tmp := Cur;                   -- Item to dispose
+      Cur := Cur.Next;              -- Next node
+      Dispose_Node( Tmp );          -- Dispose of item
+    end loop;
+  end Release_Storage;
+
+end Class_List;
+
+--[class_list/iterator.ads] Specification
+--WITH Ada.Finalization; USE  Ada.Finalization;
+generic
+package Class_List.Iterator is
+
+  type List_Iter is limited private;
+
+  procedure Initialize( The:in out List_Iter );
+  procedure Finalize( The:in out List_Iter );
+  procedure First( The:in out List_Iter; L:in out List );
+  procedure Last( The:in out List_Iter; L:in out List );
+
+  function  Deliver( The:in List_Iter) return T;
+  procedure Insert( The:in out List_Iter; Data:in T );
+  procedure Delete( The:in out List_Iter );
+  function  Is_End( The:in List_Iter ) return Boolean;
+  procedure Next( The:in out List_Iter );
+  procedure Prev( The:in out List_Iter );
+private
+  type P_P_Node is access all P_Node;
+  type List_Iter is record
+    Cur_List_First: P_P_Node := null;    -- First in chain
+    Cur_List_Last : P_P_Node := null;    -- Last in chain
+    Cur_Node      : P_Node   := null;    -- Current item
+  end record;
+end Class_List.Iterator;
+
+--[class_list/iterator.adb] Implementation
+--WITH Simple_io; USE Simple_io;
+package body Class_List.Iterator is
+
+  procedure Initialize( The:in out List_Iter ) is
+  begin
+    The.Cur_Node       := null;   -- Iterator not setup
+    The.Cur_List_First := null;
+    The.Cur_List_Last  := null;
+  end Initialize;
+
+  procedure Finalize( The:in out List_Iter ) is
+  begin
+    null;
+  end Finalize;
+
+  procedure First( The:in out List_Iter; L:in out List ) is
+  begin
+    The.Cur_Node      := L.First_Node;       -- Set to first
+    The.Cur_List_First:= L.First_Node'Unchecked_Access;
+    The.Cur_List_Last := L.Last_Node'Unchecked_Access;
+  end First;
+
+  procedure Last( The:in out List_Iter; L:in out List ) is
+  begin
+    The.Cur_Node      := L.Last_Node;        -- Set to last
+    The.Cur_List_First:= L.First_Node'Unchecked_Access;
+    The.Cur_List_Last := L.Last_Node'Unchecked_Access;
+  end Last;
+
+  function Deliver( The:in List_Iter ) return T is
+  begin
+    return The.Cur_Node.Item;  -- The current item
+  end Deliver;
+
+  procedure Insert( The:in out List_Iter; Data:in T ) is
+    Tmp   : P_Node;
+    Cur   : P_Node   := The.Cur_Node;   -- Current element
+    First : P_P_Node := The.Cur_List_First;
+    Last  : P_P_Node := The.Cur_List_Last;
+  begin
+    if Cur = null then            -- Empty or last item
+      if First.all = null then    --  Empty list
+        Tmp := new Node'( null, Data, null );
+        First.all := Tmp;
+        Last.all  := Tmp;
+        The.Cur_Node := Tmp;
+      else                        --  Last
+        Tmp := new Node'( Last.all, Data, null );
+        Last.all.Next := Tmp;
+        Last.all      := Tmp;
+        The.Cur_Node := Tmp;
+      end if;
+    else
+      Tmp := new Node'( Cur.Prev, Data, Cur );
+      if Cur.Prev = null then      -- First item
+        First.all := Tmp;
+      else
+        Cur.Prev.Next := Tmp;
+      end if;
+      Cur.Prev := Tmp;
+    end if;
+  end Insert;
+
+  procedure Delete( The:in out List_Iter) is
+    Cur   : P_Node   := The.Cur_Node;   -- Current element
+    First : P_P_Node := The.Cur_List_First;
+    Last  : P_P_Node := The.Cur_List_Last;
+  begin
+    if Cur /= null then             -- Something to delete
+      if Cur.Prev /= null then      -- Fix forward pointer;
+        Cur.Prev.Next := Cur.Next;  --  Not first in chain
+      else
+        First.all := Cur.Next;      --  First in chain
+        if First.all = null then
+          Last.all := null;         --   Empty list
+        end if;
+      end if;
+      if Cur.Next /= null then      -- Fix backward pointer;
+        Cur.Next.Prev := Cur.Prev;  --  Not last in chain
+      else
+        Last.all := Cur.Prev;       --  Last in chain
+        if Last.all = null then
+          First.all := null;        --   Empty list
+        end if;
+      end if;
+      if Cur.Next /= null then      -- Fix current pointer
+        The.Cur_Node := Cur.Next;   --  next
+      elsif Cur.Prev /= null then
+        The.Cur_Node := Cur.Prev;   --  previous
+      else
+        The.Cur_Node := null;       --  none empty list
+      end if;
+      Dispose_Node( Cur );          -- Release storage
+    end if;
+  end Delete;
+
+  function  Is_End( The:in List_Iter ) return Boolean is
+  begin
+    return The.Cur_Node = null;               -- True if end
+  end Is_End;
+
+  procedure Next( The:in out List_Iter ) is
+  begin
+    if The.Cur_Node /= null then               --
+      The.Cur_Node  := The.Cur_Node.Next;      -- Next
+    end if;
+  end Next;
+
+  procedure Prev( The:in out List_Iter ) is
+  begin
+    if The.Cur_Node /= null then               --
+      The.Cur_Node  := The.Cur_Node.Prev;      -- Previous
+    end if;
+  end Prev;
+
+end Class_List.Iterator;
+
+--[class_set.ads] Specification
+with Class_List, Class_List.Iterator;
+pragma Elaborate_All( Class_List, Class_List.Iterator );
+generic
+  type T is private;
+  with procedure Put( Item:in T ) is <>;
+  with function  ">" (First,Second:in T ) return Boolean is <>;
+  with function  "<" (First,Second:in T ) return Boolean is <>;
+package Class_Set is
+  type Set is private;
+  procedure Put( The:in Set );
+  function "+"( F:in Set; S:in Set ) return Set;
+  function Set_Const( Item: in T )   return Set;
+  function Members( The:in Set )     return Positive;
+private
+  package Class_List_T          is new Class_List(T);
+  package Class_List_T_Iterator is new Class_List_T.Iterator;
+  type Set is new Class_List_T.List with record
+    Elements : Natural := 0;             -- Elements in set
+  end record;
+end Class_Set;
+
+--[class_set.adb] Implementation
+with Ada.Text_Io;
+use  Ada.Text_Io;
+package body Class_Set is
+  use Class_List_T, Class_List_T_Iterator;
+
+  procedure Put( The:in Set ) is
+    It    : List_Iter;
+    C_The : List := List(The);
+  begin
+    Put("("); First( It, C_The );
+    for I in 1 .. The.Elements loop
+      Put( Deliver(It) ); Next( It );
+      if I /= The.Elements then Put(","); end if;
+    end loop;
+    Put(")");
+  end Put;
+
+  function "+"  ( F:in Set; S:in Set ) return Set is
+    Res_It    : List_Iter;
+    F_It,S_It : List_Iter;
+    Res       : Set;
+    F_List, S_List: List;
+  begin
+    F_List := List(F); S_List := List(S);
+    First( F_It, List(F_List) );
+    First( S_It, List(S_List) );
+    First( Res_It, List(Res) );
+
+    while (not Is_End(F_It)) or (not Is_End(S_It)) loop
+      if Is_End(F_It) then
+        Next(Res_It); Insert(Res_It, Deliver(S_It));
+        Next(S_It);
+      elsif Is_End(S_It) then
+        Next(Res_It); Insert(Res_It, Deliver(F_It));
+        Next(F_It);
+      elsif Deliver(F_It) < Deliver(S_It) then
+        Next(Res_It); Insert(Res_It, Deliver(F_It));
+        Next(F_It);
+      elsif Deliver(F_It) > Deliver(S_It) then
+        Next(Res_It); Insert(Res_It, Deliver(S_It));
+        Next(S_It);
+      elsif Deliver(F_It) = Deliver(S_It) then
+        Next(Res_It); Insert(Res_It, Deliver(F_It) );
+        Next(F_It); Next(S_It);
+      end if;
+      Res.Elements := Res.Elements + 1;
+    end loop;
+    return Res;
+  end "+";
+
+
+  function Set_Const( Item: in T ) return Set is
+    Res : Set;
+  begin
+    Initialize( Res, Item ); Res.Elements := 1;
+    return Res;
+  end Set_Const;
+
+  function Members( The:in Set ) return Positive is
+  begin
+    return The.Elements;
+  end Members;
+
+end Class_Set;
+
+-- =======================================================
+
+-- =======================================================
+
+package Pack_Types is
+  type Filling is ( Cheese, Onion, Ham, Tomato );
+end Pack_Types;
+
+with Ada.Text_Io, Pack_Types;
+use  Ada.Text_Io, Pack_Types;
+procedure Put_Filling( C:in Filling ) is
+begin
+  Put( Filling'Image( C ) );
+end Put_Filling;
+
+with Pack_Types, Class_Set, Put_Filling;
+use  Pack_Types;                          -- **** Object Ada
+pragma Elaborate_All( Class_Set );
+package Class_Set_Sandwich is
+  new Class_Set( T => Pack_Types.Filling, Put => Put_Filling );
+
+--[main1.adb] Procedure
+with Pack_Types, Ada.Text_Io, Ada.Integer_Text_Io, Class_Set_Sandwich;
+use  Pack_Types, Ada.Text_Io, Ada.Integer_Text_Io, Class_Set_Sandwich;
+procedure Main1 is
+  Sandwich : Class_Set_Sandwich.Set;
+begin
+  Sandwich := Sandwich + Set_Const(Cheese);
+  Sandwich := Sandwich + Set_Const(Onion) ;
+  Put("Contents of sandwich are : ");
+  Put( Sandwich ); New_Line;
+  Put("Number of ingredients is : ");
+  Put( Members(Sandwich) ); New_Line;
+  null;
+end Main1;
+
+-- =======================================================
+
+with Ada.Integer_Text_Io;
+procedure Put_Natural( N:in Natural ) is
+begin
+  Ada.Integer_Text_Io.Put( N, Width=>2 );
+end Put_Natural;
+
+with Class_Set, Put_Natural;
+pragma Elaborate_All( Class_Set );
+package Class_Set_Naturals is
+  new Class_Set( T => Natural, Put => Put_Natural );
+
+--[main2.adb] Procedure
+with Ada.Text_Io, Class_Set_Naturals;
+use  Ada.Text_Io, Class_Set_Naturals;
+procedure Main2 is
+  Set1 : Class_Set_Naturals.Set;
+  Set2 : Class_Set_Naturals.Set;
+  Set3 : Class_Set_Naturals.Set;
+begin
+  for I in 1 .. 5 loop
+    Set1 := Set1 + Set_Const(I*2);
+  end loop;
+  Put( "Set 1 =       "); Put( Set1 ); New_Line;
+  for I in 1 .. 5 loop
+    Set2 := Set2 + Set_Const(I*2+1);
+  end loop;
+  Put( "Set 2 =       "); Put( Set2 ); New_Line;
+  Put( "Set 1 + Set 2 ");
+  Put( Set1+Set2 ); New_Line;
+  for I in 4 .. 15 loop
+    Set3 := Set3 + Set_Const(I);
+  end loop;
+  Put( "Set 3 =       "); Put( Set3 ); New_Line;
+  Put( "Set 2 + Set 3 ");
+  Put( Set2+Set3 ); New_Line;
+end Main2;
+
+
+--[main3.adb] Procedure
+with Ada.Text_Io, Class_Set_Naturals;
+use  Ada.Text_Io, Class_Set_Naturals;
+procedure Main3 is
+  Set1 : Class_Set_Naturals.Set;
+  Set2 : Class_Set_Naturals.Set;
+  Set3 : Class_Set_Naturals.Set;
+begin
+  for I in 1 .. 5 loop
+    Set1 := Set1 + Set_Const(I*2);
+  end loop;
+  Put( "Set 1 =       "); Put( Set1 ); New_Line;
+  for I in 1 .. 5 loop
+    Set2 := Set2 + Set_Const(I*2+1);
+  end loop;
+  Put( "Set 2 =       "); Put( Set2 ); New_Line;
+  Put( "Set 1 + Set 2 ");
+  Put( Set1+Set2 ); New_Line;
+  Set3 := Set1 + Set2;
+  Put( Set3 ); New_Line;
+  Set3 := Set3 +  Set_Const(100);
+  Put( Set3 ); New_Line;
+  Put( Set2 ); New_Line;
+  Put( Set1 ); New_Line;
+end Main3;
+
+--[main4.adb] Procedure
+procedure Main4 is
+begin
+  null;
+end Main4;
+
+--[main.adb] Procedure
+with Ada.Text_Io, Main1, Main2, Main3, Main4;
+use  Ada.Text_Io;
+procedure Main is
+begin
+  Put("Example 1 "); New_Line; Main1;
+  Put("Example 2 "); New_Line; Main2;
+  Put("Example 3 "); New_Line; Main3;
+  Put("Example 4 "); New_Line; Main4;
+end Main;
@@  x61_rc_g.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:51 PM BST  --
+---------------------------------------------------------------------
+
+--[class_account.ads] Specification
+package Class_Account is
+
+  type Account is private;
+  subtype Money  is Float;
+  subtype Pmoney is Float range 0.0 .. Float'Last;
+
+  procedure Deposit ( The:in out Account; Amount:in Pmoney );
+  procedure Withdraw( The:in out Account; Amount:in Pmoney;
+    Get:out Pmoney );
+  function  Balance ( The:in Account ) return Money;
+
+private
+  type Account is record
+    Balance_Of : Money := 0.00;      -- Amount in account
+  end record;
+end Class_Account;
+
+
+--[class_account.adb] Implementation
+package body Class_Account is
+
+
+  procedure Deposit ( The:in out Account; Amount:in Pmoney ) is
+  begin
+    The.Balance_Of := The.Balance_Of + Amount;
+  end Deposit;
+
+  procedure Withdraw( The:in out Account; Amount:in Pmoney;
+      Get:out Pmoney ) is
+  begin
+    if The.Balance_Of >= Amount then
+      The.Balance_Of := The.Balance_Of - Amount;
+      Get := Amount;
+    else
+      Get := 0.00;
+    end if;
+  end Withdraw;
+
+  function  Balance( The:in Account ) return Money is
+  begin
+    return The.Balance_Of;
+  end Balance;
+
+end Class_Account;
+
+
+-- Generic IN        constant
+--         IN OUT    Renaming
+
+
+
+
+--[class_object_rc.ads] Specification
+with Ada.Finalization; use Ada.Finalization;
+generic
+  type T is private;                    -- The type
+  Null_Value:in T;                      -- Identity element
+package Class_Object_Rc is
+  type Object is new Controlled with private;
+  type P_T is access all T;
+
+  procedure Initialize( The:in out Object );
+  procedure Initialize( The:in out Object; Data:in T );
+  procedure Finalize( The:in out Object );
+  procedure Adjust( The:in out Object );
+  function  Deliver( The:in Object) return T;
+  function  Deliver_Ref( The:in Object) return P_T;
+  procedure Unique( The:in out Object);
+private
+  procedure Build_Storage ( The:in out Object; Value:in T );
+  procedure Release_Storage( The:in out Object );
+
+  type Descriptor;
+  type P_Descriptor is access all Descriptor;
+
+  type Descriptor is record
+    Refs   : Natural;       -- References to this data
+    Object : aliased T;     -- The physical data
+  end record;
+
+  type Object is new Controlled with record
+    P_Desc : P_Descriptor:= null; -- Descriptor for a number
+  end record;
+
+end Class_Object_Rc;
+
+
+
+
+--[class_object_rc.adb] Implementation
+with Unchecked_Deallocation;
+package body Class_Object_Rc is
+
+  procedure Initialize( The:in out Object ) is
+  begin
+    Build_Storage( The, Null_Value );
+  end Initialize;
+
+  procedure Initialize( The:in out Object; Data:in T ) is
+  begin
+    Build_Storage( The, Data );
+  end Initialize;
+
+  procedure Build_Storage ( The:in out Object; Value:in T ) is
+  begin
+    The.P_Desc := new Descriptor'(1,Value);
+  end Build_Storage;
+
+  procedure Finalize( The:in out Object ) is
+  begin
+    if The.P_Desc /= null then
+      Release_Storage( The );
+      The.P_Desc := null;
+    end if;
+  end Finalize;
+
+  procedure Dispose is
+    new Unchecked_Deallocation( Descriptor, P_Descriptor );
+
+  procedure Release_Storage( The:in out Object ) is
+  begin
+    The.P_Desc.Refs := The.P_Desc.Refs-1;
+    if The.P_Desc.Refs = 0 then
+      Dispose( The.P_Desc );
+    else
+      null;
+    end if;
+  end Release_Storage;
+
+  procedure Adjust( The:in out Object ) is
+  begin
+    The.P_Desc.Refs := The.P_Desc.Refs+1;
+  end Adjust;
+
+  function  Deliver( The:in Object) return T is
+  begin
+    return The.P_Desc.Object;
+  end Deliver;
+
+  function  Deliver_Ref( The:in Object) return P_T is
+  begin
+    return The.P_Desc.Object'access;
+  end Deliver_Ref;
+
+  procedure Unique( The:in out Object) is
+    Tmp : P_Descriptor;
+  begin
+    if The.P_Desc.Refs > 1 then
+      The.P_Desc.Refs := The.P_Desc.Refs-1;
+      Tmp := new Descriptor'(1,The.P_Desc.Object);
+      The.P_Desc := Tmp;
+    end if;
+  end Unique;
+end Class_Object_Rc;
+
+
+
+
+--[class_object_rc_int.ADS] Specification Instantiation
+with Class_Object_Rc;
+  pragma Elaborate_All( Class_Object_Rc );
+  package Class_Rc_Integer is
+           new Class_Object_Rc(Integer, 0);
+
+--[class_ref_integer.ads] Specification
+with Class_Rc_Integer; use Class_Rc_Integer;
+package Class_Ref_Integer is
+  type Ref_Integer is new Object with null record;
+  function  Number_Const( Value:in Integer ) return Ref_Integer;
+  function "+" ( L,R:in Ref_Integer ) return Ref_Integer;
+  function "=" ( L,R:in Ref_Integer ) return Boolean;
+end Class_Ref_Integer;
+
+--[class_ref_integer.adb] Implementation
+package body Class_Ref_Integer is
+  function  Number_Const( Value:in Integer ) return Ref_Integer is
+    Res: Ref_Integer;
+  begin
+    Initialize( Res, Value );
+    return Res;
+  end Number_Const;
+
+  function "+" ( L,R:in Ref_Integer ) return Ref_Integer is
+    Res : Ref_Integer;
+  begin
+    Initialize( Res, Deliver(L) + Deliver(R) );
+    return Res;
+  end "+";
+
+  function "=" ( L,R:in Ref_Integer ) return Boolean is
+  begin
+    return Deliver(L) = Deliver(R);
+  end "=";
+end Class_Ref_Integer;
+
+
+--[pack_procedures.adb] Implementation
+with Ada.Text_Io, Ada.Integer_Text_Io, Ada.Float_Text_Io, Class_Rc_Integer;
+use  Ada.Text_Io, Ada.Integer_Text_Io, Ada.Float_Text_Io, Class_Rc_Integer;
+procedure Main1 is
+  A,B,C : Class_Rc_Integer.Object;
+begin
+  Initialize( B, 10 );
+  Initialize( C, 20 );
+
+  Put("a := b; "); New_Line;
+  A := B;
+
+  Put("b := c; "); New_Line;
+  B := C;
+
+  Put("c := a; "); New_Line;
+  C := A;
+
+  Put("a = "); Put( Deliver( A ) ); New_Line;
+  Put("b = "); Put( Deliver( B ) ); New_Line;
+  Put("c = "); Put( Deliver( C ) ); New_Line;
+
+end Main1;
+
+package Pack_Types is
+  type P_Integer is access all Integer;
+end Pack_Types;
+
+with Pack_Types, Class_Object_Rc;
+package Class_Object_Rc_P_Int is
+  new Class_Object_Rc(Pack_Types.P_Integer, null);
+
+with Ada.Text_Io, Ada.Integer_Text_Io, Class_Object_Rc_P_Int;
+use  Ada.Text_Io, Ada.Integer_Text_Io, Class_Object_Rc_P_Int;
+procedure Main2 is
+  A,B,C  : Object;
+begin
+  Initialize( A, new Integer'(10) );
+  Initialize( B, new Integer'(20) );
+
+  Put("a := b; "); New_Line;
+  A := B;
+  Put("a = "); Put( Deliver( A ).all ); New_Line;
+  Put("b = "); Put( Deliver( B ).all ); New_Line;
+end Main2;
+
+procedure Main3 is
+begin
+  null;
+end Main3;
+
+with Class_Account;
+package Pack_Consts is
+  Null_Account: Class_Account.Account;
+end Pack_Consts;
+
+with Pack_Consts, Class_Object_Rc, Class_Account;
+package Class_Account_Rc is
+  new Class_Object_Rc(Class_Account.Account, Pack_Consts.Null_Account);
+
+
+with Ada.Text_Io, Ada.Float_Text_Io, Class_Account;
+use  Ada.Text_Io, Ada.Float_Text_Io, Class_Account;
+procedure Statement( An_Account:in Account ) is
+begin
+  Put("Mini statement: The amount on deposit is $" );
+  Put( Balance( An_Account), Aft=>2, Exp=>0 );
+  New_Line(2);
+end Statement;
+
+with Ada.Text_Io, Ada.Float_Text_Io, 
+     Class_Account, Class_Account_Rc, Statement;
+use  Ada.Text_Io, Ada.Float_Text_Io, 
+     Class_Account, Class_Account_Rc; 
+procedure Main4 is
+  Original,Copy : Class_Account_Rc.Object;
+begin
+  Deposit( Deliver_Ref(Original).all, 100.00 );
+  Put("copy := original; (Shallow copy)"); New_Line;
+  Copy := Original;                           -- Shallow copy
+  Statement( Deliver_Ref(Original).all );     -- The same object
+  Statement( Deliver_Ref(Copy).all );         --  "  "
+  Put("Make copy unique (Deep copy if necessary)"); New_Line;
+  Unique( Copy );                             -- Deep copy
+  Deposit( Deliver_Ref(Copy).all, 20.00 );    -- copy only
+  Statement( Deliver_Ref(Original).all );     -- Unique object
+  Statement( Deliver_Ref(Copy).all );         --   "   "
+end Main4;
+
+with Ada.Text_Io, Ada.Integer_Text_Io, Class_Rc_Integer;
+use  Ada.Text_Io, Ada.Integer_Text_Io, Class_Rc_Integer;
+procedure Main5 is
+  A : Class_Rc_Integer.Object;
+begin
+  Initialize( A, 20 );
+  Put("a = "); Put( Deliver( A ) ); New_Line;
+
+  Put("a := a; "); New_Line;
+  A := A;
+
+  Put("a = "); Put( Deliver( A ) ); New_Line;
+
+end Main5;
+
+--[main.adb] Procedure
+with Ada.Text_Io, Main1, Main2, Main3, Main4, Main5;
+use  Ada.Text_Io;
+procedure Main is
+begin
+  Put("Example 1"); New_Line; Main1;
+  Put("Example 2"); New_Line; Main2;
+  Put("Example 3"); New_Line; Main3;
+  Put("Example 4"); New_Line; Main4;
+  Put("Example 5"); New_Line; Main5;
+end Main;
@@  x70_cc1.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:52 PM BST  --
+---------------------------------------------------------------------
+--[pack_factorial.ads] Specification
+package Pack_Factorial is
+  task type Task_Factorial is                -- Specification
+    entry Start( F:in Positive );            -- Rendezvous
+    entry Finish( Result:out Positive );     -- Rendezvous
+  end Task_Factorial;
+end Pack_Factorial;
+
+--[pack_factorial.adb] Implementation
+package body Pack_Factorial is
+  task body Task_Factorial is                -- Implementation
+    Factorial : Positive;
+    Answer    : Positive := 1;
+  begin
+    accept Start( F:in Positive ) do         -- Factorial
+      Factorial := F;
+    end Start;
+    for I in 2 .. Factorial loop             -- Calculate
+      Answer := Answer * I;
+    end loop;
+    accept Finish( Result:out Positive ) do -- Return answer
+      Result := Answer;
+    end Finish;
+  end Task_Factorial;
+end Pack_Factorial;
+
+--[pack_is_a_prime.ads] Specification
+package Pack_Is_A_Prime is
+  task type Task_Is_Prime is                 -- Specification
+    entry Start( P:in Positive );            -- Rendezvous
+    entry Finish( Result:out Boolean );      -- Rendezvous
+  end Task_Is_Prime;
+end Pack_Is_A_Prime;
+
+--[pack_is_a_prime.adb] Implementation
+package body Pack_Is_A_Prime is
+  task body Task_Is_Prime is                 -- Implementation
+    Prime : Positive;
+    Answer: Boolean := True;
+  begin
+    accept Start( P:in Positive ) do         -- Factorial
+      Prime := P;
+    end Start;
+    for I in 2 .. Prime-1 loop               -- Calculate
+      if Prime rem I = 0 then
+        Answer := False; exit;
+      end if;
+    end loop;
+    accept Finish( Result:out Boolean ) do  -- Return answer
+      Result := Answer;
+    end Finish;
+  end Task_Is_Prime;
+end Pack_Is_A_Prime;
+
+--[execute_threads.adb] Procedure
+with Ada.Text_Io, Ada.Integer_Text_Io, Pack_Factorial, Pack_Is_A_Prime;
+use  Ada.Text_Io, Ada.Integer_Text_Io, Pack_Factorial, Pack_Is_A_Prime;
+procedure Main is
+  Thread_1 : Task_Factorial;
+  Thread_2 : Task_Factorial;
+  Thread_3 : Task_Is_Prime;
+  Factorial: Positive;
+  Prime    : Boolean;
+
+begin
+  Thread_1.Start(5);            -- Start factorial calculation
+  Thread_2.Start(7);            -- Start factorial calculation
+  Thread_3.Start(97);           -- Start is_prime  calculation
+
+  Put("Factorial  5 is ");
+  Thread_1.Finish( Factorial ); -- Obtain result
+  Put( Factorial ); New_Line;
+
+  Put("Factorial  8 is ");
+  Thread_2.Finish( Factorial ); -- Obtain result
+  Put( Factorial ); New_Line;
+
+  Put("97 is a prime is ");
+  Thread_3.Finish( Prime );     -- Obtain result
+  if Prime then                 --
+     Put("True");               --   and print
+  else 
+     Put("False"); 
+  end if; 
+  New_Line;
+end Main;
@@  x70_cc4.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:53 PM BST  --
+---------------------------------------------------------------------
+--[pack_types.ads] Specification
+with Ada.Text_Io;
+use  Ada.Text_Io;
+package Pack_Types is
+  type P_File_Type is access all Ada.Text_Io.File_Type;
+  Eot  : constant Character := Character'Val(0);
+  Cr   : constant Character := Character'Val(15);
+  Queue_Size    : constant := 3;
+
+  type    Queue_No    is new Integer   range 0 .. Queue_Size;
+  type    Queue_Index is mod Queue_Size;
+  subtype Queue_Range is Queue_Index;
+  type    Queue_Array is array ( Queue_Range ) of Character;
+end Pack_Types;
+
+--[pack_threads.ads] Specification
+with Pack_Types;
+use  Pack_Types;
+package Pack_Threads is
+  protected type PT_Buffer is         -- Task type specification
+    entry Put( Ch:in Character; No_More:in Boolean );
+    entry Get( Ch:in out Character; No_More:out Boolean);
+  private
+    Elements    : Queue_Array;              -- Array of elements
+    Head        : Queue_Index := 0;         -- Index
+    Tail        : Queue_Index := 0;         -- Index
+    No_In_Queue : Queue_No    := 0;         -- Number in queue
+    Fin         : Boolean     := False;     -- Finish;
+  end PT_Buffer;
+
+  type P_PT_Buffer is access all PT_Buffer;
+
+  task type Task_Read( P_Buffer:P_PT_Buffer;
+                       Fd_In:P_File_Type) is
+    entry Finish;
+  end Task_Read;
+
+  task type Task_Write( P_Buffer:P_PT_Buffer; 
+                        Fd_Out:P_File_Type) is
+    entry Finish;
+  end Task_Write;
+end Pack_Threads;
+
+--[pack_threads.adb] Implementation
+with Ada.Text_Io;
+use  Ada.Text_Io;
+package body Pack_Threads is
+
+  protected body PT_Buffer is
+
+    entry Put( Ch:in Character; No_More:in Boolean )
+        when No_In_Queue < Queue_Size  is
+    begin
+      if No_More then                    -- Last
+        Fin := True;                     -- Set flag
+      else
+        Elements( Tail ) := Ch;          -- Add to queue
+        Tail := Tail+1;                  -- Next position
+        No_In_Queue := No_In_Queue + 1;  --
+      end if;
+    end;
+
+    entry Get(Ch:in out Character; No_More:out Boolean)
+        when No_In_Queue > 0 or else Fin is
+    begin
+      if No_In_Queue > 0 then             -- Item available
+        Ch := Elements( Head );           -- Get item
+        Head := Head+1;                   -- Next position
+        No_In_Queue := No_In_Queue - 1;   --
+        No_More := False;                 -- Not end
+      else
+        No_More := True;                  -- End of items
+      end if;
+    end;
+
+  end PT_Buffer;
+
+  task body Task_Read is                  -- Task implementation
+    Ch      : Character;
+  begin
+    while not End_Of_File( Fd_In.all ) loop
+      while not End_Of_Line( Fd_In.all ) loop
+        Get( Fd_In.all, Ch);              -- Get character
+        P_Buffer.Put( Ch, False );        -- Add to buffer
+        --DELAY 0.00001;                  -- Cause task switch
+      end loop;
+      Skip_Line( Fd_In.all );             -- Next line
+      P_Buffer.Put( Cr, False );          -- New line
+      --DELAY 0.00001;                    -- Cause task switch
+    end loop;
+    P_Buffer.Put( Eot, True );            -- End of characters
+
+    accept Finish;
+  exception
+    when Tasking_Error =>
+      Put("Exception in Task read"); New_Line;
+  end Task_Read;
+
+  task body Task_Write is                 -- Task implementation
+    Last     : Boolean := False;          -- No more data
+    Ch       : Character;                 -- Character read
+  begin
+    loop
+      P_Buffer.Get( Ch, Last );           -- From buffer
+      exit when Last;                     -- No more characters
+      if Ch = Cr then
+        New_Line( Fd_Out.all );           -- New line
+      else
+        Put( Fd_Out.all, Ch );            -- Character
+      end if;
+      --DELAY 0.00001;                    -- Cause task switch
+    end loop;
+
+    accept Finish;                        -- Finished
+  exception
+    when Tasking_Error =>
+      Put("Exception in Task write"); New_Line;
+  end Task_Write;
+end Pack_Threads;
+
+--[copy.adb] Procedure
+with Ada.Text_Io, Pack_Threads, Pack_Types;
+use  Ada.Text_Io, Pack_Threads, Pack_Types;
+procedure Do_Copy(From:in String; To:in String) is
+  type State is ( Open_File, Create_File );
+  Fd_In   : P_File_Type := new Ada.Text_Io.File_Type;
+  Fd_Out  : P_File_Type := new Ada.Text_Io.File_Type;
+  Mode    : State := Open_File;
+begin
+  Open(  File=>Fd_In.all,  Mode=>In_File,  Name=>From);
+  Mode := Create_File;
+  Create(File=>Fd_Out.all, Mode=>Out_File, Name=>To);
+  declare
+    Buffers : P_PT_Buffer := new PT_Buffer;
+    Reader  : Task_Read( Buffers, Fd_In );
+    Writer  : Task_Write( Buffers, Fd_Out );
+  begin
+    Reader.Finish;  Close( Fd_In.all );   -- Finish reader task
+    Writer.Finish;  Close( Fd_Out.all );  -- Finish writer task
+  end;
+exception
+  when Name_Error =>
+    case Mode is
+      when Open_File =>
+        Put("Problem opening file " & From ); New_Line;
+      when Create_File =>
+        Put("Problem creating file " & To ); New_Line;
+    end case;
+  when Tasking_Error =>
+    Put("Task error in main program"); New_Line;
+end Do_Copy;
+
+--[main.adb] Procedure
+with Ada.Text_Io, Ada.Command_Line, Do_Copy;
+use  Ada.Text_Io, Ada.Command_Line;
+procedure Copy is
+begin
+  if Argument_Count = 2 then
+    Do_Copy ( Argument(1), Argument(2) );
+  else
+    Put("Usage: copy from to"); New_Line;
+  end if;
+end Copy;
@@  x72_t0.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:53 PM BST  --
+---------------------------------------------------------------------
+function Laser ( Mes:in String ) return String is
+begin
+  return "";
+end Laser;
+
+function Ink_Jet ( Mes:in String ) return String is
+begin
+  return "";
+end Ink_Jet;
+
+function About ( Mes:in String ) return String is
+begin
+  return "";
+end About;
+
+with Class_Input_Manager, Class_Menu, Class_Menu_Title,
+     Laser, Ink_Jet, About;
+use  Class_Input_Manager, Class_Menu, Class_Menu_Title;
+procedure Main is
+begin
+  Window_Prologue;
+  declare
+    Menu_Bar     : Menu_Title;
+    Printer_Type : aliased Menu;
+  begin
+    Framework( Printer_Type,
+      "Laser",   null, Laser'access,
+      "Ink jet", null, Ink_Jet'access );
+    Framework( Menu_Bar,
+      "About",   null, About'access,
+      "Print",   Printer_Type'Unchecked_Access, null );
+    Window_Start;
+  end;
+  Window_Epilogue;
+end Main;
@@  x72_t1.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:53 PM BST  --
+---------------------------------------------------------------------
+with Class_Window;
+use  Class_Window;
+package Pack_Program is
+  procedure Main;
+private
+  P_Result : P_Window;
+end Pack_Program;
+
+
+with Ada.Text_Io, Ada.Float_Text_Io;
+use  Ada.Text_Io, Ada.Float_Text_Io;
+with Class_Input_Manager, Class_Window, Class_Dialog;
+use  Class_Input_Manager, Class_Window, Class_Dialog;
+package body Pack_Program is
+
+  function User_Input( Cb_Mes:in String ) return String is
+    Miles  : Float;             -- Miles input by user
+    Last   : Positive;          --
+    Str_Kms: String( 1 .. 10 ); -- As a string in Kms
+    Str_Mls: String( 1 .. 10 ); -- As a string in Miles
+  begin
+    begin
+      Get( Cb_Mes & ".", Miles, Last );
+      Put( Str_Kms, Miles * 1.609_344, Aft=>2, Exp=>0 );
+      Put( Str_Mls, Miles, Aft=>2, Exp=>0 );
+      Put( P_Result.all, "Distance in Miles = " );
+      Put( P_Result.all, Str_Mls ); New_Line( P_Result.all );
+      Put( P_Result.all, "Distance in Kms   = " );
+      Put( P_Result.all, Str_Kms ); New_Line( P_Result.all );
+    exception
+      when Data_Error =>
+        Put( P_Result.all, " Not a valid number" );
+        New_Line( P_Result.all );
+      when others =>
+        Put( P_Result.all, " [Calculation error]" );
+        New_Line( P_Result.all );
+    end;
+    return "";
+  end User_Input;
+  
+  
+  procedure Main is
+  begin
+    Window_Prologue;                -- Setup window system
+    declare
+      Result : aliased Window;      -- Result window
+      Input  : Dialog;              -- Input Window
+      Title  : Window;              -- title Window
+    begin
+      Framework( Title,  20,  1,  36, 5 );   -- Title Window
+      Framework( Result, 30, 10,  36, 5 );   -- Result Window
+  
+      Position( Title, 8, 2 );
+      Put( Title, "Miles to kilometres" );
+      Framework( Input, 5, 10, 22,            -- Input Window
+                  "Miles", User_Input'access );
+      P_Result := Result'Unchecked_Access;
+  
+      Window_Start;             -- Start the user interaction
+    end;
+    Window_Epilogue;            -- Close window system
+  end Main;
+
+end Pack_Program;
+
+with Pack_Program;
+procedure Main is
+begin
+  Pack_Program.Main;
+end Main;
@@  x72_t3.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:54 PM BST  --
+---------------------------------------------------------------------
+package Class_Board is
+
+  type Board      is private;
+  type Game_State is ( Win, Playable, Draw );
+
+  procedure Add( The:in out Board; Pos:in Integer;
+                 Piece:in Character );
+  function  Valid( The:in Board; Pos:in Integer ) return Boolean;
+  function  State( The:in Board ) return Game_State;
+  function  Cell( The:in Board; Pos:in Integer ) return Character;
+  procedure Reset( The:in out Board );
+
+private
+  subtype Board_Index is Integer range 1 .. 9;
+  type    Board_Array is array( Board_Index ) of Character;
+  type Board is record
+    Sqrs  : Board_Array := ( others => ' ');   -- Initialize
+    Moves : Natural     := 0;
+  end record;
+end Class_Board;
+
+package body Class_Board is
+
+  procedure Add( The:in out Board; Pos:in Integer;
+                 Piece:in Character ) is
+  begin
+    The.Sqrs( Pos ) := Piece;
+  end Add;
+
+  function Valid(The:in Board; Pos:in Integer) return Boolean is
+  begin
+    return Pos in Board_Array'Range and then The.Sqrs( Pos ) = ' ';
+  end Valid;
+
+  function  State( The:in Board ) return Game_State is
+    subtype Position   is Integer range 1 .. 9;
+    type Win_Line      is array( 1 .. 3 ) of Position;
+    type All_Win_Lines is range 1 .. 8;
+    Cells: constant array ( All_Win_Lines ) of Win_Line :=
+      ( (1,2,3), (4,5,6), (7,8,9), (1,4,7),
+        (2,5,8), (3,6,9), (1,5,9), (3,5,7) ); -- All win lines
+    First : Character;
+  begin
+    for Pwl in All_Win_Lines loop         -- All Pos Win Lines
+      First := The.Sqrs( Cells(Pwl)(1) ); -- First cell in line
+      if First /= ' ' then                --  Looks promising
+        if First = The.Sqrs(Cells(Pwl)(2)) and then
+            First = The.Sqrs(Cells(Pwl)(3)) then return Win;
+        end if;
+      end if;
+    end loop;
+    if The.Moves >= 9 then                -- Check for draw
+      return Draw;                        --  Board full
+    else
+      return Playable;                    --  Still playable
+    end if;
+  end State;
+
+  function Cell( The:in Board; Pos:in Integer ) return Character is
+  begin
+    return The.Sqrs( Pos );
+  end Cell;
+
+  procedure Reset( The:in out Board ) is
+  begin
+    The.sqrs  := ( others => ' ');   -- All spaces
+    The.moves := 0;                  -- No of moves
+  end reset;
+
+end Class_Board;
+
+with Class_Board, Class_Window;
+use  Class_Board, Class_Window;
+package Pack_Program is
+  procedure Play;
+private
+  Game      : Board;       -- The board
+  P_Win_Brd : P_Window;    -- Window to display OXO board in
+  P_Win_Bnr : P_Window;    -- Window to display Banner in
+  P_Win_R   : P_Window;    -- Window to display commentary in
+  Player    : Character;   -- Either 'X' or 'O'
+end Pack_Program;
+
+
+with Ada.Integer_Text_Io, 
+     Class_Dialog, Class_Menu, Class_Input_Manager, Class_Menu_Title;
+use  Ada.Integer_Text_Io, 
+     Class_Dialog, Class_Menu, Class_Input_Manager, Class_Menu_Title;
+package body Pack_Program is
+
+  procedure Display_Board( Win:in P_Window ) is
+  begin
+    Position( Win.all, 1, 2 );
+    Put(Win.all, " 7 | 8 | 9" ); New_Line( Win.all );
+    Put(Win.all, " ---------" ); New_Line( Win.all );
+    Put(Win.all, " 4 | 5 | 6" ); New_Line( Win.all );
+    Put(Win.all, " ---------" ); New_Line( Win.all );
+    Put(Win.all, " 1 | 2 | 3" ); New_Line( Win.all );
+  end Display_Board;
+  
+  -- Note mapping for squares
+  
+  procedure Update( Move:in Integer; Win:in P_Window ) is
+    type Co_Ordinate is ( X , Y );
+    type Cell_Pos is array ( Co_Ordinate ) of Positive;
+    type Board    is array ( 1 .. 9 ) of Cell_Pos;
+    Pos: constant Board :=    ( (2,6), (6,6), (10,6),
+                                (2,4), (6,4), (10,4),
+                                (2,2), (6,2), (10,2) );
+  begin
+    Position( Win.all, Pos(Move)(X), Pos(Move)(Y) );
+    Put( Win.all, Cell( Game, Move ) );       -- Display counter;
+  end Update;
+  
+  function User_Input( Cb_Mes:in String ) return String is
+    Move: Integer; Last: Positive;
+  begin
+    Clear( P_Win_R.all );                    -- Clear
+    Get( Cb_Mes, Move, Last );               -- to int
+    if Valid( Game, Move ) then              -- Valid
+      Add( Game, Move, Player );             -- to board
+      Update( Move, P_Win_Brd );
+      case State( Game ) is                  -- Game is
+        when Win       =>
+          Put(P_Win_R.all, " " & Player & " wins");
+        when Playable  =>
+          case Player is                     -- Next player
+            when 'X'    => Player := 'O';    --  'X' => 'O'
+            when 'O'    => Player := 'X';    --  'O' => 'X'
+            when others => null;             --
+          end case;
+          Put( P_Win_R.all, " Player " & Player );
+        when Draw      =>
+          Put( P_Win_R.all, " It's a draw ");
+      end case;
+    else
+      Put(P_Win_R.all, " " & Player & " Square invalid");
+    end if;
+    return "";
+  exception
+    when others =>
+      Put(P_Win_R.all, " " & Player & " re-enter move");
+      return "";
+  end User_Input;
+  
+  procedure Re_Start( First_Player:in Character ) is
+  begin
+    Player := First_Player;                  -- Start with
+    Reset( Game );                           -- Reset Board
+    Display_Board( P_Win_Brd );              -- Display
+    Clear( P_Win_R.all );                    -- Status info
+    Put( P_Win_R.all, " Player " & Player ); -- Player name
+  end Re_Start;
+  
+  function Reset_X( Cb_Mes:in String ) return String is
+  begin
+    Re_Start('X'); return "";
+  end Reset_X;
+  
+  function Reset_O( Cb_Mes:in String ) return String is
+  begin
+    Re_Start('O'); return "";
+  end Reset_O;
+  
+  function About( Cb_Mes:in String ) return String is
+  begin
+    Clear( P_Win_Bnr.all ); Position( P_Win_Bnr.all, 17, 1 );
+    Put( P_Win_Bnr.all, "Written in Ada 95");
+    return "";
+  end About;
+  
+  --[play.adb] Procedure
+  procedure Play is
+  begin
+    Window_Prologue;             -- Setup window system
+    declare
+      Win_Brd  : aliased Window; -- Board Window
+      Win_R    : aliased Window; -- Result Window
+      Win_Bnr  : aliased Window; -- title Window
+      Win_Usr  : aliased Dialog; -- Input Window
+      Ttt_Reset: aliased Menu;   -- Reset menu
+      Ttt_Menu : Menu_Title;     -- Title menu
+  
+  
+    begin
+      Framework( Win_Bnr,  1,  4, 52, 3 );    -- Banner
+      Framework( Win_Brd, 32,  8, 13, 9 );    -- OXO board
+      Framework( Win_R,    9, 14, 22, 3 );    -- Results
+  
+      Framework( Ttt_Reset,
+        "X start",  null,  Reset_X'access,
+        "O start",  null,  Reset_O'access  );
+  
+      Framework( Ttt_Menu,
+        "About",    null,  About'access,
+        "Reset",    Ttt_Reset'Unchecked_Access,  null );
+  
+      Position( Win_Bnr, 17, 1 );
+      Put( Win_Bnr, "Noughts and crosses" );
+  
+      Framework( Win_Usr,  9, 8, 22,
+                 "Move (1-9)", User_Input'access );
+  
+      Player := 'X';                          -- Set player
+      P_Win_Brd := Win_Brd'Unchecked_Access;  -- OXO Board
+      P_Win_Bnr := Win_Bnr'Unchecked_Access;  -- Banner
+      P_Win_R   := Win_R'Unchecked_Access;    -- Commentary
+  
+      Display_Board( P_Win_Brd );             -- Empty board
+      New_Line( Win_R );                      -- Clear
+      Put( Win_R, " Player " & Player );      -- Players turn is
+  
+      Put( Win_Usr, "" );       -- Cursor
+      Window_Start;             -- Start the user interaction
+    end;
+    Window_Epilogue;            -- Close window system
+  end Play;
+
+end Pack_Program;
+
+
+with Pack_Program;
+procedure Main is
+begin
+  Pack_program.Play;
+end Main;
@@  x72_tui.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:54 PM BST  --
+---------------------------------------------------------------------
+-- The TUI
+--   To compile using the GNAT Compiler on Linux, Windows 95/NT
+--
+--   gnatchop /w x72_tui.ada         // Split into units
+--   gcc /c io.c                     // Compile C interface
+--   gnatmake main.adb /largs io.o   // Compile program
+--
+-- Notes:
+--   The file io.c is the commented out C code before Raw_io.adb
+--   The current I/O system with Windows 95 can not cope with 
+--     the fast reception of characters
+--   ^C Will Kill the program use ^E to exit
+--   ^D Will cause the program to terminate do not use
+
+package Pack_Constants is
+  Vdt_Max_X    : constant := 79;      -- Columns on VDT
+  Vdt_Max_Y    : constant := 25;      -- Lines on VDT
+  Window_Max_X : constant := 79;      -- MAX columns window
+  Window_Max_Y : constant := 25;      -- MAX lines window
+
+  C_Cursor     : constant Character := '*';
+  C_Blank      : constant Character := ' ';
+  C_Win_A      : constant Character := '#';
+  C_Win_Pas    : constant Character := '+';
+  C_Exit       : constant Character := Character'Val(05); --^E
+  C_Where      : constant Character := Character'Val(255);
+  C_Action     : constant Character := Character'Val(13); --cr
+  C_Switch     : constant Character := Character'Val(09); --ht
+  C_Menu       : constant Character := Character'Val(01); --^A
+  C_Del        : constant Character := Character'Val(08); --^B
+  C_No_Char    : constant Character := Character'Val(00);
+
+  C_Left       : constant Character := Character'Val(12); --^L
+  C_Right      : constant Character := Character'Val(18); --^R
+  C_Up         : constant Character := Character'Val(21); --^U
+  C_Down       : constant Character := Character'Val(04); --^D
+end Pack_Constants;
+
+-- All I/O is RAW
+--     Write :chs are immediately written to the terminal
+--     Read  :chs are immediately available to the program
+--           Unfortunately input characters are echoed using
+--           get_immediate in Ada.Text_IO
+
+package Raw_Io is
+  procedure Get_Immediate( Ch:out Character );
+  procedure Put( Ch:in Character );
+  procedure Put( Str:in String );
+end Raw_Io;
+
+-- BEGIN file io.c
+-- /*
+--  *   The C function to turn of echoing
+--  *
+--  *   Works with the GNAT implementation on Linux, Win95
+--  *   Note:
+--  *    Uses Unix API call to turn of echoing
+--  *   Compile: gcc /c io.c
+--  */
+--
+-- 
+-- #include <termios.h>
+-- #include <unistd.h>
+-- 
+-- void c_no_echo()
+-- {
+--   static tcflag_t c_lflag;
+--   static int fd = STDIN_FILENO;
+--   static struct termios termios_data;
+--   tcgetattr( fd, &termios_data );
+--   c_lflag = termios_data.c_lflag;
+--   termios_data.c_lflag = termios_data.c_lflag & (~ECHO);
+--   tcsetattr( fd, TCSANOW, &termios_data );
+-- }
+-- END file io.c
+
+
+-- Alternative BODY for Raw_io
+--   All the I/O is performed by code written in C
+--   Implemented in io.c
+--
+
+-- WITH Interfaces.C;
+-- USE  Interfaces.C;
+-- PACKAGE BODY raw_io IS
+-- 
+-- PROCEDURE get_immediate( ch:OUT Character ) IS
+--    FUNCTION c_get_char RETURN Char;
+--    PRAGMA import (C, c_get_char, "c_get_char");
+-- BEGIN
+--    ch := to_ada( c_get_char );
+-- END get_immediate;
+-- 
+-- PROCEDURE put( ch:IN Character ) IS
+--    PROCEDURE c_put_char( ch:IN Char );
+--    PRAGMA import (C, c_put_char, "c_put_char");
+-- BEGIN
+--    c_put_char( to_c( ch ) );
+-- END put;
+-- 
+-- PROCEDURE put( str:IN String ) IS
+--    PROCEDURE c_put_str( str:IN Char_array );
+--    PRAGMA import (C, c_put_str, "c_put_str");
+-- BEGIN
+--    c_put_str( to_c( str, append_nul=>TRUE ) );
+-- END put;
+-- 
+-- END raw_io;
+
+with Interfaces.C, Ada.Text_Io;
+use  Interfaces.C, Ada.Text_Io;
+package body Raw_Io is
+
+  First_Time : Boolean := True;
+
+  procedure Get_Immediate( Ch:out Character) is
+    procedure C_No_Echo;
+    pragma Import (C, C_No_Echo, "c_no_echo");   -- Turn off echo
+  begin
+    if First_Time then
+      C_No_Echo; First_Time := False;
+    end if;
+    Ada.Text_Io.Get_Immediate(Ch);
+    if Character'Pos(Ch) = 10 then               -- Real Return ch
+      Ch := Character'Val(13);
+    end if;
+  end Get_Immediate;
+
+  procedure Put( Ch:in Character ) is            -- Raw write
+  begin
+    Ada.Text_Io.Put( Ch ); Ada.Text_Io.Flush;
+  end Put;
+
+  procedure Put( Str:in String ) is              -- Raw write
+  begin
+    Ada.Text_Io.Put( Str ); Ada.Text_Io.Flush;
+  end Put;
+
+end Raw_Io;
+
+
+-- Machine dependent I/O
+-- Currently assume input is from a terminal supporting
+-- input of ANSI escape sequences
+
+package Pack_Md_Io is
+  procedure Put( Ch :in Character );           -- Put char
+  procedure Put( Str:in String );              -- Put string
+  procedure Get_Immediate( Ch:out Character ); -- no echo
+end Pack_Md_Io;
+
+--[pack_md_io.adb] Implementation
+with Raw_Io, Pack_Constants;
+use  Raw_Io, Pack_Constants;
+package body Pack_Md_Io is
+  procedure Put( Ch:in Character ) is
+  begin
+    Raw_Io.Put( Ch );
+  end Put;
+
+  procedure Put( Str:in String ) is
+  begin
+    Raw_Io.Put( Str );
+  end Put;
+
+  procedure Get_Immediate( Ch:out Character) is
+    Esc: constant Character := Character'Val(27);
+  begin
+    Raw_Io.Get_Immediate( Ch );
+    if Ch = Esc then                         -- ESC 
+      Raw_Io.Get_Immediate( Ch );            -- [
+      if Ch = '[' then
+        Raw_Io.Get_Immediate( Ch );
+        case Ch is
+          when 'A'    => Ch := C_Up;         -- A - Up arrow
+          when 'B'    => Ch := C_Down;       -- B - Down arrow
+          when 'C'    => Ch := C_Right;      -- C - Right arrow
+          when 'D'    => Ch := C_Left;       -- D - Left arrow
+          when others => Ch := '?';          -- ? - Unknown
+        end case;
+      end if;
+    end if;
+  end Get_Immediate;
+
+end Pack_Md_Io;
+
+
+package Class_Screen is
+  procedure Put( Ch :in Character );       -- Put char
+  procedure Put( Str:in String );          -- Put string
+  procedure Clear_Screen;                  -- Clear screen
+  procedure Position_Cursor(Col:in Positive; Row:in Positive);
+private
+end Class_Screen;
+
+--[pack_ansi_display.adb] Implementation
+with Pack_Md_Io; use  Pack_Md_Io;
+package body Class_Screen is
+  Prefix: constant String := Character'Val(27) & "[";
+  procedure Put( N:in Positive );          -- Write decimal number
+
+  procedure Put( Ch :in Character ) is
+  begin
+    Pack_Md_Io.Put( Ch );
+  end Put;
+
+  procedure Put( Str:in String ) is
+  begin
+    Pack_Md_Io.Put( Str );
+  end Put;
+
+  procedure Clear_Screen is                 -- Clear screen
+  begin
+    Put( Prefix & "2J");
+  end Clear_Screen;
+
+  procedure Position_Cursor(Col:in Positive; Row:in Positive) is
+  begin
+    Put( Prefix ); Put(Row); Put(";"); Put(Col); Put("H");
+  end Position_Cursor;
+
+  procedure Put( N:in Positive ) is   -- Write decimal number
+  begin
+    if N >= 10 then Put( N / 10 ); end if;
+    Put( Character'Val(N rem 10 + Character'Pos('0') ) );
+  end Put;
+
+end Class_Screen;
+
+--=================================================================
+
+with Ada.Finalization;
+use  Ada.Finalization;
+package Class_Root_Window is
+  type Root_Window   is abstract tagged limited private;
+  type P_Root_Window is access all Root_Window'Class;
+  type Attribute is ( Top, Bottom, Left, Right, Abs_X, Abs_Y );
+
+  procedure Send_To( The:in out Root_Window;
+    Ch:in Character) is abstract;
+  procedure Switch_To( The:in out Root_Window ) is abstract;
+  procedure Switch_Away( The:in out Root_Window ) is abstract;
+  function  About( The:in Root_Window;
+    B:in Attribute) return Natural is abstract;
+private
+  type Root_Window is
+    abstract new Limited_Controlled with null record;
+
+end Class_Root_Window;
+
+
+--===========================================================
+
+with Ada.Finalization;
+use  Ada.Finalization;
+package Class_Input_Manager is
+  type Input_Manager is abstract tagged limited private;
+  procedure Window_Prologue;       -- Initialize window system
+  procedure Window_Start;          -- Start taking user input
+  procedure Window_Epilogue;       -- Clean up
+private
+  type Input_Manager is
+    abstract new Limited_Controlled with null record;
+end Class_Input_Manager;
+
+with Ada.Finalization, Class_Root_Window;
+use  Ada.Finalization, Class_Root_Window;
+package Class_Window_Control is
+
+  type Window_Control is abstract tagged limited private;
+  procedure Add_To_List(P_W:in P_Root_Window; Ch:in Character);
+  procedure Remove_From_List( P_W:in P_Root_Window );
+  procedure Top( P_W:in P_Root_Window );
+  procedure Find( P_W:out P_Root_Window; Ch:in Character );
+
+  procedure Send_To_Top( Ch:in Character );
+  procedure Switch_To_Top;
+  procedure Switch_Away_From_Top;
+
+  procedure Write_To( P_W:in P_Root_Window;
+    X,Y:in Positive; Mes:in String );
+  procedure Hide_Win( P_W:in P_Root_Window );
+  procedure Window_Fatal( Mes:in String );
+private
+  type Window_Control is
+    abstract new Limited_Controlled with null record;
+  Max_Items : constant := 10;
+  type Active_Window is record           -- Active window
+    P_W : P_Root_Window;                 -- Window
+    A_Ch: Character;                     -- Activate character
+  end record;
+
+  subtype Window_Index is Natural      range 0 .. Max_Items;
+  subtype Window_Range is Window_Index range 1 .. Max_Items;
+  type    Window_Array is array (Window_Range) of Active_Window;
+
+  The_Last_Win: Window_Index := 0;       -- Last active window
+  The_Windows : Window_Array;            -- All windows
+end Class_Window_Control;
+
+--===========================================================
+
+with Pack_Constants, Pack_Md_Io, Class_Screen,
+  Class_Window_Control, Class_Root_Window;
+use  Pack_Constants, Pack_Md_Io, Class_Screen,
+  Class_Window_Control, Class_Root_Window;
+package body Class_Input_Manager is
+
+  procedure Window_Prologue is
+  begin
+    Clear_Screen;
+  end Window_Prologue;
+
+  procedure Window_Start is
+    P_W : P_Root_Window;                   -- A window
+    Ch  : Character;                       -- Current Char
+  begin
+    loop
+      Get_Immediate( Ch );                 -- From Keyboard
+      exit when Ch = C_Exit;
+      Find( P_W, Ch );                     -- Active window
+      if P_W /= null then                  -- Window activation
+        Switch_Away_From_Top;              --  No longer active
+        Top( P_W );                        --  Make p_w top
+        Switch_To_Top;                     --  & make active
+        Send_To_Top( C_Where );            -- In selected window
+      else                                 --
+        Send_To_Top( Ch );                 -- Give to top window
+      end if;
+    end loop;
+    Pack_Md_Io.Put( Character'Val(0) );    -- Capture output
+  end Window_Start;
+
+  procedure Window_Epilogue is
+  begin
+    null;
+  end Window_Epilogue;
+
+end Class_Input_Manager;
+
+--=================================================================
+
+with Class_Screen;
+use  Class_Screen;
+package body Class_Window_Control is
+
+  procedure Add_To_List(P_W:in P_Root_Window; Ch:in Character) is
+  begin
+    if The_Last_Win < Max_Items then
+      The_Last_Win := The_Last_Win + 1;
+      The_Windows( The_Last_Win ) := ( P_W, Ch );
+    else
+      Window_Fatal("Cannot register window");
+    end if;
+  end Add_To_List;
+
+  procedure Remove_From_List( P_W:in P_Root_Window ) is
+  begin
+    for I in 1 .. The_Last_Win loop                 -- Look at
+      if The_Windows( I ).P_W = P_W then            -- Found
+        for J in I .. The_Last_Win-1 loop           -- Delete
+          The_Windows( J ) := The_Windows( J+1 );   --  move up
+        end loop;
+        The_Last_Win := The_Last_Win - 1; exit;     -- Finish
+      end if;
+    end loop;
+  end Remove_From_List;
+
+  procedure Top( P_W:in P_Root_Window ) is
+  begin
+    for I in 1 .. The_Last_Win loop               --
+      if The_Windows( I ).P_W = P_W then          -- Found
+        declare
+          Tmp : Active_Window := The_Windows( I );
+        begin
+          for J in I .. The_Last_Win-1 loop       -- Move down
+            The_Windows( J ) := The_Windows( J+1 );
+          end loop;
+          The_Windows( The_Last_Win ) := Tmp;     -- New top
+        end;
+        exit;
+      end if;
+    end loop;
+  end Top;
+
+  procedure Find( P_W:out P_Root_Window; Ch:in Character ) is
+  begin
+    P_W := null;
+    for I in 1 .. The_Last_Win loop
+      if The_Windows( I ).A_Ch = Ch then
+        P_W := The_Windows( I ).P_W;
+        exit;
+      end if;
+    end loop;
+  end Find;
+
+  procedure Send_To_Top( Ch:in Character ) is
+  begin
+    if The_Last_Win >= 1 then
+      Send_To( The_Windows(The_Last_Win).P_W.all, Ch );
+    end if;
+  end Send_To_Top;
+
+  procedure Switch_To_Top is
+  begin
+    if The_Last_Win >= 1 then
+      Switch_To( The_Windows(The_Last_Win).P_W.all );
+    end if;
+  end Switch_To_Top;
+
+  procedure Switch_Away_From_Top is
+  begin
+    if The_Last_Win >= 1 then
+      Switch_Away( The_Windows(The_Last_Win).P_W.all );
+    end if;
+  end Switch_Away_From_Top;
+
+  -- Of course this allow overlapping wondows
+
+  procedure Write_To( P_W:in P_Root_Window;
+      X,Y:in Positive; Mes:in String ) is
+    Abs_X_Crd : Positive := About( P_W.all, Abs_X );
+    Abs_Y_Crd : Positive := About( P_W.all, Abs_Y );
+  begin
+    Position_Cursor( Abs_X_Crd+X-1, Abs_Y_Crd+Y-1 );
+    Class_Screen.Put( Mes );
+  end Write_To;
+
+  -- Of course this allow overlapping wondows
+
+  procedure Hide_Win( P_W:in P_Root_Window ) is
+    Abs_X_Crd : Positive := About( P_W.all, Abs_X );
+    Abs_Y_Crd : Positive := About( P_W.all, Abs_Y );
+    Width     : Positive := About( P_W.all, Top );
+    Height    : Positive := About( P_W.all, Left );
+    Spaces    : String( 1 .. Width ) := ( others => ' ' );
+  begin
+    for H in 1 .. Height loop
+      Position_Cursor( Abs_X_Crd, Abs_Y_Crd+H-1 );
+      Class_Screen.Put( Spaces );
+    end loop;
+  end Hide_Win;
+
+  procedure Window_Fatal( Mes:in String ) is
+  begin
+    Position_Cursor( 1, 1 );
+    Put( "Window fatal error: "& Mes );
+  end Window_Fatal;
+
+end Class_Window_Control;
+
+--===========================================================
+
+with Pack_Constants, Class_Root_Window, Class_Window_Control;
+use  Pack_Constants, Class_Root_Window, Class_Window_Control;
+package Class_Window is
+  type Window   is new Root_Window with private;
+  type P_Window is access all Window;
+
+  type Mode    is ( Visible, Invisible );
+  type P_Cbf   is access function(Str:in String) return String;
+
+  procedure Initialize( The:in out Window );
+  procedure Finalize( The:in out Window );
+
+  -- Basic construction
+
+  procedure Framework( The:in out Window;
+                       Abs_X_Crd, Abs_Y_Crd: Positive;
+                       Max_X_Crd, Max_Y_Crd: Positive;
+                       Cb:in P_Cbf := null );
+  procedure Create   ( The:in out Window;
+                       Abs_X_Crd, Abs_Y_Crd: Positive;
+                       Max_X_Crd, Max_Y_Crd: Positive );
+
+  -- Call back function processing
+
+  procedure Set_Call_Back( The:in out Window; Cb:in P_Cbf );
+  function Call_Call_Back( The:in Window;
+                           Str:in String ) return String;
+
+  -- I/O to a window
+
+  procedure Put( The:in out Window; Mes:in String );
+  procedure Put( The:in out Window; Ch:in Character );
+  procedure Put( The:in out Window; N:in Integer );
+
+  procedure Position( The:in out Window; X,Y:in Positive );
+  procedure Clear( The:in out Window );
+  procedure New_Line( The:in out Window );
+  procedure Refresh( The:in out Window );
+
+  -- Look and Feel
+
+  procedure Make_Window( The:in out Window; Mo:in Mode );
+  procedure Mark_Border( The:in out Window;
+                         A_Border:in Attribute;
+                         Pos:in Positive; Ch:in Character );
+  function About(The:in Window; B:in Attribute) return Natural;
+
+  -- When window selected do
+
+  procedure Switch_Away( The:in out Window );
+  procedure Switch_To( The:in out Window );
+  procedure Send_To( The:in out Window; Ch:in Character );
+
+  -- Register window with poling system
+
+  procedure Register( P_W:in P_Root_Window; Ch:in Character );
+  procedure De_Register( P_W:in P_Root_Window );
+private
+  subtype Y_Cord is Positive range 1 .. Vdt_Max_Y;
+  subtype X_Cord is Positive range 1 .. Vdt_Max_X;
+
+  subtype Line_Index  is X_Cord range 1 .. Window_Max_X;
+  subtype Line_Range  is Line_Index;
+  subtype Line        is String( Line_Range );
+
+  subtype Pane_Index  is Y_Cord range 1 .. Window_Max_Y;
+  subtype Pane_Range  is Pane_Index;
+  type    Pane_Array  is array ( Pane_Range ) of Line;
+
+  type Window is new Root_Window with record
+    Abs_X    : X_Cord := 1;    -- The position on the vdt
+    Abs_Y    : Y_Cord := 1;    -- The position on the vdt
+    C_X      : X_Cord := 1;    -- Current position in window
+    C_Y      : Y_Cord := 1;    -- Current position in window
+    Max_X    : X_Cord := 5;    -- X size of window (+Border)
+    Max_Y    : Y_Cord := 5;    -- Y size of window (+Border)
+    Pane     : Pane_Array;     -- Copy of window in memory
+    Mode_Of  : Mode := Invisible;-- Invisible window by default
+    Call_Back: P_Cbf := null;  -- Call back function
+  end record;
+end Class_Window;
+
+--[class_window.adb] Implementation
+package body Class_Window is
+
+  procedure Put( The:in out Window;
+    X,Y:in Positive; Mes:in String );
+
+  procedure Initialize( The:in out Window ) is
+  begin
+    null;
+  end Initialize;
+
+  procedure Finalize( The:in out Window ) is
+  begin
+    Make_Window( The, Invisible );
+    De_Register( The'Unchecked_Access );
+  end Finalize;
+
+  procedure Create( The:in out Window;
+      Abs_X_Crd, Abs_Y_Crd: Positive;
+      Max_X_Crd, Max_Y_Crd: Positive ) is
+  begin
+    if Max_X_Crd < 3 or else Max_X_Crd > Window_Max_X or else
+        Max_Y_Crd < 3 or else Max_Y_Crd > Window_Max_Y or else
+        Abs_X_Crd + Max_X_Crd - 1 > Vdt_Max_X or else
+        Abs_Y_Crd + Max_Y_Crd - 1 > Vdt_Max_Y then
+      Window_Fatal("Creation window parameter error");
+    end if;
+    declare
+      Top_Bottom: String(1..Max_X_Crd)     := (others => '-');
+      Spaces    : String(2 .. Max_X_Crd-1) := (others => ' ');
+    begin
+      Top_Bottom(1) := '+'; Top_Bottom(Max_X_Crd) := '+';
+      The.Max_X := Max_X_Crd - 2;        -- For border
+      The.Max_Y := Max_Y_Crd - 2;        -- For border
+      The.Abs_Y := Abs_Y_Crd;            -- Abs position screen
+      The.Abs_X := Abs_X_Crd;            --
+      The.Pane(1)(1..Max_X_Crd) := Top_Bottom;  -- Clear / set up
+      for Y in 2 .. Max_Y_Crd-1 loop
+        The.Pane(Y)(1..Max_X_Crd):= '|'&Spaces&'|';
+      end loop;
+      The.Pane(Max_Y_Crd)(1..Max_X_Crd) := Top_Bottom;
+      Position( The, 1, 1 );             -- Top left hand corner
+    end;
+  end Create;
+
+  -- The window co-ordinates of 1 .. n , 1 .. m are
+  --  stored into an array in position 2 .. n+1, 2 .. m+1
+  --  this allows the border to be stored
+
+  procedure Framework( The:in out Window;
+      Abs_X_Crd, Abs_Y_Crd: Positive;
+      Max_X_Crd, Max_Y_Crd: Positive;
+      Cb:in P_Cbf := null ) is
+  begin
+    Create( The, Abs_X_Crd, Abs_Y_Crd, Max_X_Crd, Max_Y_Crd );
+    Make_Window( The, Visible );
+    if Cb /= null then
+      Set_Call_Back( The, Cb );
+      Register( The'Unchecked_Access, C_Switch );
+    else
+      Register( The'Unchecked_Access, C_No_Char );
+    end if;
+  end Framework;
+
+  procedure Set_Call_Back( The:in out Window; Cb:in P_Cbf ) is
+  begin
+    The.Call_Back := Cb;
+  end Set_Call_Back;
+
+  function Call_Call_Back( The:in Window;
+      Str:in String ) return String is
+  begin
+    if The.Call_Back /= null then
+      return The.Call_Back(Str);
+    end if;
+    return "No call back function";
+  end;
+
+  procedure Put( The:in out Window; Mes:in String ) is
+    Add : Natural;
+  begin
+    Add := Mes'Length;                   -- Length
+    if Add + The.C_X > The.Max_X then    -- Actual characters
+      Add := The.Max_X - The.C_X + 1;    --  to add
+    end if;
+    if Add >= 1 then                     -- There are some
+      The.Pane(The.C_Y+1)(The.C_X+1 .. The.C_X+Add)
+        := Mes( 1 .. Add );
+      if The.Mode_Of = Visible then      -- Add to screen
+        Put(The, The.C_X+1, The.C_Y+1, Mes( 1 .. Add) );
+      end if;
+      The.C_X := The.C_X + Add;
+    else
+      Put(The, The.C_X+1, The.C_Y+1, "" );
+    end if;
+  end Put;
+
+  procedure Put( The:in out Window; Ch:in Character ) is
+  begin
+    Put( The, "" & Ch );           -- Convert to string
+  end Put;
+
+  procedure Put( The:in out Window; N:in Integer ) is
+  begin
+    Put( The, Integer'Image(N) );  -- Convert to string
+  end Put;
+
+  procedure Position( The:in out Window; X,Y:in Positive ) is
+  begin
+    if X <= The.Max_X and Y <= The.Max_Y then
+      The.C_X := X; The.C_Y := Y;
+    end if;
+  end Position;
+
+  procedure Clear( The:in out Window ) is
+    Empty : String( 1 .. The.Max_X ) := (others => ' ');
+  begin
+    Position(The, 1, 1);            -- Top right hand corner
+    for Y in 1 .. The.Max_Y loop    -- Clear text
+      Put( The, Empty ); New_Line(The);
+    end loop;
+  end Clear;
+
+  procedure New_Line( The:in out Window ) is
+  begin
+    if The.C_Y >= The.Max_Y then         -- Scroll text
+      for Y in 2 .. The.Max_Y loop       --  Copy up
+        The.Pane(Y) := The.Pane(Y+1);
+      end loop;
+      The.Pane(The.Max_Y+1)(2..The.Max_X+1):= (others=>' ');
+      Refresh(The);                      --  refresh
+    else
+      The.C_Y := The.C_Y + 1;            -- Next line
+    end if;
+    The.C_X := 1;                        -- At start
+  end New_Line;
+
+  procedure Refresh( The:in out Window ) is
+  begin
+    if The.Mode_Of = Visible then             -- Visible
+      for Y in 1 .. The.Max_Y+2 loop          -- Text
+        Put( The, 1, Y,
+          The.Pane(Y)(1 .. The.Max_X+2) ); -- include border
+      end loop;
+      Put( The, "" );                         -- Cursor
+    end if;
+  end Refresh;
+
+  procedure Make_Window( The:in out Window; Mo:in Mode ) is
+  begin
+    if The.Mode_Of /= Mo then              -- Change so
+      The.Mode_Of := Mo;                   -- Set new mode_of
+      case Mo is
+        when Invisible =>                  -- Clear from screen
+          Hide_Win( The'Unchecked_Access );-- Hide window
+        when Visible =>                    -- Redraw on screen
+          Refresh( The );
+      end case;
+    end if;
+  end Make_Window;
+
+  procedure Mark_Border( The:in out Window;
+      A_Border:in Attribute;
+      Pos:in Positive; Ch:in Character ) is
+    A_Y, A_X : Positive;
+  begin
+    case A_Border is
+      when Top    => A_X := Pos; A_Y := 1;
+      when Bottom => A_X := Pos; A_Y := The.Max_Y+2;
+      when Left   => A_X := 1; A_Y := Pos;
+      when Right  => A_X := The.Max_X+2; A_Y := Pos;
+      when others => null;
+    end case;
+    if A_X <= The.Max_X+2 and then A_Y <= The.Max_Y+2 then
+      The.Pane(A_Y)(A_X) := Ch;       -- Store
+      if The.Mode_Of = Visible then   -- Update on screen
+        Put( The, A_X, A_Y, Ch & "" );
+        Put( The, "" );
+      end if;
+    end if;
+  end Mark_Border;
+
+  function About(The:in Window; B:in Attribute) return Natural is
+  begin
+    case B is
+      when Top  | Bottom => return The.Max_X+2;
+      when Left | Right  => return The.Max_Y+2;
+      when Abs_X         => return The.Abs_X;
+      when Abs_Y         => return The.Abs_Y;
+      when others        => return 0;
+    end case;
+  end;
+
+  procedure Switch_Away( The:in out Window ) is
+  begin
+    Mark_Border( The, Top, 1, C_Win_Pas );
+  end Switch_Away;
+
+  procedure Switch_To( The:in out Window ) is
+  begin
+    Mark_Border( The, Top, 1, C_Win_A );
+  end Switch_To;
+
+  procedure Send_To( The:in out Window; Ch:in Character ) is
+  begin
+    null;
+  end Send_To;
+
+  procedure Register( P_W:in P_Root_Window;
+      Ch:in Character ) is
+  begin
+    Switch_Away_From_Top;           -- Register window focus
+    Add_To_List( P_W, Ch );         -- Register window
+    Switch_To_Top;                  -- Make focus
+  end Register;
+
+  procedure De_Register( P_W:in P_Root_Window ) is
+  begin
+    Top( P_W );                     -- Make top
+    Switch_Away_From_Top;           --  prepare for demise
+    Remove_From_List( P_W );        -- De register window
+    Switch_To_Top;                  -- Make focus
+  end De_Register;
+
+  -- Write to Physical Screen
+
+  procedure Put( The:in out Window;
+      X,Y:in Positive; Mes:in String ) is
+  begin
+    Write_To( The'Unchecked_Access, X, Y, Mes );
+  end Put;
+
+end Class_Window;
+
+
+--==================================================================
+
+with Pack_Constants, Class_Root_Window, Class_Window;
+use  Pack_Constants, Class_Root_Window, Class_Window;
+package Class_Dialog is
+  type Dialog is new Window with private;
+
+  procedure Framework ( The:in out Dialog;
+    Abs_X, Abs_Y:in Positive;
+    Max_X: in Positive;
+    Name:in String; Cb:in P_Cbf );
+
+  procedure Send_To( The:in out Dialog; Ch:in Character );
+private
+  subtype Message is String( 1 ..  Window_Max_X );
+  type Dialog is new Window with record
+    Dialog_Pos: Positive := 1;  -- Position in input message
+    Dialog_Len: Positive := 1;  -- Length of dialogue message
+    Dialog_Mes: Message := ( others => ' '); -- Input message
+  end record;
+end Class_Dialog;
+
+package body Class_Dialog is
+
+  procedure Framework( The:in out Dialog;
+      Abs_X, Abs_Y:in Positive;
+      Max_X:in Positive;
+      Name:in String; Cb:in P_Cbf ) is
+    Dashes : String( 1 .. Max_X ) := (others=>'-');
+  begin
+    Create( The, Abs_X, Abs_Y, Max_X, 5 );
+    The.Dialog_Len := Max_X-2;                  -- User input
+    The.Dialog_Pos := 1;                        -- In Dialog
+    Set_Call_Back( The, Cb );                   -- Call back fun
+    Put( The, "Dialog| " ); Put( The, Name );   -- Dialog title
+    Position( The, 1, 2 ); Put( The, Dashes );  -- Line
+    Position( The, 1, 3 ); Put( The, C_Cursor );-- Cursor
+    Make_Window( The, Visible );
+    Register( The'Unchecked_Access, C_Switch ); -- Activation Chr
+  end Framework;
+
+  procedure Send_To( The:in out Dialog; Ch:in Character ) is
+    Spaces : String(1 .. About(Window(The),Top)) := (others => ' ');
+    Res    : String(1..0);
+  begin
+    case Ch is
+      when C_Where =>
+        Put( The, "" );
+      when C_Action =>
+        Res := Call_Call_Back( The,
+          The.Dialog_Mes(1..The.Dialog_Pos-1) )(1..0);
+        The.Dialog_Pos := 1;
+        The.Dialog_Mes := ( others => ' ' );
+        Position( The, 1, 3 );                   -- Start
+        Put( The, C_Cursor & Spaces );           -- Clear
+        Position( The, 2, 3 );                   -- Cursor
+        Put( The, "" );                          -- Cursor
+      when C_Del =>
+        if The.Dialog_Pos > 1 then               -- Can delete
+          The.Dialog_Pos := The.Dialog_Pos - 1;  -- Make avail.
+          The.Dialog_Mes(The.Dialog_Pos):= ' ';  -- Remove
+          Position( The, The.Dialog_Pos, 3 );
+          Put( The, C_Cursor & " " );            -- Overwrite
+          Position( The, The.Dialog_Pos, 3 );
+          Put( The, "" );                        -- Cursor
+        end if;
+      when others =>
+        if The.Dialog_Pos <= The.Dialog_Len then
+          if Ch in ' ' .. '~' then               -- Add to
+            The.Dialog_Mes( The.Dialog_Pos ) := Ch; -- Save ch
+            Position( The, The.Dialog_Pos, 3 );
+            Put( The, The.Dialog_Mes(The.Dialog_Pos) );
+            Put( The, C_Cursor );
+            The.Dialog_Pos := The.Dialog_Pos + 1;
+          end if;
+        end if;
+    end case;
+  end Send_To;
+end Class_Dialog;
+
+--==================================================================
+
+with Class_Root_Window, Class_Window;
+use  Class_Root_Window, Class_Window;
+package Class_Menu is
+  type Menu is new Window with private;
+  type P_Menu is access all Menu;
+
+  procedure Framework( The:in out Menu'Class;
+    M1:in String:=""; W1:in P_Menu:=null; Cb1:in P_Cbf:=null;
+    M2:in String:=""; W2:in P_Menu:=null; Cb2:in P_Cbf:=null;
+    M3:in String:=""; W3:in P_Menu:=null; Cb3:in P_Cbf:=null;
+    M4:in String:=""; W4:in P_Menu:=null; Cb4:in P_Cbf:=null;
+    M5:in String:=""; W5:in P_Menu:=null; Cb5:in P_Cbf:=null;
+    M6:in String:=""; W6:in P_Menu:=null; Cb6:in P_Cbf:=null );
+
+  procedure Set_Up( The:in out Menu; Active:in Positive);
+  procedure Menu_Spot( The:in out Menu; Ch:in Character );
+  procedure Send_To( The:in out Menu; Ch:in Character );
+
+  Max_Menu : constant Positive := 10;
+  subtype Menu_Item is String( 1 .. Max_Menu );
+
+  procedure Get_Menu_Name( The:in Menu; I:in Positive;
+    N:out Menu_Item );
+  procedure Get_Cur_Selected_Details( The:in P_Menu;
+    W:out P_Menu; Cb:out P_Cbf );
+private
+  type    Direction is (D_Reverse, D_Forward);
+  procedure Next( The:in out Menu; Dir:in Direction );
+
+  type Menu_Desc is record  -- A menu is:
+    Name: Menu_Item;        -- Name of menu item
+    P_M : P_Menu;           -- Menu window
+    Fun : P_Cbf;            -- Call back function
+  end record;
+
+  Max_Menu_Items : constant := 6;    -- Maximum menu items
+
+  type    Menus_Index is range 0 .. Max_Menu_Items;
+  subtype Menus_Range is Menus_Index range 1 .. Max_Menu_Items;
+  type    Menus       is array ( Menus_Range ) of Menu_Desc;
+
+  type Menu is new Window with record
+    Number   : Menus_Index := 0;   -- Number of menu items
+    Cur_Men  : Menus_Index := 1;   -- Currently selected item
+    Menu_Set : Menus;              -- Components of a menu
+  end record;
+end Class_Menu;
+
+with Pack_Constants;
+use  Pack_Constants;
+package body Class_Menu is
+
+  -- The type is Menu'Class so a run time dispatch will
+  -- take place when set_up is called
+
+  procedure Framework( The:in out Menu'Class;
+      M1:in String:=""; W1:in P_Menu:=null; Cb1:in P_Cbf:=null;
+      M2:in String:=""; W2:in P_Menu:=null; Cb2:in P_Cbf:=null;
+      M3:in String:=""; W3:in P_Menu:=null; Cb3:in P_Cbf:=null;
+      M4:in String:=""; W4:in P_Menu:=null; Cb4:in P_Cbf:=null;
+      M5:in String:=""; W5:in P_Menu:=null; Cb5:in P_Cbf:=null;
+      M6:in String:=""; W6:in P_Menu:=null; Cb6:in P_Cbf:=null
+                                                               ) is
+    Spaces : Menu_Item := ( others => ' ' );
+    Active : Menus_Index := 1;
+    procedure Set_Up( Mi:in String; Wi:in P_Menu;
+                      Cb:in P_Cbf; N:in Menus_Index ) is
+    begin
+      if Mi /= "" then Active := N; end if;   -- A menu item
+      The.Menu_Set( N ) :=
+        (" "&Mi&Spaces(1 .. Max_Menu-1-Mi'Length), Wi, Cb);
+    end Set_Up;
+  begin
+    Set_Up( M1, W1, Cb1, 1 ); Set_Up( M2, W2, Cb2, 2 );
+    Set_Up( M3, W3, Cb3, 3 ); Set_Up( M4, W4, Cb4, 4 );
+    Set_Up( M5, W5, Cb5, 5 ); Set_Up( M6, W6, Cb6, 6 );
+    The.Number := Active;
+    Set_Up( The, Positive(Active) );
+  end Framework;
+
+  procedure Set_Up( The:in out Menu;
+                    Active:in Positive ) is
+    Me: Menu_Item;
+  begin
+    Create( The, 1, 1, (1+Max_Menu)*Active+1, 3 );
+    for I in 1 .. Active loop            -- Display menu names
+      Get_Menu_Name( The, I, Me );
+      Put( The, Me ); Put( The, "|" );
+      null;
+    end loop;
+    Menu_Spot( The, C_Cursor );          -- Mark current
+  end Set_Up;
+
+  procedure Menu_Spot( The:in out Menu; Ch:in Character ) is
+  begin
+    Position( The, (Max_Menu+1)*(Positive(The.Cur_Men)-1)+1, 1 );
+    Put( The, Ch );
+  end Menu_Spot;
+
+  procedure Send_To( The:in out Menu; Ch:in Character ) is
+  begin
+    Menu_Spot( The, C_Blank );
+    case Ch is
+      when C_Right => Next( The, D_Forward );
+      when C_Left  => Next( The, D_Reverse );
+      when others  => null;
+    end case;
+    Menu_Spot( The, C_Cursor );
+  end Send_To;
+
+  procedure Next( The:in out Menu; Dir:in Direction ) is
+  begin
+    case Dir is
+      when D_Forward =>
+        The.Cur_Men := The.Cur_Men rem The.Number + 1;
+      when D_Reverse =>
+        if The.Cur_Men = 1
+            then The.Cur_Men := The.Number;
+        else The.Cur_Men := The.Cur_Men-1;
+        end if;
+    end case;
+  end Next;
+
+  procedure Get_Menu_Name( The:in Menu; I:in Positive;
+                           N:out Menu_Item ) is
+  begin
+    N  := The.Menu_Set( Menus_Index(I) ).Name;
+  end Get_Menu_Name;
+
+  procedure Get_Cur_Selected_Details( The:in P_Menu;
+      W:out P_Menu; Cb:out P_Cbf ) is
+  begin
+    W  := The.Menu_Set( The.Cur_Men ).P_M;
+    Cb := The.Menu_Set( The.Cur_Men ).Fun;
+  end Get_Cur_Selected_Details;
+
+end Class_Menu;
+
+--==================================================================
+
+with Class_Root_Window, Class_Window, Class_Menu;
+use  Class_Root_Window, Class_Window, Class_Menu;
+package Class_Menu_Title is
+  type Menu_Title is new Menu with private;
+  type P_Menu_Title is access all Menu_Title;
+
+  procedure Set_Up( The:in out Menu_Title; Active:in Positive );
+  procedure Send_To( The:in out Menu_Title; Ch:in Character );
+  procedure Switch_Away( The:in out Menu_Title );
+private
+
+  Max_Act_Menu : constant := 6;    -- Maximum depth of menus
+  type    Act_Index is range 0 .. Max_Act_Menu;
+  subtype Act_Range is Act_Index range 1 .. Max_Act_Menu;
+  type    Act_Menus is array ( Act_Range ) of P_Menu;
+
+  type Menu_Title is new Menu with record
+    Act_Menu  : Act_Menus;        -- Stack of displayed menus
+    Menu_Index: Act_Index := 0;   -- Top of menu stack
+  end record;
+end Class_Menu_Title;
+
+with Pack_Constants;
+use  Pack_Constants;
+package body Class_Menu_Title is
+
+  procedure Set_Up( The:in out Menu_Title; Active:in Positive ) is
+    Me: Menu_Item;
+  begin
+    Create( The, 1, 1, (1+Max_Menu)*Active+1, 3 ); -- Fixed size
+    Make_Window( The, Visible );
+    The.Act_Menu( 1 ) := Menu(The)'Unchecked_Access;-- Title menu
+    The.Menu_Index := 1;
+    for I in 1 .. Active loop                      -- Get menu
+      Get_Menu_Name( The, I, Me );                 --  name
+      Put( The, Me ); Put( The, "|" );             --  write
+    end loop;
+    Register( The'Unchecked_Access, C_Menu );      -- Register
+    Menu_Spot( The, C_Cursor );                    -- Cursor on
+  end Set_Up;
+
+  procedure Send_To( The:in out Menu_Title; Ch:in Character ) is
+    Current, Next : P_Menu;
+    Proc          : P_Cbf;
+    Res           : String( 1..0 );
+  begin
+    Current := The.Act_Menu( The.Menu_Index );  -- Active menu
+    Get_Cur_Selected_Details( Current, Next, Proc );
+    case Ch is
+      when C_Where =>
+        Put( Current.all, "" );
+      when C_Action =>
+        if Next /= null and The.Menu_Index < Max_Act_Menu then
+          Make_Window( Current.all, Invisible );     -- Hide cur.
+          The.Menu_Index := The.Menu_Index + 1;      --
+          The.Act_Menu( The.Menu_Index ) := Next;    -- New menu
+          Make_Window( Next.all, Visible );          -- Reveal
+        else
+          if Proc /= null then                       -- Call
+            Res := Proc("Action")(1 .. 0 );
+          end if;
+        end if;
+      when others =>
+        Send_To( Current.all , Ch );  -- Treat as normal menu
+    end case;
+  end Send_To;
+
+  procedure Switch_Away( The:in out Menu_Title ) is
+  begin
+    Mark_Border( The, Top, 1, C_Win_Pas ); -- Now inactive
+    if The.Menu_Index > 1 then          -- Not top level menu
+      Make_Window( The.Act_Menu(The.Menu_Index).all, Invisible );
+      The.Menu_Index := 1;
+      Make_Window( The.Act_Menu( 1 ).all, Visible ); -- Top level
+    end if;
+  end Switch_Away;
+
+end Class_Menu_Title;
+
+--==================================================================
+
+with Class_Window;
+use  Class_Window;
+package Pack_Globals is
+  P_W1 : P_Window;    -- Window 1
+  P_W2 : P_Window;    -- Window 2
+end Pack_Globals;
+
+with Class_Window, Pack_Globals;
+use  Class_Window, Pack_Globals;
+function Execute_Call_Back(Cb_Mes:in String) return String is
+  Win : Window;
+begin
+  Put( P_W1.all, "Start [" & Cb_Mes & "]" ); New_Line( P_W1.all );
+  Framework( Win, 1, 17, 16, 5 );
+  for I in 1 .. 10 loop
+    Put( Win, I ); Put( Win, " " );
+    Put( Win, Cb_Mes ); New_Line( Win );
+  end loop;
+  Put( P_W1.all, "End   [" & Cb_Mes & "]" ); New_Line( P_W1.all );
+  return "";
+end Execute_Call_Back;
+
+with Class_Window, Pack_Globals;
+use  Class_Window, Pack_Globals;
+function Write_Name( Cb_Mes:in String ) return String is
+begin
+  Put( P_W1.all, "Written by Mike Smith" ); New_Line( P_W1.all );
+  Put( P_W1.all, "University of Brighton" ); New_Line( P_W1.all );
+  New_Line( P_W2.all ); Put( P_W2.all, "Written by Mike Smith" );
+  New_Line( P_W2.all ); Put( P_W2.all, "University of Brighton" );
+  return "";
+end Write_Name;
+
+with Class_Window, Pack_Globals;
+use  Class_Window, Pack_Globals;
+function No_Help( Cb_Mes:in String ) return String is
+begin
+  Put( P_W1.all, " +------------------+" ); New_Line( P_W1.all );
+  Put( P_W1.all, " | There is no Help |" ); New_Line( P_W1.all );
+  Put( P_W1.all, " +------------------+" ); New_Line( P_W1.all );
+  return "";
+end No_Help;
+
+with Class_Window, Pack_Globals;
+use  Class_Window, Pack_Globals;
+function Echo_Mess( Cb_Mes:in String ) return String is
+begin
+  Clear( P_W1.all );
+  Put( P_W1.all, Cb_Mes ); New_Line( P_W1.all );
+  return "";
+end Echo_Mess;
+
+with Class_Root_Window, Class_Input_Manager, Class_Window,
+     Class_Dialog, Class_Menu, Class_Menu_Title, Pack_Globals,
+     Execute_Call_Back, Write_Name, No_Help, Echo_Mess;
+use  Class_Root_Window, Class_Input_Manager, Class_Window,
+     Class_Dialog, Class_Menu, Class_Menu_Title, Pack_Globals;
+procedure Main is
+begin
+  Window_Prologue;
+  declare
+    E,F            : Dialog;
+    W1,W2          : aliased Window;
+    M1             : aliased Menu_Title;
+    M2,M3,M4,M5    : aliased Menu;
+
+
+  begin
+    Framework( W1,  1,  5, 30, 10 );
+    Framework( W2, 70, 20, 10, 6 );
+
+    Framework(M2, "Open",   null,       null,
+      "Close",  null,       null,
+      "Window", null,       Execute_Call_Back'access,
+      "help",   null,       No_Help'access );
+
+    Framework(M3, "up",     null,       null,
+      "down",   null,       null,
+      "left",   null,       null,
+      "right",  null,       null,
+      "loop",   M4'Unchecked_Access,  null,
+      "About",  null,       Write_Name'access);
+
+    Framework(M4, "Loop",   M3'Unchecked_Access,   null,
+      "Help",   null,        No_Help'access,
+      "About",  null,        Write_Name'access,
+      "About",  null,        Write_Name'access );
+
+    Framework(M5, "Mike",   null,        Write_Name'access,
+      "A",      null,        Write_Name'access,
+      "Smith",  null,        Write_Name'access,
+      "Next",   M4'Unchecked_Access,   null );
+
+    Framework(M1, "PC",    M2'Unchecked_Access,    null,
+      "File",  M3'Unchecked_Access,    null,
+      "Trans", M5'Unchecked_Access,    null );
+
+    for I in 1 .. 7 loop
+      Put(W1,"Mike Smith"); New_Line( W1 );
+    end loop;
+
+    for I in 1 .. 20 loop
+      for B in Attribute loop
+        Mark_Border( W2, B, I, ':' );
+      end loop;
+    end loop;
+
+    Framework(E, 40, 6 , 20, "Diag 1", Echo_Mess'access );
+    Framework(F, 40, 18, 22, "Diag 2", Execute_Call_Back'access );
+
+    P_W1 := W1'Unchecked_Access;
+    P_W2 := W2'Unchecked_Access;
+
+    Window_Start;
+  end;
+  Window_Epilogue;
+end Main;
@@  x80_arch.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:57 PM BST  --
+---------------------------------------------------------------------
+--[cat.adb] Procedure
+with Ada.Text_Io, Ada.Command_Line;
+use  Ada.Text_Io, Ada.Command_Line;
+procedure Main is
+  Fd  : Ada.Text_Io.File_Type;          -- File descriptor
+  Ch  : Character;                      -- Current character
+begin
+  if Argument_Count >= 1 then
+    for I in 1 .. Argument_Count loop   -- Repeat for each file
+      begin
+        Open( File=>Fd, Mode=>In_File,  -- Open file
+          Name=>Argument(I) );
+        Put("@@ "); Put( Argument(I) );
+        Put(" @@"); New_Line;
+        while not End_Of_File(Fd) loop  -- For each Line
+          Put("+");                     -- Marker
+          while not End_Of_Line(Fd) loop-- For each character
+            Get(Fd,Ch); Put(Ch);        -- Read / Write character
+          end loop;
+          Skip_Line(Fd); New_Line;      -- Next line / new line
+        end loop;
+        Close(Fd);                      -- Close file
+      exception
+        when Name_Error =>
+          Put("arch: " & Argument(I) & " no such file" );
+          New_Line;
+        when Status_Error =>
+          Put("arch: " & Argument(I) & " all ready open" );
+          New_Line;
+      end;
+    end loop;
+  else
+    Put("Usage: arch file1 ... "); New_Line;
+  end if;
+end Main;
@@  x80_ed.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:57 PM BST  --
+---------------------------------------------------------------------
+-- The editor
+--   To compile using the GNAT Ada 95 Compiler on Windows 95/NT, Linux
+-- 
+--   gnatchop /w x80_ed.ada          // Split into units
+--   gcc /c io.c                     // Compile C interface
+--   gnatmake ed.adb /largs io.o     // Compile program
+-- 
+-- Notes:
+--   The file io.c is the commented out C code before Raw_io.adb
+--   The current I/O system with Windows 95 can not cope with 
+--     the fast reception of characters
+--   ^C Will Kill the program use ^E to exit
+--   ^D Will cause the program to terminate do not use
+-- 
+--   In the package Pack_constants
+--     ANSI_IN_DEL currently must be set to FALSE for Windows 95/NT
+--     as the ANSI escape sequences for Insert and Delete lines are
+--     not supported.
+--     Using this setting will slow down the refreshing of the screen.
+
+
+--[pack_constants.ads] Specification
+package Pack_Constants is
+  Max_Answer     : constant := 80;
+  Lines_On_Screen: constant := 25;
+  Page_Rack      : constant := Lines_On_Screen/2;
+
+  C_Left         : constant Character := Character'Val(012);
+  C_Right        : constant Character := Character'Val(018);
+  C_Up           : constant Character := Character'Val(021);
+  C_Down         : constant Character := Character'Val(011);
+
+  C_Page_Up      : constant Character := Character'Val(023);
+  C_Page_Down    : constant Character := Character'Val(024);
+
+  C_Quit         : constant Character := Character'Val(005);
+  C_Debug        : constant Character := Character'Val(020);
+  C_Refresh      : constant Character := Character'Val(025);
+  C_Del          : constant Character := Character'Val(008);
+
+  C_Open         : constant Character := Character'Val(001);
+  C_Close        : constant Character := Character'Val(002);
+  C_Set_Fn       : constant Character := Character'Val(006);
+
+  C_Next         : constant Character := Character'Val(007);
+
+  Ansi_Ins_Del   : constant Boolean   := False;
+end Pack_Constants;
+
+--====================================================================
+
+--[class_line.ads] Specification
+with Ada.Finalization;
+use  Ada.Finalization;
+package Class_Line is
+  type Line is new Controlled with private;
+
+  procedure Debug( The:in Line );
+  procedure Initialize( The:in out Line );
+  procedure Finalize( The:in out Line );
+  procedure Adjust( The:in out Line );
+  procedure Clear( The:in out Line );
+
+  procedure Start( The:in out Line );       -- Iterator for line
+  function  End_Of_Line( The:in Line) return Boolean;
+  function  Get_Char( The:in Line ) return Character;
+  procedure Next_Ch( The:in out Line );
+
+  procedure Add(The:in out Line; Where:in Natural; Ch:in Character);
+  procedure Del( The:in out Line; Where:in Natural );
+
+  function  Deliver_Current_Col( The:in Line ) return Natural;
+  function  Deliver_Cur_Len( The:in Line ) return Natural;
+  function  Deliver_Max_Line_Size( The:in Line ) return Natural;
+
+private
+  Max_Chs : constant := 79;
+  type    Line_Iter_Index is range 0 .. Max_Chs+1;
+  subtype Line_Index      is Line_Iter_Index range 0 .. Max_Chs;
+  subtype Line_Range      is Line_Iter_Index range 1 .. Max_Chs;
+  type    Line_Array      is array ( Line_Range ) of Character;
+
+  --TYPE O_Line IS RECORD
+  type Line is new Controlled with record
+    Chs        : Line_Array;          -- Line of characters
+    Iter_Pos   : Line_Iter_Index := 0;-- Iterator position
+    Cur_Len    : Line_Index := 0;     -- Position of last ch
+    Col        : Line_Range := 1;     -- Last operation here
+  end record;
+  --TYPE Line IS ACCESS O_Line;          -- Pointer to a Line
+
+end Class_Line;
+
+--[class_line.adb] Implementation
+with Ada.Text_Io, Ada.Integer_Text_Io;
+package body Class_Line is
+
+  procedure Debug( The:in Line ) is
+    use  Ada.Text_Io, Ada.Integer_Text_Io;
+  begin
+    Put("Line    >");
+    Put("last ch      :"); Put(Integer(The.Cur_Len),Width=>2);
+    Put(" Iter pos    :"); Put(Integer(The.Iter_Pos),Width=>2);
+    Put(" Active col  :"); Put(Integer(The.Col), Width=>2);
+    New_Line;
+  end Debug;
+
+  procedure Initialize( The:in out Line ) is
+  begin
+    --the := NEW O_Line;               -- Dynamic Store
+    Clear(The);
+  end Initialize;
+
+  procedure Finalize( The:in out Line ) is
+  begin
+    null;
+  end Finalize;
+
+  procedure Adjust( The:in out Line ) is
+  begin
+    null;
+  end Adjust;
+
+  procedure Clear( The:in out Line ) is
+  begin
+    The.Iter_Pos := 0;           -- Iterator
+    The.Cur_Len := 0;            -- Empty Line
+    The.Col := 1;                -- Current position
+  end Clear;
+
+  procedure Start( The:in out Line ) is
+  begin
+    The.Iter_Pos := 1;
+  end Start;
+
+  function  End_Of_Line( The:in Line) return Boolean is
+  begin
+    return The.Iter_Pos > The.Cur_Len;
+  end End_Of_Line;
+
+  function  Get_Char( The:in Line ) return Character is
+  begin
+    return The.Chs( The.Iter_Pos );
+  end Get_Char;
+
+  procedure Next_Ch( The:in out Line ) is
+  begin
+    if The.Iter_Pos <= The.Cur_Len then
+      The.Iter_Pos := The.Iter_Pos + 1;
+    end if;
+  end Next_Ch;
+
+  procedure Add(The:in out Line; Where:in Natural;
+      Ch:in Character) is
+    Add_At : Line_Index;
+  begin
+    Add_At := Line_Index( Where );
+    if The.Cur_Len < The.Chs'Length and then
+        Add_At <= The.Cur_Len+1
+        then
+      for I in reverse Add_At .. The.Cur_Len loop
+        The.Chs(I+1) := The.Chs(I);       -- Make room
+      end loop;
+      The.Cur_Len := The.Cur_Len + 1;     -- Increase length
+      The.Chs( Add_At ) := Ch;            -- Insert character
+      if Add_At < The.Chs'Length then     -- New column
+        The.Col := Add_At + 1;
+      end if;
+    end if;
+  end Add;
+
+  procedure Del( The:in out Line; Where:in Natural ) is
+    Del_At : Line_Index;
+  begin
+    Del_At := Line_Index( Where );
+    if Del_At <= The.Cur_Len then         -- Can delete
+      The.Cur_Len := The.Cur_Len-1;       -- New length
+      The.Col     := Del_At;              -- New current col
+      for I in Del_At .. The.Cur_Len loop
+        The.Chs(I) := The.Chs(I+1);       -- Delete ch
+      end loop;
+    end if;
+    if Del_At > The.Cur_Len then          -- New column
+      The.Col := Line_Index'Max(The.Cur_Len+1, 1 );
+    end if;
+  end Del;
+
+  function  Deliver_Current_Col( The:in Line ) return Natural is
+  begin
+    return Natural( The.Col );            -- Current position
+  end Deliver_Current_Col;
+
+  function  Deliver_Cur_Len( The:in Line ) return Natural is
+  begin
+    return Natural( The.Cur_Len );        -- Chars in line
+  end Deliver_Cur_Len;
+
+  function  Deliver_Max_Line_Size( The:in Line ) return Natural is
+  begin
+    return Max_Chs;                         -- Max size of line
+  end Deliver_Max_Line_Size;
+
+end Class_Line;
+
+--====================================================================
+
+--[class_store.ads] Specification
+with Class_Line; use Class_Line;
+with Ada.Finalization;
+use  Ada.Finalization;
+package Class_Store is
+
+  type Store is new Limited_Controlled with private;
+
+  procedure Debug( The:in Store );
+  procedure Initialize( The:in out Store );
+  procedure Finalize( The:in out Store );
+  procedure Clear( The:in out Store );
+
+  procedure Add( The:in out Store; Row:in Natural;
+    Column:in Natural; Ch:in Character );
+  procedure Del( The:in out Store; Row:in Natural;
+    Column:in Natural );
+  procedure Add( The:in out Store; Ch:in Character );
+  procedure Del( The:in out Store );
+
+  procedure Left_Right( The:in out Store; Dir:in Character );
+  procedure Up_Down( The:in out Store; Dir:in Character;
+    No_Lines:in Natural );
+
+  function  Deliver_Line(The:in Store; Row:in Natural) return Line;
+
+  function  No_Lines( The:in Store ) return Natural;
+  procedure Set_Position( The:in out Store; Row:in Natural;
+    Column:in Natural );
+  procedure Set_Last_Line( The:in out Store; Row:in Natural );
+  procedure Deliver_Row_Column( The:in Store; Row:out Natural;
+    Column:out Natural );
+  function  Deliver_Store_Size( The:in Store ) return Natural;
+  function  Deliver_Max_Line_Size
+    ( The:in Store; Row:in Natural ) return Natural;
+
+private
+  Max_Lines : constant := 120;
+  type    Store_Index    is range 0 .. Max_Lines;
+  subtype Store_Range    is Store_Index range 1 .. Max_Lines;
+  type    Store_As_Array is array ( Store_Index ) of Line;
+
+  type Store is new Limited_Controlled with record
+    Lines     : Store_As_Array;    -- Store as array
+    No_Lines  : Store_Index := 0;  -- Lines stores
+    Row       : Natural := 0;      -- Current row
+    Col       : Natural := 0;      -- Current column
+  end record;
+end Class_Store;
+
+--[class_store.adb] Implementation
+with Pack_Constants, Ada.Text_Io, Ada.Integer_Text_Io;
+use  Pack_Constants;
+package body Class_Store is
+
+  procedure Debug( The:in Store ) is
+    use Ada.Text_Io, Ada.Integer_Text_Io;
+  begin
+    Put("Store   >");
+    Put("no_lines     :"); Put(Integer(The.No_Lines), Width=>2);
+    Put(" active row  :"); Put(Integer(The.Row), Width=>2);
+    Put(" active col  :"); Put(Integer(The.Col), Width=>2);
+    New_Line;
+    Debug( The.Lines( Store_Index( The.Row ) ) );
+  end Debug;
+
+  procedure Initialize( The:in out Store ) is
+  begin
+    --O    FOR i IN Store_range LOOP
+    --O      initialize( the.lines(i) );           -- Individual lines
+    --O    END LOOP;
+    Clear(The);                             -- clear Store
+    Set_Last_Line( The, 1 );                -- Set the last line
+  end Initialize;
+
+  procedure Finalize( The:in out Store ) is
+  begin
+    null;
+  end Finalize;
+
+  procedure Clear( The:in out Store ) is
+  begin
+    for I in Store_Range loop
+      Clear( The.Lines(I) );      -- Individual lines
+    end loop;
+    The.No_Lines := 0;            -- Lines stored
+    The.Row      := 1;            -- Current Line
+    The.Col      := 1;            -- Current char in line
+  end Clear;
+
+  procedure Add( The:in out Store; Row:in Natural;
+      Column:in Natural; Ch:in Character ) is
+    Row_Is : Store_Index := Store_Index( Row );
+  begin
+    if Row_Is > The.No_Lines and then Row <= Max_Lines then
+      The.No_Lines := The.No_Lines + 1;
+    end if;
+    Add( The.Lines( Row_Is ), Column, Ch );
+  end Add;
+
+  procedure Del( The:in out Store; Row:in Natural;
+      Column:in Natural ) is
+  begin
+    Del( The.Lines( Store_Index(Row) ), Column );
+  end Del;
+
+  procedure Add( The:in out Store; Ch:in Character ) is
+  begin
+    Add( The, The.Row, The.Col, Ch );
+    The.Col :=
+      Deliver_Current_Col( The.Lines(Store_Index(The.Row)));
+  end Add;
+
+  procedure Del( The:in out Store ) is
+  begin
+    Del( The, The.Row, Natural'Max(The.Col-1, 1) );    -- at position
+    The.Col :=
+      Deliver_Current_Col( The.Lines(Store_Index(The.Row)));
+  end Del;
+
+  procedure Left_Right( The:in out Store; Dir:in Character ) is
+    Length  : Natural;
+  begin
+    if Dir = C_Left then                -- move ->
+      if The.Col > 1 then               -- Can go left
+        The.Col := The.Col-1;
+      end if;
+    else                                -- move ->
+      Length :=
+        Deliver_Cur_Len( The.Lines(Store_Index(The.Row)) );
+      if The.Col <= Length then         -- Can go right
+        The.Col := The.Col+1;
+      end if;
+    end if;
+  end Left_Right;
+
+  procedure Up_Down( The:in out Store; Dir:in Character;
+      No_Lines:in Natural ) is
+    Length  : Natural;
+  begin
+    if Dir = C_Up or else Dir = C_Page_Up then
+      if Integer(The.Row) - No_Lines >= 1 then
+        The.Row := The.Row - No_Lines;
+      else
+        The.Row := 1;
+      end if;
+    else
+      if Integer(The.Row)+No_Lines<=Integer(The.No_Lines) then
+        The.Row := The.Row + No_Lines;
+      else
+        The.Row := Natural(The.No_Lines);
+        if The.Row < Max_Lines and then Dir = C_Down then
+          The.Row := The.Row + 1;       -- Expand by 1 line
+        end if;
+      end if;
+    end if;
+    Length := Deliver_Cur_Len(The.Lines(Store_Index(The.Row)));
+    The.Col := Natural'Max( Natural'Min( Length, The.Col ), 1 );
+  end Up_Down;
+
+  function Deliver_Line(The:in Store; Row:in Natural) return Line is
+  begin
+    return The.Lines( Store_Index(Row) );  -- The whole line
+  end  Deliver_Line;
+
+  function  No_Lines( The:in Store ) return Natural is
+  begin
+    return Natural(The.No_Lines);          -- Lines in buffer
+  end No_Lines;
+
+  procedure Set_Position( The:in out Store; Row:in Natural;
+      Column:in Natural ) is
+  begin
+    The.Col  := Column;         -- The new col
+    The.Row  := Row;            -- The new row
+  end Set_Position;
+
+  procedure Set_Last_Line( The:in out Store; Row:in Natural ) is
+  begin
+    The.No_Lines := Store_Index(Row);  -- New last line
+  end Set_Last_Line;
+
+  procedure Deliver_Row_Column( The:in Store; Row:out Natural;
+      Column:out Natural ) is
+  begin
+    Row    := The.Row;           -- The current row
+    Column := The.Col;           -- The current col
+  end Deliver_Row_Column;
+
+  function  Deliver_Store_Size( The:in Store ) return Natural is
+  begin
+    return Max_Lines;            -- Max size of buffer
+  end Deliver_Store_Size;
+
+  function  Deliver_Max_Line_Size
+      ( The:in Store; Row:in Natural ) return Natural is
+  begin
+    return Deliver_Max_Line_Size(The.Lines(Store_Index(Row)));
+  end Deliver_Max_Line_Size;
+
+end Class_Store;
+
+-- All I/O is RAW
+--     Write :chs are immediately written to the terminal
+--     Read  :chs are immediately available to the program
+--           Unfortunately input characters are echoed using
+--           get_immediate in Ada.Text_IO
+
+package Raw_Io is
+  procedure Get_Immediate( Ch:out Character );
+  procedure Put( Ch:in Character );
+  procedure Put( Str:in String );
+private
+  First_Time : Boolean := True;
+end Raw_Io;
+
+-- BEGIN file io.c
+-- /*
+--  *   The C function to turn of echoing
+--  *
+--  *   Works with the GNAT implementation on Linux, Win95
+--  *   Note:
+--  *    Uses Unix API call to turn of echoing
+--  *   Compile: gcc /c io.c
+--  */
+-- 
+-- 
+-- #include <termios.h>
+-- #include <unistd.h>
+-- 
+-- void c_no_echo()
+-- {
+--   static tcflag_t c_lflag;
+--   static int fd = STDIN_FILENO;
+--   static struct termios termios_data;
+--   tcgetattr( fd, &termios_data );
+--   c_lflag = termios_data.c_lflag;
+--   termios_data.c_lflag = termios_data.c_lflag & (~ECHO);
+--   tcsetattr( fd, TCSANOW, &termios_data );
+-- }
+-- END file io.c
+
+
+-- =========================================================================
+-- 
+-- Alternative BODY for Raw_io
+--   All the I/O is performed by code written in C
+--   Implemented in C code that following this Ada body
+-- 
+
+-- WITH Interfaces.C;
+-- USE  Interfaces.C;
+-- PACKAGE BODY raw_io IS
+-- 
+-- PROCEDURE get_immediate( ch:OUT Character ) IS
+--    FUNCTION c_get_char RETURN Char;
+--    PRAGMA import (C, c_get_char, "c_get_char");
+-- BEGIN
+--    ch := to_ada( c_get_char );
+-- END get_immediate;
+-- 
+-- PROCEDURE put( ch:IN Character ) IS
+--    PROCEDURE c_put_char( ch:IN Char );
+--    PRAGMA import (C, c_put_char, "c_put_char");
+-- BEGIN
+--    c_put_char( to_c( ch ) );
+-- END put;
+-- 
+-- PROCEDURE put( str:IN String ) IS
+--    PROCEDURE c_put_str( str:IN Char_array );
+--    PRAGMA import (C, c_put_str, "c_put_str");
+-- BEGIN
+--    c_put_str( to_c( str, append_nul=>TRUE ) );
+-- END put;
+-- 
+-- END raw_io;
+-- 
+-- C Interface for above Ada body
+-- 
+-- #define UNIX     1       /* Using GNAT on a UNIX based system all IO in C*/
+-- #define DOS      2       /* Using GNAT on a DOS based system */
+-- #define WIN95    3       /* Using GNAT on a WIN 95/NT system */
+-- #define UNIXs    WIN95   /* Using GNAT on a UNIX based system */
+-- 
+-- /* Notes:
+--  *  ENVIRONMENT = UNIX  / Uses Unix API for all I/O
+--  *              = DOS   / Uses DOS API (Via DJGPP C) for all I/O
+--  *              = GNAT  / Uses Ada95 Input & Output procedures +
+--  *                             Unix API call to turn of echoing of input
+--  *              = UNIXs / Uses Ada95 Input & Output procedures +
+--  *                             Unix API call to turn of echoing of input
+--  */
+-- 
+-- #define ENVIRONMENT	WIN95    /* Environment for program */
+-- 
+-- 
+-- #define ESC	'\033'
+-- 
+-- 
+-- #if ENVIRONMENT == DOS
+-- # include <pc.h>
+-- # include <keys.h>
+-- #endif
+-- #include <stdio.h>
+-- 
+-- typedef enum { false, true } bool;
+-- 
+-- char c_get_char();
+-- void c_put_char( char ch );
+-- void c_put_str( char *str );
+-- 
+-- 
+-- #if ENVIRONMENT == DOS
+-- /*
+--  * Make function keys and arrow keys return two characters
+--  * E.G. Right arrow returns (char) 0, 'M'
+--  *      Left  arrow         (char) 0, 'K'
+--  */
+-- 
+-- char c_get_char()
+-- {
+--   int c;
+--   static char the_ch;                 /* Remembered character */
+--   static bool prev_char = false;      /* There is remembered ch */
+--   if ( prev_char ) {
+--     prev_char = false; return the_ch;
+--   }
+--   c = getkey();                        /* Get char no echo */
+--   if ( c & 0x100 ) {                   /* Function / Arrow key */
+--     prev_char = true; 
+--     the_ch = (char) ( c & 0xFF );
+--     return (char) 0;                   /* Marker */
+--   }
+--   return (char) (c & 0xFF);            /* Ordinary character */
+-- }
+-- #endif
+-- 
+-- #if ENVIRONMENT == UNIX
+-- /*
+--  * Set the terminal mode to /echo /icanon on first read
+--  * reset when get ^E
+--  *
+--  */
+-- 
+-- #include <termios.h>
+-- #include <unistd.h>
+-- 
+-- char c_get_char()
+-- {
+--   static bool first_time = true;
+--   static tcflag_t c_lflag;
+--   static int fd = STDOUT_FILENO;
+--   static struct termios termios_data;
+--   char c;
+-- 
+--   if ( first_time )
+--   {
+--     tcgetattr( fd, &termios_data );
+--     c_lflag = termios_data.c_lflag;
+--     termios_data.c_lflag = termios_data.c_lflag & ( ~(ECHO|ICANON) );
+--     tcsetattr( fd, TCSANOW, &termios_data );
+--     first_time = false;
+--   }
+--   c = getchar();
+--   if ( c == '\005')
+--   {
+--     termios_data.c_lflag = c_lflag;
+--     tcsetattr( fd, TCSANOW, &termios_data );
+--   }
+--   return (char) (c & 0xFF);            /* Ordinary character */
+-- }
+-- 
+-- #endif
+-- 
+-- #if ENVIRONMENT == WIN95
+-- 
+-- /*
+--  * Uses the C function c_no_echo to turn of echoing of input
+--  *
+--  */
+-- 
+-- #include <termios.h>
+-- #include <unistd.h>
+-- 
+-- void c_no_echo()
+-- {
+--   static tcflag_t c_lflag;
+--   static int fd = STDIN_FILENO;
+--   static struct termios termios_data;
+--   tcgetattr( fd, &termios_data );
+--   c_lflag = termios_data.c_lflag;
+--   termios_data.c_lflag = termios_data.c_lflag & (~ECHO);
+--   tcsetattr( fd, TCSANOW, &termios_data );
+-- }
+-- 
+-- #endif
+-- 
+-- #if ENVIRONMENT == UNIX || ENVIRONMENT == DOS
+-- 
+-- /*
+--  * C function to write characters immediately to the terminal
+--  */
+-- 
+-- void c_put_char( char ch )
+-- {
+--   fputc(ch, stdout); fflush( stdout );  /* Output ch */
+-- }
+-- 
+-- void c_put_str( char *str )
+-- {
+--   while (*str) fputc(*str++, stdout);  /* Output String */
+--   fflush( stdout );                    /* Flush buffer */
+-- }
+-- 
+-- #endif
+-- 
+-- =========================================================================
+
+with Interfaces.C, Ada.Text_Io;
+use  Interfaces.C, Ada.Text_Io;
+package body Raw_Io is
+
+  procedure Get_Immediate( Ch:out Character) is
+    procedure C_No_Echo;
+    pragma Import (C, C_No_Echo, "c_no_echo");   -- Turn off echo
+  begin
+    if First_Time then
+      C_No_Echo; First_Time := False;
+    end if;
+    Ada.Text_Io.Get_Immediate(Ch);
+    if Character'Pos(Ch) = 10 then               -- Real Return ch
+      Ch := Character'Val(13);
+    end if;
+  end Get_Immediate;
+
+  procedure Put( Ch:in Character ) is            -- Raw write
+  begin
+    Ada.Text_Io.Put( Ch ); Ada.Text_Io.Flush;
+  end Put;
+
+  procedure Put( Str:in String ) is              -- Raw write
+  begin
+    Ada.Text_Io.Put( Str ); Ada.Text_Io.Flush;
+  end Put;
+
+end Raw_Io;
+
+
+-- Machine dependent I/O
+-- Currently assume input is from a terminal supporting
+-- input of ANSI escape sequences
+
+package Pack_Md_Io is
+  procedure Put( Ch :in Character );           -- Put char
+  procedure Put( Str:in String );              -- Put string
+  procedure Get_Immediate( Ch:out Character ); -- no echo
+end Pack_Md_Io;
+
+--[pack_md_io.adb] Implementation
+with Raw_Io, Pack_Constants;
+use  Raw_Io, Pack_Constants;
+package body Pack_Md_Io is
+  procedure Put( Ch:in Character ) is
+  begin
+    Raw_Io.Put( Ch );
+  end Put;
+
+  procedure Put( Str:in String ) is
+  begin
+    Raw_Io.Put( Str );
+  end Put;
+
+  procedure Get_Immediate( Ch:out Character) is
+    Esc: constant Character := Character'Val(27);
+  begin
+    Raw_Io.Get_Immediate( Ch );
+    if Ch = Esc then                         -- ESC 
+      Raw_Io.Get_Immediate( Ch );            -- [
+      if Ch = '[' then
+        Raw_Io.Get_Immediate( Ch );
+        case Ch is
+          when 'A'    => Ch := C_Up;         -- A - Up arrow
+          when 'B'    => Ch := C_Down;       -- B - Down arrow
+          when 'C'    => Ch := C_Right;      -- C - Right arrow
+          when 'D'    => Ch := C_Left;       -- D - Left arrow
+          when others => Ch := '?';          -- ? - Unknown
+        end case;
+      end if;
+    end if;
+  end Get_Immediate;
+
+end Pack_Md_Io;
+
+--====================================================================
+
+--[pack_ansi_display.ads] Specification
+package Pack_Ansi_Display is
+  procedure Clear;                        -- Clear screen
+  procedure Down ( N:in Natural );        -- Cursor Down
+  procedure Up   ( N:in Natural );        -- Cursor Up
+  procedure Left ( N:in Natural );        -- Cursor Left
+  procedure Right( N:in Natural );        -- Cursor Right
+  procedure Insert_Line( N:in Natural );  -- Insert Line(s)
+  procedure Delete_Line( N:in Natural );  -- Delete Line(s)
+  procedure Clear_To_End_Of_Line;         -- Clear to end of line
+  procedure Cursor_Position (Row:in Natural; Column:in Natural);
+  procedure Put  ( N:in Natural );        -- Write decimal number
+private
+end Pack_Ansi_Display;
+
+--[pack_ansi_display.adb] Implementation
+with Pack_Md_Io;
+use  Pack_Md_Io;
+package body Pack_Ansi_Display is
+  Prefix: constant String := Character'Val(27) & "[";
+
+  procedure Clear is                      -- Clear screen
+  begin
+    Put( Prefix & "2J");
+  end Clear;
+
+  procedure Down( N:in Natural ) is      -- Cursor Down
+  begin
+    Put( Prefix ); Put( N );Put("B");
+  end Down;
+
+  procedure Up( N:in Natural ) is        -- Cursor Up
+  begin
+    Put( Prefix ); Put( N );Put("A");
+  end Up;
+
+  procedure Left( N:in Natural ) is      -- Cursor Left
+  begin
+    Put( Prefix ); Put( N );Put("D");
+  end Left;
+
+  procedure Right( N:in Natural ) is      -- Cursor Right
+  begin
+    Put( Prefix ); Put( N );Put("C");
+  end Right;
+
+  procedure Insert_Line( N:in Natural ) is
+  begin
+    Put( Prefix ); Put( N ); Put("L");
+  end Insert_Line;
+
+  procedure Delete_Line( N:in Natural ) is
+  begin
+    Put( Prefix ); Put( N ); Put("M");
+  end Delete_Line;
+
+  procedure Cursor_Position(Row:in Natural; Column:in Natural) is
+  begin
+    Put( Prefix ); Put(Row); Put(";"); Put(Column); Put("H");
+  end Cursor_Position;
+
+  procedure Clear_To_End_Of_Line is    -- Clear to end of line
+  begin
+    Put( Prefix & "K");
+  end Clear_To_End_Of_Line;
+
+  procedure Put( N:in Natural ) is     -- Write decimal number
+  begin
+    if N >= 10 then Put( N / 10 ); end if;
+    Put( Character'Val(N rem 10 + Character'Pos('0') ) );
+  end Put;
+
+end Pack_Ansi_Display;
+
+--====================================================================
+
+--[class_user.ads] Specification
+package Class_User is
+  type User is private;
+  type Mode is ( No_Echo, Echo );
+
+  function Get_Command( The:in User ) return Character;
+  function Dialog(The:in User; Mes:in String) return String;
+  function Get_Character(The:in User; M:in Mode)return Character;
+
+private
+  type User is record null; end record;
+
+end Class_User;
+
+--[class_user.adb] Implementation
+with Pack_Constants, Pack_Md_Io, Pack_Ansi_Display;
+use  Pack_Constants, Pack_Md_Io, Pack_Ansi_Display;
+
+package body Class_User is
+
+  function Get_Command( The:in User ) return Character is
+    Ch : Character;
+  begin
+    Get_Immediate( Ch );
+    return Ch;
+  end Get_Command;
+
+  function  Dialog( The:in User;
+      Mes:in String) return String is
+    Ch      : Character;
+    Reading : Boolean;
+    Str     : String( 1 .. Max_Answer );
+    Str_Len : Integer := 1;
+  begin
+    Cursor_Position( Lines_On_Screen, 1 ); Clear_To_End_Of_Line;
+    Put( Mes ); Reading := True; Str(1) := ' ';
+    for I in Str'range loop
+      Ch := Get_Character( The, No_Echo );
+      if Ch = Ascii.Cr or else Ch = Ascii.Lf then
+        Reading := False;
+        exit;
+      else
+        Put( Ch ); Str(I) := Ch; Str_Len := I;
+      end if;
+    end loop;
+    return Str( 1 .. Str_Len );
+  end Dialog;
+
+  function Get_Character( The:in User; M:in Mode ) return Character is
+    Ch : Character;
+  begin
+    Get_Immediate( Ch );
+    if M = Echo then Put( Ch ); end if;
+    return Ch;
+  end Get_Character;
+
+end Class_User;
+
+--====================================================================
+
+--[class_display.ads] Specification
+with Ada.Finalization, Pack_Constants, Class_Line, Class_Store;
+use  Ada.Finalization, Pack_Constants, Class_Line, Class_Store;
+package Class_Display is
+
+  type Mode    is ( No_Echo, Echo );
+  type Display is new Limited_Controlled with private;
+
+  procedure Debug( The:in Display );
+  procedure Initialize( The:in out Display );
+  procedure Finalize( The:in out Display );
+  procedure Clear( The:in out Display );
+
+  procedure Init( The:in out Display; S:in Store);
+  procedure Refresh( The:in out Display );
+
+  procedure Add( The:in out Display; B:in Store; Ch:in Character );
+  procedure Del( The:in out Display; S:in Store );
+  procedure Position( The:in out Display; S:in Store );
+
+  procedure Status( The:in out Display; S:in Store );
+  function  Deliver_Display_Size( The:in Display ) return Natural;
+
+private
+  Display_Lines : constant := Lines_On_Screen-1;
+  type    Display_Index is new Integer   range 0..Display_Lines;
+  subtype Display_Range is Display_Index range 1..Display_Lines;
+
+  procedure Display_Line( The:in out Display; I:in Display_Index );
+  procedure Minimal_Refresh( The:in out Display;
+    Old_Abs_Line:in Natural );
+
+  type Display_As_Array is array ( Display_Range ) of Line;
+  type Display is new Limited_Controlled with record
+    Display       : Display_As_Array;    -- Display
+    No_Lines      : Display_Index := 0;  -- Active lines
+    Abs_Line      : Natural := 0;        -- of 1st display line
+    Row           : Natural := 0;        -- current row
+    Col           : Natural := 0;        -- current column
+  end record;
+
+end Class_Display;
+
+--[class_display.adb] Implementation
+with Ada.Text_Io, Ada.Integer_Text_Io,
+     Pack_Constants, Pack_Md_Io, Pack_Ansi_Display; 
+use  Pack_Constants, Pack_Md_Io, Pack_Ansi_Display;
+package body Class_Display is
+
+  procedure Debug( The:in Display ) is
+  begin
+    Ada.Text_Io.        Put("Display >");
+    Ada.Text_Io.        Put("no_lines     :");
+    Ada.Integer_Text_Io.Put(Integer(The.No_Lines),Width=>2);
+    Ada.Text_Io.        Put(" current_row :");
+    Ada.Integer_Text_Io.Put(Integer(The.Row),Width=>2);
+    Ada.Text_Io.        Put(" current_col :");
+    Ada.Integer_Text_Io.Put(Integer(The.Col),Width=>2);
+    Ada.Text_Io.        Put(" abs_line    :");
+    Ada.Integer_Text_Io.Put(Integer(The.Abs_Line),Width=>2);
+    Ada.Text_Io.        New_Line;
+  end Debug;
+
+  procedure Initialize( The:in out Display ) is
+  begin
+    The.Row := 1;      The.Col := 1;
+    The.Abs_Line := 1; The.No_Lines := 0;
+    --O    FOR i IN Display_range LOOP
+    --O      initialize( the.display( i ) );    -- Individual lines
+    --O    END LOOP;
+    Clear(The);
+  end Initialize;
+
+  procedure Finalize( The:in out Display ) is
+  begin
+    null;
+  end Finalize;
+
+  procedure Clear( The:in out Display ) is
+  begin
+    Clear;
+  end Clear;
+
+  procedure Init( The:in out Display; S:in Store) is
+    Store_Row, Store_Col, Lines : Natural;
+  begin
+    Deliver_Row_Column( S, Store_Row, Store_Col );
+    The.Abs_Line := Store_Row;         -- Shadowing screen from
+    The.Row := Store_Row;              --
+    The.Col := Store_Col;              -- Position on screen
+    Lines := No_Lines(S)-Store_Row+1;  -- Current pos to end
+    The.No_Lines := Display_Index(Natural'Min(Lines, Display_Lines));
+
+    for I in 1 .. The.No_Lines loop
+      The.Display(I) := Deliver_Line( S, Natural(I) );
+    end loop;
+  end Init;
+
+  procedure Refresh( The:in out Display ) is
+  begin
+    Clear( The );
+    for I in 1 .. The.No_Lines loop
+      Cursor_Position( Natural(I), 1 );
+      Display_Line( The, I );
+    end loop;
+    Cursor_Position( The.Row, The.Col );
+  end Refresh;
+
+  procedure Display_Line(The:in out Display; I:in Display_Index) is
+  begin
+    Start( The.Display(I) );
+    while not End_Of_Line( The.Display(I) ) loop
+      Put( Get_Char( The.Display(I) ) );
+      Next_Ch( The.Display(I) );
+    end loop;
+    Clear_To_End_Of_Line;
+  end Display_Line;
+
+  -- Add the character to the current position in the display
+
+  procedure Add(The:in out Display; B:in Store; Ch:in Character) is
+    I : Display_Index;
+  begin
+    I := Display_Index( The.Row );
+    if I > The.No_Lines then      -- Insert on empty line
+      The.No_Lines := I;          --  the first time
+    end if;
+    The.Display(I):=Deliver_Line(B,Natural(I)+The.Abs_Line-1);
+    Cursor_Position( Natural(I), 1 );
+    Display_Line( The, I );
+    The.Col := Deliver_Current_Col( The.Display(I) );
+
+    Cursor_Position( Natural(I), The.Col );
+  end Add;
+
+  -- Delete the char at the current position from the display
+
+  procedure Del( The:in out Display; S:in Store ) is
+    I : Display_Index;
+  begin
+    I := Display_Index( The.Row );
+    The.Display(I) :=
+      Deliver_Line(S, Natural(I)+The.Abs_Line-1 );
+    Cursor_Position( Natural(I), 1 );
+    Display_Line( The, I );
+    Position( The, S );
+  end Del;
+
+  -- Position the cursor in the correct position on the display
+
+  procedure Position( The:in out Display; S:in Store ) is
+    Row,Column   : Natural;     -- In store
+    Change       : Boolean;     -- Change display
+    Old_Abs_Line : Natural;     -- Old abs line at top of screen
+  begin
+    Deliver_Row_Column( S, Row, Column );
+    Change := False;
+    if Row < The.Abs_Line then                     -- Rack Down
+      Old_Abs_Line := The.Abs_Line;
+      The.Abs_Line := Row;
+      Change := True;
+    end if;
+
+    if Row > The.Abs_Line + (Display_Lines-1) then  -- Rack up
+      Old_Abs_Line := The.Abs_Line;
+      The.Abs_Line := Row - (Display_Lines-1);
+      Change := True;
+    end if;
+
+    if Change then                            -- change display
+      declare
+        Remaining_Lines : Natural;
+      begin
+        Remaining_Lines := No_Lines(S) - The.Abs_Line+1;
+        Remaining_Lines := Natural'Min(Remaining_Lines, Display_Lines);
+        The.No_Lines := Display_Range( Remaining_Lines );
+
+        for I in 1 .. The.No_Lines loop
+          The.Display(I) :=
+            Deliver_Line(S, Natural(I) + The.Abs_Line-1 );
+        end loop;
+
+        Row := Row - The.Abs_Line + 1;
+        Minimal_Refresh( The, Old_Abs_Line );    -- try and do
+      end;
+    else
+      Row := Row - The.Abs_Line + 1;
+    end if;
+
+    The.Row := Row; The.Col := Column;
+    Cursor_Position( The.Row, The.Col );
+  end Position;
+
+  -- Do a minimal refresh of the screen
+
+  procedure Minimal_Refresh( The:in out Display;
+      Old_Abs_Line:in Natural ) is
+    Diff : Natural;
+  begin
+    if Ansi_Ins_Del and then
+        ( Old_Abs_Line-(Display_Lines-1) <= The.Abs_Line and
+        Old_Abs_Line+(Display_Lines-1) >= The.Abs_Line )
+        then
+      -- Some of the lines on the screen OK
+      if The.Abs_Line < Old_Abs_Line then
+        -- Rack display down, Insert new lines at top
+        Diff := Old_Abs_Line-The.Abs_Line;
+        Cursor_Position( 1, 1 );
+        Insert_Line( Diff );
+        for I in 1 .. Display_Index(Diff) loop
+          Cursor_Position( Natural(I), 1 );
+          Display_Line( The, I );
+        end loop;
+      else
+        -- Rack display up, Insert new lines at bottom of display
+        Diff := The.Abs_Line - Old_Abs_Line;
+        Cursor_Position(1,1); Delete_Line( Diff );   -- Rack up
+        Cursor_Position( Display_Lines-(Diff)+1, 1);
+        for I in The.No_Lines-Display_Index(Diff)+1
+            .. The.No_Lines loop
+          Cursor_Position( Natural(I), 1 );
+          Display_Line( The, I );
+        end loop;
+        for I in The.No_Lines+1 .. Display_Lines loop
+          Cursor_Position( Natural(I), 1 );      -- Clear left
+          Clear_To_End_Of_Line;                  -- on screen
+        end loop;
+      end if;
+    else -- No lines on display valid do a total refresh
+      Refresh(The);
+    end if;
+  end Minimal_Refresh;
+
+  procedure Status( The:in out Display; S:in Store ) is
+    Row,Column : Natural;
+  begin
+    Deliver_Row_Column( S, Row, Column );
+    Cursor_Position( Lines_On_Screen, 1 ); Clear_To_End_Of_Line;
+    Cursor_Position( Lines_On_Screen, 58 );
+    Put("Line "); Put( Row ); Put("    ");
+    Cursor_Position( Lines_On_Screen, 68 );
+    Put("column "); Put( Column ); Put("  ");
+    Cursor_Position( The.Row, The.Col);
+  end Status;
+
+  function Deliver_Display_Size(The:in Display) return Natural is
+  begin
+    return Display_Lines;
+  end Deliver_Display_Size;
+
+end Class_Display;
+
+--====================================================================
+
+--[class_file.ads] Specification
+with Ada.Finalization, Class_Store, Pack_Constants, Class_User, Class_Display;
+use  Ada.Finalization, Class_Store, Pack_Constants, Class_User, Class_Display;
+package Class_File is
+
+  type File is new Limited_Controlled with private;
+
+  procedure Initialize( The:in out File );
+  procedure Finalize( The:in out File );
+  procedure Register( The:in out File; Str:in String );
+  function  Is_Active( The:in File ) return Boolean;
+  procedure Set_Active( The:in out File );
+  procedure Set_Not_Active( The:in out File );
+  procedure Read ( The:in out File; S:in out Store );
+  procedure Write( The:in out File; S:in out Store; U:in User );
+
+private
+  type    File_Index  is range 0 .. Max_Answer;
+  subtype File_Range  is File_Index  range 1 .. Max_Answer;
+  type    State_File  is ( Active, Not_Active );
+  type File is new Limited_Controlled with record
+    State         : State_File := Not_Active;
+    Lines_In_File : Natural := 0;
+    File          : String( 1 .. Max_Answer );
+    File_Length   : File_Index := 0;
+  end record;
+end Class_File;
+
+--[class_file.adb] Implementation
+with Text_Io, Class_Line;
+use  Text_Io, Class_Line;
+package body Class_File is
+
+  procedure Initialize( The:in out File ) is
+  begin
+    The.State       := Not_Active;    -- Not active
+    The.File_Length := 0;             -- No file registered
+    The.File        := (others=>' '); -- Blank file name
+  end Initialize;
+
+  procedure Finalize( The:in out File ) is
+  begin
+    if The.State = Active then
+      null;                      -- Dilemma should do something
+    end if;
+  end Finalize;
+
+  procedure Register( The:in out File; Str:in String ) is
+  begin
+    The.File( 1 .. Str'Length ) := Str;
+    The.File_Length             := Str'Length;
+    The.State                   := Active;
+  end Register;
+
+  function  Is_Active( The:in File ) return Boolean is
+  begin
+    return The.State = Active;
+  end Is_Active;
+
+  procedure Set_Active( The:in out File ) is
+  begin
+    The.State := Active;
+  end Set_Active;
+
+  procedure Set_Not_Active( The:in out File ) is
+  begin
+    The.State := Not_Active;
+  end Set_Not_Active;
+
+  procedure Read( The:in out File; S:in out Store ) is
+    File_In : Text_Io.File_Type;   -- File handle
+    Row     : Natural;             -- Processing row
+    Max_Size: Natural;             -- Max lines in store
+  begin
+    Open( File => File_In, Mode => In_File,
+      Name => The.File(1 .. Integer(The.File_Length)));
+    Row := 1; Max_Size := Deliver_Store_Size(S);
+    while not End_Of_File( File_In ) and Row <= Max_Size loop
+      Set_Position( S, Row, 1 );
+      declare
+        Ch       : Character;    -- Character read from file
+        Col      : Natural;      -- Current col position in line
+        Line_Size: Natural;      -- Maximum line size
+      begin
+        Col := 1; Line_Size := Deliver_Max_Line_Size( S, Row );
+        while not End_Of_Line( File_In ) loop
+          Get( File_In, Ch );
+          if Col <= Line_Size then
+            Add( S, Ch ); Col := Col + 1;
+          end if;
+        end loop;
+      end;
+      Skip_Line( File_In ); Row := Row + 1;
+    end loop;
+    Close( File_In );
+    Set_Position( S, 1, 1 ); Set_Last_Line( S, Row-1 );
+    The.Lines_In_File := Row-1;
+    The.State := Not_Active;              -- Not changed
+  end Read;
+
+  procedure Write( The:in out File; S:in out Store;
+      U:in User ) is
+    File_Out : Text_Io.File_Type;   -- File handle
+    Row      : Natural := 1;
+  begin
+    if The.State = Active then
+      if The.File(1) = ' ' then
+        Register( The, Dialog( U, "File name: ") );
+      end if;
+      Create( File=> File_Out, Mode => Out_File,
+        Name => The.File(1..Integer(The.File_Length)));
+      Row := 1;
+      while Row <= No_Lines(S) loop
+        declare
+          L  : Class_Line.Line;             -- Line to output
+          Ch : Character;                  -- current character
+        begin
+          L := Deliver_Line( S, Row ); Start(L);
+          while not End_Of_Line(L) loop
+            Ch := Get_Char( L ); Put( File_Out, Ch );
+            Next_Ch( L );
+          end loop;
+        end;
+        New_Line( File_Out ); Row := Row + 1;
+      end loop;
+      Close( File_Out );
+      The.State := Not_Active;
+      -- ELSE
+      --   RAISE Name_error;
+    end if;
+  end Write;
+
+end Class_File;
+
+--====================================================================
+
+--[ed.adb] Procedure
+with --Ada.Text_Io, Ada.Integer_Text_Io,
+     Ada.Io_Exceptions, Class_Store, Class_File, Class_Display, Pack_Constants,
+     Pack_Ansi_Display, Class_User;
+use  --Ada.Text_Io, Ada.Integer_Text_Io,
+     Ada.Io_Exceptions, Class_Store, Class_File, Class_Display, Pack_Constants,
+     Pack_Ansi_Display, Class_User;
+procedure Ed is
+  Max_Open  : constant := 3;           -- Maximum open files
+  type Open is range 1 .. Max_Open;
+
+  C       : Open;                      -- Current screen/file
+  In_Store: array(Open) of Store;      -- In store copy of file
+  On_Disk : array(Open) of File;       -- Disk file access
+  Screen  : array(Open) of Display;    -- The Display
+  Person  : User;                      -- The editors user
+
+
+  function Yes( Str:in String ) return Boolean is
+  begin
+    return ( Str'Length = 1  and then
+      (Str = "y" or  else Str = "Y") ) or else
+      ( Str'Length = 3  and then
+      (Str = "yes" or else Str = "YES") );
+  end Yes;
+
+  function No( Str:in String ) return Boolean is
+  begin
+    return ( Str'Length = 1  and then
+      (Str = "n" or  else Str = "N") ) or else
+      ( Str'Length = 2  and then
+      (Str = "no" or else Str = "NO") );
+  end No;
+
+  procedure Open_File( The:in Open ) is    -- Read file into buffer
+    Fail : Boolean := False;               -- Result of read
+  begin
+    loop                                   -- Repeat until read
+      begin
+        if Is_Active( On_Disk(C) ) and then -- Deleting current
+            not Yes(Dialog( Person,
+              "Delete this buffer [y/n] : ")) then
+          exit;                            -- No
+        end if;
+        Clear( In_Store(C) );              -- Clear store
+        Register(On_Disk(C),
+          Dialog(Person, "File name: "));
+        Read( On_Disk(C), In_Store(C) );   -- Read file into store
+        Init( Screen(C), In_Store(C) );    -- Initialize screen
+        Refresh( Screen(C) );              -- Display
+        Set_Not_Active( On_Disk(C) );      -- File not active
+        exit;
+      exception
+        when Name_Error => Fail := True;   -- Could not read
+        when others     => Fail := True;   -- Anything else
+      end;
+    end loop;
+    if Fail then                           -- If failed to read
+      Clear( In_Store(C) );                --  clear changes
+    end if;
+  end Open_File;                           --
+
+  procedure Close_File( The:in Open ) is   -- Write buffer
+  begin
+    loop
+      begin
+        if not No(Dialog(Person, "Save file [y/n] : ")) then
+          Write( On_Disk(C), In_Store(C),
+            Person );                 -- Write file back
+          Clear( In_Store(C) );            -- clear data
+          Init( Screen(C), In_Store(C) );  -- Set to empty
+          Position(Screen(C), In_Store(C));-- set to start position
+          Refresh( Screen(C) );            -- Blank screen
+          Set_Not_Active( On_Disk(C) );    -- Now non active
+        end if;
+        exit;
+      exception
+        when Name_Error =>
+          Register( On_Disk(C), " " );      -- Could not write
+        when others     =>
+          Register( On_Disk(C), " " );      -- Could not write
+      end;
+    end loop;
+  end Close_File;
+
+  procedure Commands is
+  begin
+--    New_Line;
+--    Put(" Left      ^L         Right       ^R"); New_Line;
+--    Put(" Up        ^U         Down        ^K"); New_Line;
+--    Put(" Page Up   ^W         Page Down   ^X"); New_Line;
+--    Put(" Quit      ^E         Debug info  ^T"); New_Line;
+--    Put(" Refresh   ^Y         Del         ^H"); New_Line;
+--    Put(" Opem file ^A         Close File  ^B"); New_Line;
+--    Put(" Set file  ^F         Next Buffer ^G"); New_Line;
+    null;
+  end Commands;
+
+
+  procedure Process_Command(Action:in Character) is
+  begin
+    case Action is
+      when C_Open   => Open_File(C);       -- read file
+      when C_Close  => Close_File(C);      -- write
+      when C_Set_Fn =>
+        Register(On_Disk(C),
+          Dialog( Person, "Set file name: "));
+      when C_Next   =>                     -- next screen
+        C := C rem Max_Open + 1;
+        Refresh( Screen(C) );
+      when C_Left | C_Right =>             -- Move   -> <-
+        Left_Right( In_Store(C), Action );
+        Position( Screen(C), In_Store(C) );
+      when C_Up | C_Down =>                -- Move   up down
+        Up_Down( In_Store(C), Action, 1 );
+        Position( Screen(C), In_Store(C) );
+      when C_Page_Up | C_Page_Down =>      -- Move   page up down
+        Up_Down(In_Store(C), Action, Page_Rack);
+        Position( Screen(C), In_Store(C) );
+      when C_Debug =>
+        Clear; Debug( In_Store(C) ); Debug( Screen(C) );
+        Commands;
+      when C_Refresh =>                    -- Refresh screen
+        Refresh( Screen(C) );
+      when C_Del =>                        -- Delete Character
+        Del(In_Store(C));
+        Del(Screen(C), In_Store(C) );
+        Set_Active( On_Disk(C) );
+      when Character'Val(32) .. Character'Val(127) =>
+        Add(In_Store(C), Action);
+        Add(Screen(C), In_Store(C), Action);
+        Set_Active( On_Disk(C) );
+      when Ascii.Cr | Ascii.Lf =>          -- Ignore
+        null;
+      when others =>                       -- Insert ?
+        Add(In_Store(C), '?');
+        Add(Screen(C), In_Store(C), '?');
+        Set_Active( On_Disk(C) );
+    end case;
+  end Process_Command;
+
+begin                                    -- Editor is
+  for C in Open loop                     -- In each current ...
+    Init( Screen(C), In_Store(C) );      -- Initialize
+  end loop;
+
+  C := 1;                                -- Current screen #1
+  Refresh( Screen(C) );                  -- Display cur screen
+  Status( Screen(C), In_Store(C) );      -- Display status
+
+  loop                                   -- Main loop
+    declare
+      Action : Character;
+    begin
+      Action := Get_Command( Person );   -- Editing command
+      exit when Action = C_Quit;         -- Quit
+      Process_Command( Action );         -- Do action
+      Status( Screen(C), In_Store(C) );  -- Display status
+    end;
+  end loop;
+
+  for C in Open loop                     -- Write changes
+    if Is_Active( On_Disk(C) ) then      -- if needed
+      Refresh( Screen(C) );              -- display file
+      Close_File(C);                     -- Save file
+    end if;
+  end loop;
+
+end Ed;
@@  x80_exp.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:50:59 PM BST  --
+---------------------------------------------------------------------
+with Ada.Text_Io;
+use  Ada.Text_Io;
+package Class_Line is
+  type Line_Status is ( Text_Line, File_Name, Unknown );
+  type Line is private;
+  procedure Get_Line( The:in out Line; Fd:in Ada.Text_Io.File_Type );
+  procedure Put_Line( The:in Line; Fd:in Ada.Text_Io.File_Type );
+  procedure Get_Fd( The:in out Line; Fd:in out Ada.Text_Io.File_Type );
+  function  Status( The:in Line ) return Line_Status;
+private
+  Max_Line : constant := 200;
+  subtype Line_Index is Integer range 0 .. Max_Line+1;
+  subtype Line_Range is Line_Index range 1 .. Max_Line;
+  subtype Line_Array is String( Line_Range );
+  type Line is record
+    Chs : Line_Array;       -- Characters of line
+    Len : Line_Index;       -- Positions used
+    Open: Boolean := False; -- Output file open
+  end record;
+  Name     : Line_Array;    -- File name from file
+  Name_Pos : Line_Index;    -- Characters in name
+end Class_Line;
+
+with Ada.Text_Io, Ada.Characters.Handling;
+use  Ada.Text_Io, Ada.Characters.Handling;
+package body Class_Line is
+  procedure Get_Line( The:in out Line; Fd:in Ada.Text_Io.File_Type ) is
+    Pos : Line_Index := 0;
+    Ch  : Character;
+  begin
+    while not End_Of_Line( Fd ) loop
+      Get( Fd, Ch );
+      if Pos < Max_Line then
+        Pos := Pos + 1;
+        The.Chs(Pos) := Ch;
+      end if;
+    end loop;
+    The.Len := Pos;
+    Skip_Line( Fd );
+  end Get_Line;
+
+  procedure Put_Line( The:in Line; Fd:in Ada.Text_Io.File_Type ) is
+  begin
+    if The.Open then
+      for I in 2 .. The.Len loop
+        Put( Fd, The.Chs(I) );
+      end loop;
+      New_Line( Fd );
+    end if;
+  end Put_Line;
+
+  function Status( The:in Line ) return Line_Status is
+    Pos  : Line_Index := 0;
+  begin
+    if The.Len >= 1 and then The.Chs(1) = '+' then
+      return Text_Line;
+    end if;
+    if The.Len >= 2 and then The.Chs(1..2) = "@@" then
+      for I in 3 .. The.Len-2 loop
+        if Is_Upper( The.Chs(I) ) or Is_Lower( The.Chs(I) ) or
+            Is_Digit( The.Chs(I) ) or The.Chs(I) = '_' or
+            The.Chs(I) = '.' then
+          Pos := Pos + 1;
+          Name(Pos) := The.Chs(I);
+        end if;
+      end loop;
+      Name_Pos := Pos;
+      Put( "Extracting file " & Name(1..Pos) ); New_Line;
+      return File_Name;
+    end if;
+    return Unknown;
+  end Status;
+
+  procedure Get_Fd( The:in out Line; Fd:in out Ada.Text_Io.File_Type ) is
+  begin
+    if The.Open then                    -- Output file open
+      Close( Fd ); The.Open := False;
+    end if;
+    Create( File=>Fd, Mode=>Out_File,   -- Create file
+      Name=>Name(1..Name_Pos) );
+    The.Open := True;
+  exception
+    when Name_Error =>
+      Put("Exp: Can not create file " & Name(1..Name_Pos) );
+      New_Line;
+    when Status_Error =>
+      Put("Exp: " & Name(1..Name_Pos) & " all ready open" );
+      New_Line;
+    when others =>
+      Put("Exp: " & Name(1..Name_Pos) & " unknown error" );
+      New_Line;
+  end;
+
+end Class_Line;
+
+
+with Ada.Text_Io, Ada.Command_Line, Class_Line;
+use  Ada.Text_Io, Ada.Command_Line, Class_Line;
+procedure Main is
+  I_Fd   : Ada.Text_Io.File_Type;        -- File descriptor
+  O_Fd   : Ada.Text_Io.File_Type;        -- File descriptor
+  A_Line : Class_Line.Line;
+begin
+  if Argument_Count >= 1 then
+    for I in 1 .. Argument_Count loop    -- Repeat for each file
+      begin
+        Open( File=>I_Fd, Mode=>In_File, -- Open file
+          Name=>Argument(I) );
+        while not End_Of_File(I_Fd) loop -- For each Line
+          Get_Line( A_Line, I_Fd );
+          case Status(A_Line) is
+            when Text_Line =>            -- Write to file
+              Put_Line( A_Line, O_Fd );
+            when File_Name =>            -- Get file name
+              Get_Fd( A_Line, O_Fd );
+            when Unknown =>              -- Ignore
+              null;
+          end case;
+        end loop;
+        Close(I_Fd);                     -- Close file
+      exception
+        when Name_Error =>
+          Put("Exp: " & Argument(I) & " no such file" );
+          New_Line;
+        when Status_Error =>
+          Put("Exp: " & Argument(I) & " all ready open" );
+          New_Line;
+        when others =>
+          Put("Exp: " & Argument(I) & " unknow error" );
+          New_Line;
+      end;
+    end loop;
+  else
+    Put("Usage: Exp file1 ... "); New_Line;
+  end if;
+end Main;
@@  x80_gam.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:51:00 PM BST  --
+---------------------------------------------------------------------
+--[pack_screen.ads] Specification
+package Pack_Screen is
+  procedure Screen_Clear;                -- Home clear screen
+  procedure Screen_Home;                 -- Home no clear screen
+private
+  Esc: constant Character := Character'Val(27);
+end Pack_Screen;
+
+--[pack_screen.adb] Implementation
+with Text_Io; use Text_Io;
+package body Pack_Screen is             -- Terminal dependent I/O
+  procedure Screen_Clear is             -- Clear screen
+  begin
+    Put( Esc & "[2J" );                 -- Escape sequence
+  end Screen_Clear;
+  procedure Screen_Home is              -- Home
+  begin
+    Put( Esc & "[0;0H");                -- Escape sequence
+  end Screen_Home;
+end Pack_Screen;
+
+--====================================================================
+
+--[class_counter.ads] Specification
+package Class_Counter is
+  type Counter        is private;
+  type Counter_Colour is ( Black, White );
+  procedure Set( The:in out Counter; Rep:in Counter_Colour );
+  procedure Display( The:in Counter );
+  procedure Display_None( The:in Counter );
+  procedure Flip( The:in out Counter );
+  function  Rep( The:in Counter ) return Counter_Colour;
+private
+  type Counter is record
+    Colour: Counter_Colour;         -- Colour of counter
+  end record;
+end Class_Counter;
+
+--[class_counter.adb] Implementation
+with Ada.Text_Io;
+use  Ada.Text_Io;
+package body Class_Counter is
+  procedure Set( The:in out Counter; Rep:in Counter_Colour ) is
+  begin
+    The.Colour := Rep;
+  end Set;
+
+  procedure Display( The:in Counter ) is
+  begin
+    case The.Colour is
+      when Black  => Put('X'); -- Representation of a black piece
+      when White  => Put('O'); -- Representation of a white piece
+    end case;
+  end Display;
+
+  procedure Display_None( The:in Counter ) is
+  begin
+    Put(' ');                   -- Representation of NO piece
+  end Display_None;
+
+  procedure Flip( The:in out Counter ) is
+  begin
+    case The.Colour is
+      when Black  => The.Colour := White;     -- Flip to White
+      when White  => The.Colour := Black;     -- Flip to Black
+    end case;
+  end Flip;
+
+  function  Rep( The:in Counter ) return Counter_Colour is
+  begin
+    return The.Colour;  -- Representation of the counter colour
+  end Rep;
+end Class_Counter;
+
+--====================================================================
+
+--[class_cell.ads] Specification
+with Class_Counter;
+use  Class_Counter;
+package Class_Cell is
+  type Cell is private;
+  type Cell_Holds is ( C_White, C_Black, Empty );
+
+  procedure Initialize( The:in out Cell );
+  function  Holds( The:in Cell ) return Cell_Holds;
+  procedure Add( The:in out Cell; Players_Counter:in Counter );
+  procedure Display( The:in Cell );
+  procedure Flip( The:in out Cell );
+  function To_Colour( C:in Cell_Holds ) return Counter_Colour;
+private
+  type Cell_Is is ( Empty_Cell, Not_Empty_Cell );
+  type Cell is record
+    Contents: Cell_Is := Empty_Cell;
+    Item    : Counter;                 -- The counter
+  end record;
+end Class_Cell;
+
+--[class_cell.adb] Implementation
+package body Class_Cell is
+  procedure Initialize( The:in out Cell ) is
+  begin
+    The.Contents := Empty_Cell;   -- Initialize cell to empty
+  end Initialize;
+
+  function  Holds( The:in Cell ) return Cell_Holds is
+  begin
+    case The.Contents is
+      when Empty_Cell     =>             -- Empty
+        return Empty;                    --  No counter
+      when Not_Empty_Cell =>             -- Counter
+        case Rep( The.Item ) is
+          when White => return C_White;  --  white counter
+          when Black => return C_Black;  --  black counter
+        end case;
+    end case;
+  end Holds;
+
+  procedure Add(The:in out Cell; Players_Counter:in Counter) is
+  begin
+    The := (Not_Empty_Cell,Players_Counter);
+  end Add;
+
+  procedure Display( The:in Cell ) is
+  begin
+    if The.Contents = Not_Empty_Cell then
+      Display( The.Item );           -- Display the counter
+    else
+      Display_None( The.Item );      -- No counter
+    end if;
+  end Display;
+
+  procedure Flip( The:in out Cell ) is
+  begin
+    Flip( The.Item );                -- Flip counter
+  end Flip;
+
+  function To_Colour(C:in Cell_Holds) return Counter_Colour is
+  begin
+    case C is                        -- Conversion of enum.
+      when C_White => return White;
+      when C_Black => return Black;
+      when others  => raise Constraint_Error;
+    end case;
+  end To_Colour;
+
+end Class_Cell;
+
+--====================================================================
+
+--[class_board.ads] Specification
+with Class_Counter, Class_Cell;
+use  Class_Counter, Class_Cell;
+package Class_Board is
+
+  type Board         is private;
+  type State_Of_Game is ( Play, Win, Draw, Lose );
+  type Move_Status   is ( Ok, Invalid, Pass );
+
+  procedure Set_Up( The:in out Board );
+  procedure Add( The:in out Board; X,Y:in Integer;
+                 Move_Is:in Move_Status );
+  procedure Now_Playing( The:in out Board; C:in Counter_Colour );
+  procedure Display( The:in Board );
+  function  Check_Move( The:in Board; X,Y:in Integer )
+                        return Move_Status;
+  function  Status( The:in Board ) return State_Of_Game;
+  function  Contents( The:in Board; X,Y:in Integer )
+                      return Cell_Holds;
+
+private
+  Size: constant := 8;                            -- 8 * 8 Board
+  subtype Board_Index is Integer range 1 .. Size; --
+
+  type Board_Array is array (Board_Index, Board_Index) of Cell;
+  type Score_Array is array (Counter_Colour) of Natural;
+  type Move_Array  is array (Counter_Colour) of Move_Status;
+
+  type Board is record
+    Sqrs     : Board_Array;               -- Game board
+    Player   : Counter_Colour;            -- Current Player
+    Opponent : Counter_Colour;            -- Opponent
+    Score    : Score_Array;               -- Running score
+    Last_Move: Move_Array;                -- Last move is
+  end record;
+end Class_Board;
+
+--[class_board.adb] Implementation
+with Ada.Text_Io, Ada.Integer_Text_Io, Pack_Screen;
+use  Ada.Text_Io, Ada.Integer_Text_Io, Pack_Screen;
+package body Class_Board is
+
+  procedure Next( The:in Board; X_Co,Y_Co:in out Board_Index;
+                  Dir:in Natural; Res:out Boolean);
+  function  Find_Turned( The:in Board; X,Y: in Board_Index )
+                        return Natural;
+  procedure Turn_Counters(The: in out Board; X,Y: in Board_Index;
+                          Total: out Natural );
+  function  No_Turned(The:in Board; O_X,O_Y:in Board_Index;
+                      Dir:in Natural;
+                      N:in Natural := 0 ) return Natural;
+  procedure Capture(The:in out Board; X_Co, Y_Co:in Board_Index;
+                    Dir:in Natural );
+
+  procedure Set_Up( The:in out Board ) is
+    Black_Counter: Counter;               -- A black counter
+    White_Counter: Counter;               -- A white counter
+  begin
+    Set( Black_Counter, Black );          -- Set black
+    Set( White_Counter, White );          -- Set white
+    for X in The.Sqrs'range(1) loop
+      for Y in The.Sqrs'range(2) loop
+        Initialize( The.Sqrs(X,Y) );      -- To empty
+      end loop;
+    end loop;
+    Add( The.Sqrs( Size/2,   Size/2 ),   Black_Counter );
+    Add( The.Sqrs( Size/2,   Size/2+1 ), White_Counter );
+    Add( The.Sqrs( Size/2+1, Size/2 ),   White_Counter );
+    Add( The.Sqrs( Size/2+1, Size/2+1 ), Black_Counter );
+    The.Score( Black ) := 2; The.Score( White ) := 2;
+  end Set_Up;
+
+  procedure Add( The:in out Board; X,Y:in Integer;
+                 Move_Is:in Move_Status ) is
+    Plays_With: Counter;          -- Current player's counter
+    Turned    : Natural;          -- Number counters turned
+  begin
+    Set( Plays_With, The.Player );          -- Set current colour
+    The.Last_Move( The.Player ) := Move_Is; -- Last move is
+    if Move_Is = Ok then                    -- Not Pass
+      Turn_Counters(The, X,Y, Turned);      -- and flip
+      Add( The.Sqrs( X, Y ), Plays_With );  -- to board
+      The.Score( The.Player ) :=
+        The.Score( The.Player ) + Turned + 1;
+      The.Score( The.Opponent ):=
+        The.Score( The.Opponent ) - Turned;
+    end if;
+  end Add;
+
+  procedure Now_Playing(The:in out Board; C:in Counter_Colour) is
+  begin
+    The.Player   := C;                       -- Player
+    case C is                                -- Opponent
+      when White => The.Opponent := Black;
+      when Black => The.Opponent := White;
+    end case;
+  end Now_Playing;
+
+  procedure Display( The:in Board ) is
+    Dashes: String( 1 .. The.Sqrs'Length*4+1 ) := (others=>'-');
+  begin
+    Screen_Clear;                            -- Clear screen
+    Put( Dashes ); New_Line;                 -- Top
+    for X in The.Sqrs'range(1) loop
+      Put("|");                              -- Cells on line
+      for Y in The.Sqrs'range(2) loop
+        Put(" "); Display( The.Sqrs(X,Y) ); Put(" |");
+      end loop;
+      New_Line; Put( Dashes ); New_Line;     -- Bottom lines
+    end loop;
+    New_Line;
+    Put( "Player X has " );
+    Put( Integer(The.Score(Black)), Width=>2 );
+    Put( " counters" ); New_Line;
+    Put( "Player O has " );
+    Put( Integer(The.Score(White)), Width=>2 );
+    Put( " counters" ); New_Line;
+  end Display;
+
+  function Check_Move( The:in Board; X,Y:in Integer )
+      return Move_Status is
+  begin
+    if X = 0 and then Y = 0 then
+      return Pass;
+    elsif X in Board_Index and then Y in Board_Index then
+      if Holds( The.Sqrs( X, Y ) ) = Empty then
+        if Find_Turned(The, X, Y) > 0 then
+          return Ok;
+        end if;
+      end if;
+    end if;
+    return Invalid;
+  end Check_Move;
+
+  function Find_Turned( The:in Board; X,Y: in Board_Index )
+      return Natural is
+    Sum     : Natural := 0;       -- Total stones turned
+  begin
+    if Holds( The.Sqrs( X, Y ) ) = Empty then
+      for Dir in 1 .. 8 loop      -- The  8 possible directions
+        Sum := Sum + No_Turned( The, X, Y, Dir );
+      end loop;
+    end if;
+    return Sum;                   -- return total
+  end Find_Turned;
+
+  procedure Turn_Counters(The: in out Board; X,Y: in Board_Index;
+      Total: out Natural ) is
+    Num_Cap  : Natural := 0;
+    Captured : Natural;
+  begin
+    if Holds( The.Sqrs( X, Y ) ) = Empty then
+      for Dir in 1 .. 8 loop
+        Captured := No_Turned( The, X, Y, Dir );
+        if Captured > 0 then
+          Capture( The, X, Y, Dir );
+          Num_Cap := Num_Cap + Captured;
+        end if;
+      end loop;
+    end if;
+    Total := Num_Cap;
+  end Turn_Counters;
+
+  function  No_Turned(The:in Board; O_X,O_Y:in Board_Index;
+      Dir:in Natural;
+      N:in Natural := 0 ) return Natural is
+    Ok : Boolean;                           -- Result from next
+    Nxt: Cell_Holds;                        -- Next in line is
+    Col: Counter_Colour;                    -- Counter colour
+    X  : Board_Index := O_X;                -- Local copy
+    Y  : Board_Index := O_Y;                -- Local copy
+  begin
+    Next( The, X,Y, Dir, Ok );              -- Next cell
+    if Ok then                              -- On the board
+      Nxt := Holds( The.Sqrs(X,Y) );        -- Contents are
+      if Nxt = Empty then                   -- End of line
+        return 0;
+      else
+        Col := To_Colour( Nxt );            -- Colour
+        if Col = The.Opponent then          -- Opponents counter
+          return No_Turned(The, X,Y, Dir, N+1); -- Try next cell
+        elsif Col = The.Player then         -- End of counters
+          return N;                         -- Counters turned
+        end if;
+      end if;
+    else
+      return 0;                             -- No line
+    end if;
+  end No_Turned;
+
+  procedure Next( The:in Board; X_Co,Y_Co:in out Board_Index;
+      Dir:in Natural; Res:out Boolean) is
+    X, Y   : Natural;
+  begin
+    X := X_Co; Y := Y_Co;         -- May go outside Board_range
+    case Dir is
+      when 1 =>         Y:=Y+1;   --  Direction to move
+      when 2 => X:=X+1; Y:=Y+1;   --      8   1   2
+      when 3 => X:=X+1;           --
+      when 4 => X:=X+1; Y:=Y-1;   --      7   *   3
+      when 5 =>         Y:=Y-1;   --
+      when 6 => X:=X-1; Y:=Y-1;   --      6   5   4
+      when 7 => X:=X-1;           --
+      when 8 => X:=X-1; Y:=Y+1;   --
+      when others => raise Constraint_Error;
+    end case;
+    if X in Board_Index and then Y in Board_Index then
+      X_Co :=  X; Y_Co :=  Y;     --
+      Res := True;                -- Found a next cell
+    else
+      Res := False;               -- No next cell
+    end if;
+  end Next;
+
+  procedure Capture(The:in out Board; X_Co, Y_Co:in Board_Index;
+                    Dir:in Natural ) is
+    Ok   : Boolean;                   -- There is a next cell
+    X, Y : Board_Index;               -- Coordinates of cell
+    Nxt  : Cell_Holds;                -- Next in line is
+  begin
+    X := X_Co; Y := Y_Co;
+    Next( The, X, Y, Dir, Ok );       -- Calculate pos next cell
+    if Ok then                        -- Cell exists (Must)
+      Nxt := Holds( The.Sqrs(X,Y) );
+      if To_Colour( Nxt ) = The.Opponent then
+        Flip( The.Sqrs(X, Y) );       -- Capture
+        Capture(The, X, Y, Dir );     -- Implement capture
+      else
+        return;                       -- End of line
+      end if;
+    else
+      raise Constraint_Error;         -- Will never occur
+    end if;
+  end Capture;
+
+  function  Status ( The:in Board ) return State_Of_Game is
+  begin
+    if The.Score( The.Opponent ) = 0 then
+      return Win;
+    end if;
+    if (The.Sqrs'Length(1) * The.Sqrs'Length(2) =
+        The.Score(The.Opponent)+The.Score(The.Player)) or
+        (The.Last_Move(Black)=Pass and The.Last_Move(White)=Pass)
+        then
+      if The.Score(The.Opponent) = The.Score(The.Player)
+          then return Draw;
+      end if;
+      if The.Score(The.Opponent) < The.Score(The.Player)
+          then return Win;
+      else
+        return Lose;
+      end if;
+    end if;
+    return Play;
+  end;
+
+  function Contents( The:in Board; X,Y:in Integer )
+                     return Cell_Holds is
+  begin
+    return Holds( The.Sqrs( X, Y ) );
+  end Contents;
+
+end Class_Board;
+
+--====================================================================
+
+--[class_player.ads] Specification
+with Class_Counter, Class_Board;
+use  Class_Counter, Class_Board;
+package Class_Player is
+  type Player is private;
+
+  procedure Set( The:in out Player; C:in Counter_Colour );
+  procedure Get_Move(The:in Player; Row,Column:out Integer);
+  function  My_Counter( The:in Player ) return Counter;
+  procedure Announce( The:in Player; What:in State_Of_Game );
+private
+  type Player is record
+    Plays_With : Counter;        -- Player's counter
+  end record;
+end Class_Player;
+
+--[class_player.adb] Implementation
+with Ada.Text_Io, Ada.Integer_Text_Io, Ada.Float_Text_Io;
+use  Ada.Text_Io, Ada.Integer_Text_Io, Ada.Float_Text_Io;
+package body Class_Player is
+  procedure Set(The:in out Player; C:in Counter_Colour ) is
+    A_Counter : Counter;
+  begin
+    Set( A_Counter, C );          -- Set colour
+    The.Plays_With := A_Counter;  -- Player is playing with
+  end Set;
+
+  procedure Get_Move(The:in Player; Row,Column:out Integer) is
+    Valid_Move : Boolean := False;
+  begin
+    while not Valid_Move loop
+      begin
+        Put("Please enter move "); Display( The.Plays_With );
+        Put(" row column : "); Get( Row ); Get( Column );
+        Valid_Move := True;
+      exception
+        when Data_Error =>
+          Row := -1; Column := -1; Skip_Line;
+        when End_Error =>
+          Row := 0; Column := 0;
+          return;
+      end;
+    end loop;
+  end Get_Move;
+
+  function  My_Counter( The:in Player ) return Counter is
+  begin
+    return The.Plays_With;
+  end My_Counter;
+
+  procedure Announce(The:in Player; What:in State_Of_Game) is
+  begin
+    case What is
+      when Win    =>
+        Put("Player "); Display( The.Plays_With );
+        Put(" has won");
+      when Lose   =>
+        Put("Player "); Display( The.Plays_With );
+        Put(" has lost");
+      when Draw   =>
+        Put("It's a draw");
+      when others =>
+        raise Constraint_Error;
+    end case;
+    New_Line;
+  end Announce;
+
+end Class_Player;
+
+--====================================================================
+
+--[play.adb] Procedure
+with Class_Board, Class_Player, Class_Counter;
+use  Class_Board, Class_Player, Class_Counter;
+package Class_Game is
+  type Game is private;
+  procedure play( The:in out Game );
+private
+  type Player_Array is array(Counter_Colour) of Player;
+  type Game is record
+    Reversi    : Board;                     -- The playing board
+    Contestant : Player_Array;
+  end record;
+end Class_Game;
+
+
+package body Class_Game is
+
+procedure Play( The:in out Game ) is         -- Play reversi
+  Current_State : State_Of_Game;             -- State of game
+  Person        : Counter_Colour;            -- Current player
+  X, Y          : Integer;                   -- Move
+  Move_Is       : Move_Status;               -- Last move is
+begin
+  Set_Up( The.Reversi );                     -- Set up board
+  Set( The.Contestant(Black), Black );       -- Set player black
+  Set( The.Contestant(White), White );       -- Set player white
+
+  Current_State := Play;  Person := Black;   -- Black starts
+
+  Display( The.Reversi );                    -- Initial board
+
+  while Current_State = Play loop            -- Playable game
+    Now_Playing( The.Reversi, Person );      -- set player
+
+    loop                                     -- Get move 
+      Get_Move(The.Contestant(Person), X, Y);
+      Move_Is:=Check_Move(The.Reversi, X, Y);-- Validate
+      exit when Move_Is=Ok or Move_Is=Pass;  -- OK
+    end loop;
+
+    Add( The.Reversi, X, Y, Move_Is );       -- Add move to board
+
+    Display( The.Reversi );                  -- Display new board
+    Current_State := Status( The.Reversi );  -- State of play is
+
+    if Current_State = Play then             -- Is still playable
+      case Person is                         -- next player
+        when Black  => Person := White;
+        when White  => Person := Black;
+      end case;
+    end if;
+
+  end loop;                                  -- Next move
+
+  Announce( The.Contestant(Person), Current_State );  -- Result
+
+end Play;
+
+--====================================================================
+
+end Class_Game;
+
+with Class_Game;
+use  Class_Game;
+procedure Main is
+  A_Game : Game;
+begin
+  Play( A_Game );
+end Main;
@@  x99_mix.ada @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:51:01 PM BST  --
+---------------------------------------------------------------------
+with Interfaces.C, Ada.Unchecked_Conversion;
+use  Interfaces.C;
+function To_C_Int is new
+  Ada.Unchecked_Conversion( Integer, Int );
+
+with Interfaces.C, Ada.Unchecked_Conversion;
+use  Interfaces.C;
+function To_Ada_Integer is new
+  Ada.Unchecked_Conversion( Int, Integer );
+
+with Interfaces.C, To_C_Int, To_Ada_Integer;
+use  Interfaces.C;
+function Double( N:in Integer ) return Integer is
+  function C_Double(N:in Int) return Int;
+  pragma Import (C, C_Double, "c_double");
+begin
+  return To_Ada_Integer( C_Double( To_C_Int(N) ) );
+end Double;
+
+--[main.adb] Procedure
+with Ada.Text_Io, Ada.Integer_Text_Io, Ada.Float_Text_Io, Double;
+use  Ada.Text_Io, Ada.Integer_Text_Io, Ada.Float_Text_Io;
+procedure Main is
+begin
+  Put("3 Doubled is "); Put( Double(3) ); New_Line;
+end Main;
@@  c_double.c @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:51:03 PM BST  --
+---------------------------------------------------------------------
+int c_double( int );        /* Prototype */
+
+int c_double( int n )       /* function to double aargument */
+{
+  return n + n;
+}
@@  io.c @@
+---------------------------------------------------------------------
+-- (C) Michael A Smith 1993-2000 University of Brighton            --
+--     http://www.it.brighton.ac.uk/~mas                           --
+---------------------------------------------------------------------
+-- Version automatically created  Sat 29 Apr 2000 08:51:03 PM BST  --
+---------------------------------------------------------------------
+/*///////////////////////////////////////////////////////////////////////////
+// I / O     I n t e r f a c e   f o r   A d a 9 5   P r o g r a m s       //
+///////////////////////////////////////////////////////////////////////////*/
+
+#define UNIX     1       /* Using GNAT on a UNIX based system all IO in C*/
+#define WIN95    3       /* Using GNAT on a WIN 95/NT system */
+
+/* Notes:
+ *  ENVIRONMENT = UNIX  - Uses Unix API for all I/O
+ *              = WIN95 - Uses Ada95 Input & Output procedures +
+ *                             Unix API call to turn of echoing of input
+ */
+
+#define ENVIRONMENT	UNIX    /* Environment for program */
+
+/*///////////////////////////////////////////////////////////////////////////
+// D o   N o t    C h a n g e   b e y o n d     h e r e                    //
+///////////////////////////////////////////////////////////////////////////*/
+
+#define ESC	'\033'
+
+#include <stdio.h>
+
+typedef enum { false, true } bool;
+
+char c_get_char();
+
+#if ENVIRONMENT == UNIX
+/*
+ * Set the terminal mode to -echo -icanon on first read
+ * reset when get ^E
+ *
+ */
+
+#include <termios.h>
+#include <unistd.h>
+
+static tcflag_t c_lflag;
+static int fd = 1;                              /* STDOUT_FILENO; */
+static struct termios termios_data;
+
+void c_no_echo()
+{
+  tcgetattr( fd, &termios_data );
+  c_lflag = termios_data.c_lflag;
+  termios_data.c_lflag = termios_data.c_lflag & ( ~(ECHO|ICANON|ECHOCTL) );
+  tcsetattr( fd, TCSANOW, &termios_data );
+}
+
+char c_get_char()
+{
+  char c;
+
+  c = getchar();
+  if ( c == '\005')
+  {
+    termios_data.c_lflag = c_lflag;
+    tcsetattr( fd, TCSANOW, &termios_data );
+  }
+  return (char) (c & 0xFF);            /* Ordinary character */
+}
+
+#endif
+
+#if ENVIRONMENT == WIN95
+
+/*
+ * Uses the C function c_no_echo to turn of echoing of input
+ *
+ */
+
+#include <termios.h>
+#include <unistd.h>
+
+void c_no_echo()
+{
+#ifdef WIN95_HAS_TERMIOS
+  static tcflag_t c_lflag;
+  static int fd = STDIN_FILENO;
+  static struct termios termios_data;
+  tcgetattr( fd, &termios_data );
+  c_lflag = termios_data.c_lflag;
+  termios_data.c_lflag = termios_data.c_lflag & (~ECHO);
+  tcsetattr( fd, TCSANOW, &termios_data );
+#endif
+}
+
+#endif